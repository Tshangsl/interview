1. 声明式编程 命令式编程 函数式编程 面向切面编程 响应式编程
    - 两种编程方式 声明式编程/命令式编程
    1. 命令式
        - 命令机器如何做事情 不管你想要什么 它都会按照你的命令实现
    2. 声明式
        - 告诉机器你想要什么 让机器想出如何去做
    > 让一个数组中的数字翻倍
    - 命令式 for循环/声明式 map函数
    - map函数所做的事情是将直接便利整个数组的过程归纳抽离出来 专注于描述我们想要的是什么 传入map的是一个纯函数 它不具有任何副作用(不会改变外部状态)
    - 一些具有函数式编程特征的语言中 对list数据类型的操作 命令式编程for循环 声明式编程 reduce函数 每一次调用 第一个参数都是这个函数处理前一个值时返回的结果 第二个参数就是当前元素
    - reduce函数归纳抽离如何遍历数组和状态管理部分的实现 提供一个通用的方式把list合并成一个值
    ```
    var numbers = [1,2,3,4,5];
    var total = numbers.reduce(function(sum,n){
        return sum+n
    })
    ```
    3. 面向对象编程属于命令编程和声明式的结合
    - 面向对象编程和函数式编程
    1. 面向对象编程 
        - 是命令式编程的一种抽象 抽象包括两方面 数据抽象和过程抽象 
        - 在JS中 面向对象编程(也就是基于对象 因为JS并不是面向对象的语言) 把逻辑和数据封装到函数与原型中 通过函数的原型链拷贝实现继承 代码的运行逻辑与数据依然封装在函数内 但是做了属性和方法的区分
        - 优秀的面向对象编程可以做到声明式编程 也就是根据声明配置生成结果
        - 但是绝大多数的面向对象编程 不会根据声明配置去生成逻辑
    2. 函数式编程
        - 把逻辑完全视为函数的计算 把数据和逻辑封装到函数中 通过对函数的计算 加工 处理 生成新的函数 最后拼装成一个个功能独立的函数 
    
    > 函数式编程思维
    
    > 面向对象编程OOP通过封装变化使代码更易理解 函数式编程通过最小变化使得代码更易理解
    - js是一种拥有很多共享状态的动态语言 代码会随时间变得复杂笨拙难以维护 面向对象设计可在一定程度上解决这个问题 但是还不够
    - 由于有很多状态 所以处理数据流和变化的传递尤为重要 响应式编程有助于处理js异步或事件响应 在设计应用程序时 应考虑是否遵循了以下的设计原则
        - 可扩展性
        - 易模块化
        - 可重用性
        - 可测性
        - 易推理性
    - 函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作 从而在系统中消除副作用并减少对状态的改变

    > 声明式编程
    - 函数式编程属于声明式编程范式：这种范式会描述一系列的操作 但并不会暴露它们是如何实现或数据流如何传入它们
    - SQL就是一种很典型的声明式范式 它由一个个描述查询结果应该是什么样的断言组成 对数据检索的内部机制进行了抽象
    > 命令式 很具体地告诉计算机如何执行某个任务
    > 声明式 将程序的描述和求职分离开 关注如何用各种表达式描述程序逻辑 而不一定指明其控制流或状态关系的变化
    - 去掉代码循环 循环是一种重要的命令控制结构 但很难重用且很呐插入其他操作中 函数式编程旨在金肯呢个提高代码的无状态性和不变性 无副作用的函数 纯函数
    
    > 纯函数
    -  没有副作用的函数 相同的输入有相同的输出
        > 产生副作用的情况
        1. 改变一个全局的变量 属性或数据结构
        2. 改变一个函数参数的原始值
        3. 处理用户输入
        4. 抛出一个异常
        5. 屏幕打印或记录日志
        6. 查询HTML文档 浏览器的cookie或访问数据库
    - 纯函数性质
        1. 仅取决于提供的输入 而不依赖任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态
        2. 不会造成超出作用域的变化 例如修改全局变量或引用传递的参数

    > 引用透明
    - 引用透明是定义一个纯函数较为正确的方法 纯度咋子这个意义上表示一个函数的参数和返回值之间映射的纯的关系 如果一个函数对于相同的输入始终产生相同的结果 引用透明
        > 箭头函数在函数式编程里有一个高大上的名字 叫lambda表达式 对于这种匿名函数在学术上就是叫lambda表达式 JAVA中同样支持

    > 不可变数据
    - 不可变数据是指那些创建后不能更改的数据 与许多其他语言一样 js中有一些基本类型(String Number)从本质上是不可变的 对象可以在任意地方改变

    > 小结
    1. 使用纯函数的代码绝不会更改或破坏全局状态 有助于提高代码的可测试性和可维护性
    2. 函数式编程采用声明式的风格 易于推理 提高代码的可读性
    3. 函数式编程将函数视为积木 通过一等高阶函数来提高代码的模块化和可重用性
    4. 可以利益哦那个响应式编程结合各个函数降低事件驱动程序的复杂性    
    > 面向切面编程思维
    - 这种在运行时 动态地将代码切入到类的指定方法 指定位置上的编程思想就是面向切面的编程
    - 一般而言 管切入到指定类指定方法的代码片段称为切面 而切入到哪些类 那些方法 为切入点
    - 有AOP 可以把几个类共用的代码抽取到一个切片中 等到需要时再切入到对象中 从而改变其原有的腥味
    - 这样看AOP只是OOP的补充 OOP从横面上区分出一个个的类 AOP 从纵面上向对象中加入特定的代码 
    - 有了AOP OOP立体 加上时间维度 AOP使OOP由原来的二维变成三维 由平面变立体 技术上说 AOP是通过代理机制实现的
2. 前端工程化
    - 价值
    1. 为简化用户使用提供技术支持(交互部分)
    2. 为多个浏览器兼容性提供支持
    3. 为提高用户浏览速度(浏览器性能)提供支持
    4. 为跨平台或其他基于webkit或其他渲染引擎的应用提供支持
    5. 为展示数据提供支持(数据接口)
3. 静态类型和动态类型
    > 编程语言按类型检查可分为两大类 
    - 静态类型  Java C/C++ Golang
    - 动态类型  Python Ruby
    > 静态类型和动态类型的区别在于什么时候报类型的错误 
    > 如3/a 静态类型多是在编译时 动态类型多是在程序运行时
    > 编程语言设计时 考虑
    1. 什么程序要类型检查
    2. 怎么执行类型检查
    > 区别
    1. 方便性 Convenience
    动态类型比较方便 因为一个函数可以根据需要返回不同的类型 静态类型需要去构造一个新的数据类型实现
    2. 更早发现错误 Catching bugs earlier
    静态类型在编译时能发现类型上的错误 不用写tests 可以比动态类型更早找到bug 
    3. 性能 Performance
    静态类型程序运行时更快 因为在编译时已进行了检测 不需要存储和检测类型 可以节省程序运行的时间和空间
    4. 代码重用 Code Reuse
    动态类型更好 动态类型代码重用率更高 因为没有严格的类型系统 代码可以被不同类型的数据重用 静态类型有代码重用的很多方法 比如泛型 子类型等 一个list只有一中类型的数据 可以避免一些难找的bug 也可以避免因为类型自由而滥用一些库
    5. 原型开发 Prototyping
    6. 再开发和再维护 Evolution Maintaince
    > 动态语言更合适较小的程序 如Python Ruby 作为脚本语言 简单快速写完对文件的处理  静态语言Java C++ 支持大型的软件工程项目
4. UML（Unified Modeling Language，统一建模语言）:
    > 用来设计软件蓝图的可视化建模语言，一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。
    > 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。
    >基本构件:
        > UML建模核心是模型 模型是现实的简化真实系统的抽象 UML提供了系统的设计蓝图 当给软件系统建模时 需要采用通用的符号语言 这种描述模型所使用的语言被称为建模语言 在UML中 所有的描述由事物 关系 和图这些构建组成
5. 概念
  - OOA(Object-Oriented Analysis)：面向对象的分析
  - OOD(Object-Oriented Design):面向对象的设计

  - POP(Procedure-Oriented Programming):面向过程编程
  - OOP(Object-Oriented Programming):面向对象编程
  - FP(Functional programming):面向函数编程
  - AOP(Aspect Oriented Program):面向切面编程

  - 响应式编程：与异步数据流交互的编程范式
  - 命令式编程
  - 声明式编程
14. 性能优化
    > 页面流畅
    - 大多数设备的屏幕刷新率为60次/秒
    - 每帧的预算时间为16.66毫秒(1000/60 = 16.66毫秒)
    - 页面滑动过程中 浏览器渲染页面的每一帧速率如果和设备屏幕刷新率保持一致 则滑动顺畅
    - 如无法符合此预算 帧率将下降 并且内容会在屏幕上抖动

    > 标准渲染帧
    > Render进程
    - main进程：主进程
    - Compositor进程：接受用户的一些交互操作(如滚动)-唤起main线程进程进行操作-接收main线程的操作结果-commit给真正把页面draw到屏幕上的GPU进程

    > 雅虎军规
    1. Server 页面请求相关
    2. Cookie 页面请求相关
    3. Mobile 页面请求相关
    4. Content 页面渲染相关
    5. Image 页面渲染相关
    6. CSS 页面渲染相关

    > 性能指标 用户体验
    1. First contentful paint(FCP) 第一块内容显示在页面上的时间(lab&field)
    2. Largest contentful paint(LCP) 最大文本块内容或图片显示在页面中的时间(lab&field)
        > 影响因素
        1. 服务端响应时间
        2. js和css引起的渲染卡顿
        3. 资源加载时间
        4. 客户端渲染
        > 解决方案
        1. 预加载最重要的资源
        2. 渲染最核心路径
        3. 懒加载不重要的资源
        4. 缓存资源
        5. 优化css images fonts js
    3. First input delay(FID) 首次与网站进行交互到浏览器真正相应的时间(field)
        > 如何减少FID时间
        1. 减少第三方代码的影响
        2. 减少js的执行时间
        3. 最小化主线程工作
        4. 减小请求数量和请求文件大小
    4. Time to Interactive(TTI) 测量从页面加载到可视化呈现 页面初始化脚本已经加载 并可以可靠地快速响应用户的时间(lab)
    5. Total blocking time(TBT) 测量从FCP到TTI之间的时间 这个时间内主线程被阻塞无法响应用户输入lab
    6. Cumulative layout shift(CLS) 测量从页面开始加载到状态变为隐藏过程中 发生不可预期的layout shift的积累分数(lab&field) 
        > 如何优化CLS
        1. 给图片和video保留大小
        2. 不要在一个已存在的元素上插入内容 除了响应用户输入
        3. animation或transition
    
    > 测量工具
    1. lighthouse(lab) 本地测量
    2. chrome ux report(field) 捞取线上过往28天的数据
    3. chrome dev tools(lab)
    4. search console(field) 查看网站功能整体情况
    5. pagespeed insights(lab&field) 线上和本地比较性能情况
    6. web vitals extersions(field) 实时查看页面核心指标情况

    > update Layer Tree
    - 发生在chrome的渲染引擎Blink内部 尝试

    > 解析DOM树过程
    - DOM tree -> Layer tree
    - div -> render object ->render layer ->graphics layer

    > Render Object 与DOM一一对应
    > Render Layer 层叠上下文 半透明元素 
    > 子Render Layer negZOrderList与posZOrderList

    > 网页渲染机制
    - 纵向分层 横向分块
    - 好处
    1. 减少不必要的绘制操作
    2. 利用硬件加速渲染动画
15. TCB云开发网关架构设计 
    > 前置知识
    - 网关
    - NodeJS&NestJS
    - Docker&k8s

    > 网关
    - 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决
    > 分层架构 软件设计中最常用的一种架构方式 如TCP/1P体系 操作系统体系
    - 分层架构的核心是保证隔层之间边界明显 从而保证逻辑高内聚 层与层之间依赖事先定好的约定 只能按照某个方向单向进行调用 并可以通过加层 快速扩展新的逻辑

    > 三层CS架构
    > 随着多端设备的兴起 多端开发逐渐成为主流 虽然处于不同端 但相同的业务 都会使用同一份数据 当不同端请求走到了后台 后台去数据库查询数据 并且将数据拼接返回给前端
    - 客户端 服务层 数据层

    > 四层CS架构
    - 为保证服务可用性 接口性能 数据安全 后端开发往往需要考虑缓存 限流 降级 鉴权等共 这些功能并不合某个特定业务强关联 并且在各个服务中都是通用的
    > 按照分层架构的思想 将这些功能放在单独一层称为网关 提供功能的服务 称为网关服务
    - 客户端 网关层 服务层 数据层

    > 技术选型
    - Nodejs 单线程 上手简单
    - Go 携程 性能高
    - Java 多线程 生态完善

    > Nodejs
    1. 异步非阻塞的编程模型 async/await语法让开发者用同步写法写出异步代码
    2. 本身适合IO密集型场景 不需要太多前置知识就能写出性能较高的代码
    3. TS的推广 使得类型系统被应用在大型JS项目中
    > 缺点
    1. 单线程瓶颈限制
    2. Nodejs进行数据计算性能非常低
    3. 相较于Java 官方没有支持高级的数据结构和算法

    > 开发框架
    
    > ExpressJS
    > 优点
    1. 社区安装最多
    2. 生态中第三方库最完善
    > 缺点
    1. 不支持AOP
    2. 需要特殊配置支持TS
    3. 没有统一规范 大型项目不易管控
    
    > KoaJS
    > 优点
    1. 基于洋葱模型 可以实现AOP
    2. 生态中第三方库非常完善
    > 缺点
    1. 需要特殊配置支持TS
    2. 没有统一规范 大型项目不易管控

    > EggJS
    > 优点
    1. 基于Express实现
    2. 有统一规范
    > 缺点
    1. 对TS支持差
    2. 官方的规范覆盖场景不全
    3. 国内社区氛围差

    > NextJS
    > 优点
    1. 基于Express实现 且底层支持切换成Fastify等其他NodeJS框架
    2. 基于控制反转和依赖注入进行开发
    3. 完美支持TS 基于最新的ES Class语法
    4. 官方提供完备的配套工具和文档
    5. 支持FP AOP Reactive等开发模式
    6. 有统一规范 并抽象出Controller Middleware Pipd Filter等概念
    > 缺点
    1. 上手成本高

    > 应用场景
    - 云开发网关是业务型网关 主要应用场景是Web端开发 为底层的云函数(Scf) 云托管(Docker)提供HTTP访问形式 目前也支持静态网站托管中的静态资源(COS)
    - 通过默认域名/触发路径访问 就能触发云函数执行并且得到返回结果 或者得到经过CDN缓存的静态王章托管中的资源

    > 系统设计
    1. 前端访问默认域名xxx.app.tcloudbase.com会被路由到k8s网关集群上 网关服务根据触发路径的类型(SCF/Docker) 将不同类型的流量转发到不同的底层服务
    
    > 代码设计
    > 基于Nest提供的概念 将代码模块划分为4大模块
    1. 控制器(Controller) 处理路由逻辑 负责将接收到的请求转发给底层服务
    2. 过滤器(Filter) 使用AOP方式 捕获全局错误 并且统一返回
    3. 中间件(Middleware) 对请求进行修改 比如处理跨域 生成完整的请求上下文信息 并将请求传递给controller
    4. 提供者(Provider) 封装各种能力提供给controller调用 如dns解析 配置读取 异步请求

    > 四大模块中 Provider模块功能最为复杂 为让代码可扩展性更高 参考分层架构设计 将Provider分为3层
    1. Util Layer 
        特点：
        1. 功能简单，代码很少变动
        2. 基本不与其他服务产生数据交换
        功能模块
        1. 日志模块 错误处理模块
    2. Module Layer
        特点
        1. 会和其他服务产生数据交互(Redis 名字服务 DNS)
        2. 封装某项可复用的能力
        功能模块
        1. 缓存模块 名字服务模块
    
    > 并且只能高级Layer中的模块 调用低级Layer中的模块 不能反向调用 从而避免循环引用的产生
    > NestJS针对循环引用提供了解决方案 但是实践中出现了各种奇怪问题 排查难度大 因此要从代码设计上尽量避免循环引用的产生

    > 实际编码中避免循环引用
    > 创建中间provider

    > 配置模块
    > 让给开发者在开发时 快速连通不同的环境 实现快速测试 联调 上线

    > 常见的配置
    1. 命令行变量: 在NodeJS中 可以通过process.env读取命令行变量 一般将其放在.env文件中
    2. 配置文件: 一般将其放在/config文件夹下 需根据不同的环境 编写不同的配置文件

    > 本地开发 配置模块的处理流程
    1. 先读取项目目录下的.env文件 并进行解析
    2. 将解析结果放入到process.env
    3. 根据.env中的环境信息和地狱信息 读取并加载对应的ts配置文件 如对上海地域的生产环境 配置文件名就是config/sh.production.config.ts

    > 线上运行时 配置模块的处理流程
    1. .env文件不会放入git版本库中 当服务部署到K8s上之后 环境变量是通过ConfigMap配置的
    2. 对于不同地域不同环境下的服务 将对应ConfigMap映射为服务Pod中的.env文件 当Pod启动时 处理流程和本地开发一样

    > 日志模块
    1. 能帮助开发者快速复原请求链路上的关键节点的信息 作为定位问题 优化系统性能 监控告警的依据
    2. 设计一个日志模块 首先要考虑到日志结构
    
    > 日志结构设计原则
    1. 字段名尽量简短 可适当添加业务前缀 增强可读性
    2. 字段值需有最大长度 防止日志过多撑爆ELK

    > reqId
    > 任何请求都要生成一个针对请求的唯一标识 REQID
    > 分布式唯一ID的生成算法有数据库生成算法 Snowflake算法 UUID算法 

    > 日志埋点 考虑到打日志的时机 一般会在以下几个场景中打印日志
    - 中间件 如请求进来时 打印logType为IncomingRequest的日志信息 此日志可以用来统计流量
    - 提供者 如在缓存模块中 读取redis缓存时 打印缓存的命中信息 此日志可用来优化缓存设计 提高缓存命中率
    - 业务逻辑 如在触发云函数模块中 打印触发结果信息 此日志可用来进行监控警告

    > 日志存储和展示
    - 本地开发时 需根据日志类型 高亮日志 
    - 对于线上服务 不用高亮日志 将日志统一上传到ELK 交由ELK手机和展示
    - 本地开发时 不需要专门存储日志信息 直接将日志打印到标准输出流即可
    - 线上服务 需要进行双写 将日志写到IPOD的标准输出流 同时将日志写入指定文件 此文件会被脚本手机进行上报

    > 监控告警模块
    > 快速发现线上服务的问题 并将问题下发给开发者 介入恢复服务

    > 名字服务模块
    1. 认识名字服务模块 网关内部 调用其他服务时 需要服务地址 ip:port 在微服务的架构中 并不会在代码中直接写明 ip:port 而是有一个专门的名字服务 用来做服务注册 服务发现等逻辑

    > 为什么需要名字服务
    1. ip:port 不容易在代码中维护和管理 在名字服务中 使用的是服务名字 服务名字通常是不变的 但是其对应的ip:port 可以有很多个 服务提供方也可以在适用房无感知的情况下 
    
    > 有了名字服务之后 处理逻辑是
    1. 引入对应的名字服务的sdk
    2. 传入底层服务的名字 查询底层五福的地址
        - 成功 返回底层服务地址
        - 失败 向名字服务上报错误 并且代码内部抛出错误

    > DNS模块
    - 云开发中 支持配置自定义域名 机械到默认域名上
    - 域名中是带有一些信息的 如云开发环境ID 腾讯云AppID 这些信息会被用作鉴权等逻辑
    - 当用户通过自定义域名访问时 网关服务里请求信息的域名是用户自定义的域名 而不是默认域名
    - 此时 为了查到用户的信息 需要通过DNS查询得到默认域名 再解析默认域名

    > 一般来说 网关系统的转发耗时应该控制在10ms左右

    > DNS服务设计
    - 为优化DNS查询耗时 参考HTTP DNS设计 专门独立出一个DNS服务 会定时(一般是600ms)去扫描用户绑定的自定义域名 
    - 然后将最新的DNS解析结果存储到Mysql中 并将记录同步到Redis

    > 为什么需要一层Redis
    - 通过读写分离 进一步提高系统的读性能 并且防止大批量写入操作阻塞等操作
    - Gateway识别出访问的是自定义域名之后 会走内网链路 调用DNS服务 DNS服务会读取Redis 中的记录 返回给GateWay如果结果为空 则GateWay都低走本地DNS解析

    > 为什么不能在用户设置/修改DNS时 保存解析记录
    - 用户的域名服务不一定托管在同一云厂商 云开发服务无法感知用户对DNS的感知

    > 流量转发模块
    - 转发请求时 网关会在HTTP请求头部添加一些metadata 比如云开发用户名 云开发环境
    - 在和底层服务建立连接之后 有两种数据传输方式
        1. 分块传输 用于云开发SCF
        2. 流式托管 用于云托管和静态托管

    > 总结
    - 现代系统架构中 在前端和后端之间通常有一层网关(也叫中间层 应用层)来承担限流 缓存 鉴权等相对独立的逻辑 在日常开发中Nginx网关
    - 网关作为承接所有流量的入口 服务需要保持高可用和高性能 文中提到的日志模块 监控警告模块是为了保证服务可用性 DNS模块 流量转发 缓存模块是为了提高服务性能 除此之外 网关还做了多地域 多可用区部署 灰度/普通/VIP多集群部署 从而最大程度上保证服务的可用性
    - 服务在设计上也要考虑可扩展性 该文 可扩展性主要体现在代码设计
    - 网关内部模块的分层架构设计
    - 鉴权模块中的鉴权npm库等
16. sdk和api
    - SDK Software Development 软件开发工具包 辅助开发某一类软件的相关文档 范例和工具的集合都可以叫做SDK 软件包
    - API SDK作为一个虚拟的程序包 该程序包中有一份做好的软件功能 该程序包几乎是全封闭的 只有一个小借口可联通外界 这个接口就是API 软件包上的一个接口
17. 聚合查询
18. cos桶
19. 设计态运行态
20. saas
21. toB toC
22. 列权限