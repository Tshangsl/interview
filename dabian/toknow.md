1. 性能优化
    > 页面流畅
    - 大多数设备的屏幕刷新率为60次/秒
    - 每帧的预算时间为16.66毫秒(1000/60 = 16.66毫秒)
    - 页面滑动过程中 浏览器渲染页面的每一帧速率如果和设备屏幕刷新率保持一致 则滑动顺畅
    - 如无法符合此预算 帧率将下降 并且内容会在屏幕上抖动

    > 标准渲染帧
    > Render进程
    - main进程：主进程
    - Compositor进程：接受用户的一些交互操作(如滚动)-唤起main线程进程进行操作-接收main线程的操作结果-commit给真正把页面draw到屏幕上的GPU进程

    > 雅虎军规
    1. Server 页面请求相关
    2. Cookie 页面请求相关
    3. Mobile 页面请求相关
    4. Content 页面渲染相关
    5. Image 页面渲染相关
    6. CSS 页面渲染相关

    > 性能指标 用户体验
    1. First contentful paint(FCP) 第一块内容显示在页面上的时间(lab&field)
    2. Largest contentful paint(LCP) 最大文本块内容或图片显示在页面中的时间(lab&field)
        > 影响因素
        1. 服务端响应时间
        2. js和css引起的渲染卡顿
        3. 资源加载时间
        4. 客户端渲染
        > 解决方案
        1. 预加载最重要的资源
        2. 渲染最核心路径
        3. 懒加载不重要的资源
        4. 缓存资源
        5. 优化css images fonts js
    3. First input delay(FID) 首次与网站进行交互到浏览器真正相应的时间(field)
        > 如何减少FID时间
        1. 减少第三方代码的影响
        2. 减少js的执行时间
        3. 最小化主线程工作
        4. 减小请求数量和请求文件大小
    4. Time to Interactive(TTI) 测量从页面加载到可视化呈现 页面初始化脚本已经加载 并可以可靠地快速响应用户的时间(lab)
    5. Total blocking time(TBT) 测量从FCP到TTI之间的时间 这个时间内主线程被阻塞无法响应用户输入lab
    6. Cumulative layout shift(CLS) 测量从页面开始加载到状态变为隐藏过程中 发生不可预期的layout shift的积累分数(lab&field) 
        > 如何优化CLS
        1. 给图片和video保留大小
        2. 不要在一个已存在的元素上插入内容 除了响应用户输入
        3. animation或transition
    
    > 测量工具
    1. lighthouse(lab) 本地测量
    2. chrome ux report(field) 捞取线上过往28天的数据
    3. chrome dev tools(lab)
    4. search console(field) 查看网站功能整体情况
    5. pagespeed insights(lab&field) 线上和本地比较性能情况
    6. web vitals extersions(field) 实时查看页面核心指标情况

    > update Layer Tree
    - 发生在chrome的渲染引擎Blink内部 尝试

    > 解析DOM树过程
    - DOM tree -> Layer tree
    - div -> render object ->render layer ->graphics layer

    > Render Object 与DOM一一对应
    > Render Layer 层叠上下文 半透明元素 
    > 子Render Layer negZOrderList与posZOrderList

    > 网页渲染机制
    - 纵向分层 横向分块
    - 好处
    1. 减少不必要的绘制操作
    2. 利用硬件加速渲染动画
15. TCB云开发网关架构设计 
    > 前置知识
    - 网关
    - NodeJS&NestJS
    - Docker&k8s

    > 网关
    - 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决
    > 分层架构 软件设计中最常用的一种架构方式 如TCP/1P体系 操作系统体系
    - 分层架构的核心是保证隔层之间边界明显 从而保证逻辑高内聚 层与层之间依赖事先定好的约定 只能按照某个方向单向进行调用 并可以通过加层 快速扩展新的逻辑

    > 三层CS架构
    > 随着多端设备的兴起 多端开发逐渐成为主流 虽然处于不同端 但相同的业务 都会使用同一份数据 当不同端请求走到了后台 后台去数据库查询数据 并且将数据拼接返回给前端
    - 客户端 服务层 数据层

    > 四层CS架构
    - 为保证服务可用性 接口性能 数据安全 后端开发往往需要考虑缓存 限流 降级 鉴权等共 这些功能并不合某个特定业务强关联 并且在各个服务中都是通用的
    > 按照分层架构的思想 将这些功能放在单独一层称为网关 提供功能的服务 称为网关服务
    - 客户端 网关层 服务层 数据层

    > 技术选型
    - Nodejs 单线程 上手简单
    - Go 携程 性能高
    - Java 多线程 生态完善

    > Nodejs
    1. 异步非阻塞的编程模型 async/await语法让开发者用同步写法写出异步代码
    2. 本身适合IO密集型场景 不需要太多前置知识就能写出性能较高的代码
    3. TS的推广 使得类型系统被应用在大型JS项目中
    > 缺点
    1. 单线程瓶颈限制
    2. Nodejs进行数据计算性能非常低
    3. 相较于Java 官方没有支持高级的数据结构和算法

    > 开发框架
    
    > ExpressJS
    > 优点
    1. 社区安装最多
    2. 生态中第三方库最完善
    > 缺点
    1. 不支持AOP
    2. 需要特殊配置支持TS
    3. 没有统一规范 大型项目不易管控
    
    > KoaJS
    > 优点
    1. 基于洋葱模型 可以实现AOP
    2. 生态中第三方库非常完善
    > 缺点
    1. 需要特殊配置支持TS
    2. 没有统一规范 大型项目不易管控

    > EggJS
    > 优点
    1. 基于Express实现
    2. 有统一规范
    > 缺点
    1. 对TS支持差
    2. 官方的规范覆盖场景不全
    3. 国内社区氛围差

    > NextJS
    > 优点
    1. 基于Express实现 且底层支持切换成Fastify等其他NodeJS框架
    2. 基于控制反转和依赖注入进行开发
    3. 完美支持TS 基于最新的ES Class语法
    4. 官方提供完备的配套工具和文档
    5. 支持FP AOP Reactive等开发模式
    6. 有统一规范 并抽象出Controller Middleware Pipd Filter等概念
    > 缺点
    1. 上手成本高

    > 应用场景
    - 云开发网关是业务型网关 主要应用场景是Web端开发 为底层的云函数(Scf) 云托管(Docker)提供HTTP访问形式 目前也支持静态网站托管中的静态资源(COS)
    - 通过默认域名/触发路径访问 就能触发云函数执行并且得到返回结果 或者得到经过CDN缓存的静态王章托管中的资源

    > 系统设计
    1. 前端访问默认域名xxx.app.tcloudbase.com会被路由到k8s网关集群上 网关服务根据触发路径的类型(SCF/Docker) 将不同类型的流量转发到不同的底层服务
    
    > 代码设计
    > 基于Nest提供的概念 将代码模块划分为4大模块
    1. 控制器(Controller) 处理路由逻辑 负责将接收到的请求转发给底层服务
    2. 过滤器(Filter) 使用AOP方式 捕获全局错误 并且统一返回
    3. 中间件(Middleware) 对请求进行修改 比如处理跨域 生成完整的请求上下文信息 并将请求传递给controller
    4. 提供者(Provider) 封装各种能力提供给controller调用 如dns解析 配置读取 异步请求

    > 四大模块中 Provider模块功能最为复杂 为让代码可扩展性更高 参考分层架构设计 将Provider分为3层
    1. Util Layer 
        特点：
        1. 功能简单，代码很少变动
        2. 基本不与其他服务产生数据交换
        功能模块
        1. 日志模块 错误处理模块
    2. Module Layer
        特点
        1. 会和其他服务产生数据交互(Redis 名字服务 DNS)
        2. 封装某项可复用的能力
        功能模块
        1. 缓存模块 名字服务模块
    
    > 并且只能高级Layer中的模块 调用低级Layer中的模块 不能反向调用 从而避免循环引用的产生
    > NestJS针对循环引用提供了解决方案 但是实践中出现了各种奇怪问题 排查难度大 因此要从代码设计上尽量避免循环引用的产生

    > 实际编码中避免循环引用
    > 创建中间provider

    > 配置模块
    > 让给开发者在开发时 快速连通不同的环境 实现快速测试 联调 上线

    > 常见的配置
    1. 命令行变量: 在NodeJS中 可以通过process.env读取命令行变量 一般将其放在.env文件中
    2. 配置文件: 一般将其放在/config文件夹下 需根据不同的环境 编写不同的配置文件

    > 本地开发 配置模块的处理流程
    1. 先读取项目目录下的.env文件 并进行解析
    2. 将解析结果放入到process.env
    3. 根据.env中的环境信息和地狱信息 读取并加载对应的ts配置文件 如对上海地域的生产环境 配置文件名就是config/sh.production.config.ts

    > 线上运行时 配置模块的处理流程
    1. .env文件不会放入git版本库中 当服务部署到K8s上之后 环境变量是通过ConfigMap配置的
    2. 对于不同地域不同环境下的服务 将对应ConfigMap映射为服务Pod中的.env文件 当Pod启动时 处理流程和本地开发一样

    > 日志模块
    1. 能帮助开发者快速复原请求链路上的关键节点的信息 作为定位问题 优化系统性能 监控告警的依据
    2. 设计一个日志模块 首先要考虑到日志结构
    
    > 日志结构设计原则
    1. 字段名尽量简短 可适当添加业务前缀 增强可读性
    2. 字段值需有最大长度 防止日志过多撑爆ELK

    > reqId
    > 任何请求都要生成一个针对请求的唯一标识 REQID
    > 分布式唯一ID的生成算法有数据库生成算法 Snowflake算法 UUID算法 

    > 日志埋点 考虑到打日志的时机 一般会在以下几个场景中打印日志
    - 中间件 如请求进来时 打印logType为IncomingRequest的日志信息 此日志可以用来统计流量
    - 提供者 如在缓存模块中 读取redis缓存时 打印缓存的命中信息 此日志可用来优化缓存设计 提高缓存命中率
    - 业务逻辑 如在触发云函数模块中 打印触发结果信息 此日志可用来进行监控警告

    > 日志存储和展示
    - 本地开发时 需根据日志类型 高亮日志 
    - 对于线上服务 不用高亮日志 将日志统一上传到ELK 交由ELK手机和展示
    - 本地开发时 不需要专门存储日志信息 直接将日志打印到标准输出流即可
    - 线上服务 需要进行双写 将日志写到IPOD的标准输出流 同时将日志写入指定文件 此文件会被脚本手机进行上报

    > 监控告警模块
    > 快速发现线上服务的问题 并将问题下发给开发者 介入恢复服务

    > 名字服务模块
    1. 认识名字服务模块 网关内部 调用其他服务时 需要服务地址 ip:port 在微服务的架构中 并不会在代码中直接写明 ip:port 而是有一个专门的名字服务 用来做服务注册 服务发现等逻辑

    > 为什么需要名字服务
    1. ip:port 不容易在代码中维护和管理 在名字服务中 使用的是服务名字 服务名字通常是不变的 但是其对应的ip:port 可以有很多个 服务提供方也可以在适用房无感知的情况下 
    
    > 有了名字服务之后 处理逻辑是
    1. 引入对应的名字服务的sdk
    2. 传入底层服务的名字 查询底层五福的地址
        - 成功 返回底层服务地址
        - 失败 向名字服务上报错误 并且代码内部抛出错误

    > DNS模块
    - 云开发中 支持配置自定义域名 机械到默认域名上
    - 域名中是带有一些信息的 如云开发环境ID 腾讯云AppID 这些信息会被用作鉴权等逻辑
    - 当用户通过自定义域名访问时 网关服务里请求信息的域名是用户自定义的域名 而不是默认域名
    - 此时 为了查到用户的信息 需要通过DNS查询得到默认域名 再解析默认域名

    > 一般来说 网关系统的转发耗时应该控制在10ms左右

    > DNS服务设计
    - 为优化DNS查询耗时 参考HTTP DNS设计 专门独立出一个DNS服务 会定时(一般是600ms)去扫描用户绑定的自定义域名 
    - 然后将最新的DNS解析结果存储到Mysql中 并将记录同步到Redis

    > 为什么需要一层Redis
    - 通过读写分离 进一步提高系统的读性能 并且防止大批量写入操作阻塞等操作
    - Gateway识别出访问的是自定义域名之后 会走内网链路 调用DNS服务 DNS服务会读取Redis 中的记录 返回给GateWay如果结果为空 则GateWay都低走本地DNS解析

    > 为什么不能在用户设置/修改DNS时 保存解析记录
    - 用户的域名服务不一定托管在同一云厂商 云开发服务无法感知用户对DNS的感知

    > 流量转发模块
    - 转发请求时 网关会在HTTP请求头部添加一些metadata 比如云开发用户名 云开发环境
    - 在和底层服务建立连接之后 有两种数据传输方式
        1. 分块传输 用于云开发SCF
        2. 流式托管 用于云托管和静态托管

    > 总结
    - 现代系统架构中 在前端和后端之间通常有一层网关(也叫中间层 应用层)来承担限流 缓存 鉴权等相对独立的逻辑 在日常开发中Nginx网关
    - 网关作为承接所有流量的入口 服务需要保持高可用和高性能 文中提到的日志模块 监控警告模块是为了保证服务可用性 DNS模块 流量转发 缓存模块是为了提高服务性能 除此之外 网关还做了多地域 多可用区部署 灰度/普通/VIP多集群部署 从而最大程度上保证服务的可用性
    - 服务在设计上也要考虑可扩展性 该文 可扩展性主要体现在代码设计
    - 网关内部模块的分层架构设计
    - 鉴权模块中的鉴权npm库等
16. sdk和api
    - SDK Software Development 软件开发工具包 辅助开发某一类软件的相关文档 范例和工具的集合都可以叫做SDK 软件包
    - API SDK作为一个虚拟的程序包 该程序包中有一份做好的软件功能 该程序包几乎是全封闭的 只有一个小借口可联通外界 这个接口就是API 软件包上的一个接口
17. 聚合查询
18. cos桶
19. 设计态运行态
20. saas
21. toB toC
22. 列权限
23. git工作流 
    1. 之前的git工作流
    2. rebase做什么 一般解决什么问题
        - 可以对某一段先行提交历史 进行编辑 删除 复制 粘贴 因此 合理使用rebase命令可以使我们的提交历史干净简洁
        - 不要通过rebase对任何已提交到公共仓库的commit进行修改
        - 使用git log 可以按s向下翻log
        - git log -oneline 可以一行展现
    3. 如何合并多个commit
    4. 具体操作 
        - 本地仓库提交多次 在把本地提交push进公共仓库之前 为了让提交记录更简洁明了 把如下分支B C D三个提交记录合并成一个完整的提交 然后push到公共仓库
        ```
        git rebase -i [startpoint] [endpoint]
        ```
        - -i的意思是--interactive 即弹出交互式的界面让用户编辑完成合并操作 [startpoint][endpoint]指定一个编辑区间 如果不指定[endpoint]则该区间的终点默认是当前分支HEAD所指向的commmit(该区间指定的是一个前开后闭的区间) 在查看到了log日志后 运行以下命令
        ```
        git rebase -i 36224db
        ```
        ```
        git rebase -i HEAD-3
        ```

https://xin-tan.com/2020-10-08-duo-ji-huan-cun/