1. shim()/垫片
    - 一个小型库，可透明地截取API，更改传递的参数，处理操作本身，或将操作重定向到别处。
    - 垫片通常在API的行为发生变化时出现，从而导致仍依赖旧功能的旧应用程序出现兼容性问题。在这些情况下，较新的代码之上的较薄的兼容层仍然可以支持较旧的API。垫片也可以用于在不同的软件平台上运行程序，而不是开发它们。
2. 什么是回调函数 什么是回调地域
    > 回调函数
    - 编程分为两类：
    1. 系统编程，简单来说，就是编写库；
        - 系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。
        - 所以在抽象层的图示里，库位于应用的底下。
    2. 应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。
        - 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。
        - 但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。
    - 回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）
    而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。
    （我认为）这应该是回调最早的应用之处，也是其得名如此的原因。
    > 回调函数的第1个参数是什么?
    - 通常是错误对象。如果这个参数为空，表示没有错误。
    
    > 错误优先的回调函数
    - 错误有限的回调函数用于传递错误和数据
    - 第一个参数始终应该是一个错误对象 用于检查程序是否发生了 错误 其余参数用于传递数据

    > 如何避免回调地狱
    1. 模块化 将回调函数分割为独立的函数
    2. 使用Promises
    3. 使用yield
    4. 计算生成器或Promise
3. 声明式编程 命令式编程 函数式编程 面向切面编程 响应式编程
    - 两种编程方式 声明式编程/命令式编程
    1. 命令式
        - 命令机器如何做事情 不管你想要什么 它都会按照你的命令实现
    2. 声明式
        - 告诉机器你想要什么 让机器想出如何去做
    > 让一个数组中的数字翻倍
    - 命令式 for循环/声明式 map函数
    - map函数所做的事情是将直接便利整个数组的过程归纳抽离出来 专注于描述我们想要的是什么 传入map的是一个纯函数 它不具有任何副作用(不会改变外部状态)
    - 一些具有函数式编程特征的语言中 对list数据类型的操作 命令式编程for循环 声明式编程 reduce函数 每一次调用 第一个参数都是这个函数处理前一个值时返回的结果 第二个参数就是当前元素
    - reduce函数归纳抽离如何遍历数组和状态管理部分的实现 提供一个通用的方式把list合并成一个值
    ```
    var numbers = [1,2,3,4,5];
    var total = numbers.reduce(function(sum,n){
        return sum+n
    })
    ```
    3. 面向对象编程属于命令编程和声明式的结合
    - 面向对象编程和函数式编程
    1. 面向对象编程 
        - 是命令式编程的一种抽象 抽象包括两方面 数据抽象和过程抽象 
        - 在JS中 面向对象编程(也就是基于对象 因为JS并不是面向对象的语言) 把逻辑和数据封装到函数与原型中 通过函数的原型链拷贝实现继承 代码的运行逻辑与数据依然封装在函数内 但是做了属性和方法的区分
        - 优秀的面向对象编程可以做到声明式编程 也就是根据声明配置生成结果
        - 但是绝大多数的面向对象编程 不会根据声明配置去生成逻辑
    2. 函数式编程
        - 把逻辑完全视为函数的计算 把数据和逻辑封装到函数中 通过对函数的计算 加工 处理 生成新的函数 最后拼装成一个个功能独立的函数 
    
    > 函数式编程思维
    - 面向对象编程OOP通过封装变化使代码更易理解 函数式编程通过最小变化使得代码更易理解
    - js是一种拥有很多共享状态的动态语言 代码会随时间变得复杂笨拙难以维护 面向对象设计可在一定程度上解决这个问题 但是还不够
    - 由于有很多状态 所以处理数据流和变化的传递尤为重要 响应式编程有助于处理js异步或事件响应 在设计应用程序时 应考虑是否遵循了以下的设计原则
        - 可扩展性
        - 易模块化
        - 可重用性
        - 可测性
        - 易推理性
    - 函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作 从而在系统中消除副作用并减少对状态的改变
    > 函数式编程
    1. 不能依赖除了入参以外的任何其他变量
    2. 必须要有确定的单一的返回值

    > 副作用
    - 函数内部和外部有互动
    1. 依赖其他的共享装填或者变量
    2. 在内存中有写入操作
    3. 打印到控制台 读取用户输入
    4. 调用了其他非纯函数
    5. 发起了请求
    - 改变了计算机的状态 服务器的状态 函数的状态都不行

    - 函数式编程的目的不是完全杜绝副作用的产生 而是利用某些易于管理的副作用的小部分代码 保证整个程序的可读性和可维护性

    > 声明式编程
    - 函数式编程属于声明式编程范式：这种范式会描述一系列的操作 但并不会暴露它们是如何实现或数据流如何传入它们
    - SQL就是一种很典型的声明式范式 它由一个个描述查询结果应该是什么样的断言组成 对数据检索的内部机制进行了抽象
    > 命令式 很具体地告诉计算机如何执行某个任务
    > 声明式 将程序的描述和求职分离开 关注如何用各种表达式描述程序逻辑 而不一定指明其控制流或状态关系的变化
    - 去掉代码循环 循环是一种重要的命令控制结构 但很难重用且很呐插入其他操作中 函数式编程旨在金肯呢个提高代码的无状态性和不变性 无副作用的函数 纯函数
    
    > 纯函数
    -  没有副作用的函数 相同的输入有相同的输出
        > 产生副作用的情况
        1. 改变一个全局的变量 属性或数据结构
        2. 改变一个函数参数的原始值
        3. 处理用户输入
        4. 抛出一个异常
        5. 屏幕打印或记录日志
        6. 查询HTML文档 浏览器的cookie或访问数据库
        7. 网络请求 访问浏览器缓存
    - 纯函数性质
        1. 仅取决于提供的输入 而不依赖任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态
        2. 不会造成超出作用域的变化 例如修改全局变量或引用传递的参数

    > 引用透明
    - 引用透明是定义一个纯函数较为正确的方法 纯度咋子这个意义上表示一个函数的参数和返回值之间映射的纯的关系 如果一个函数对于相同的输入始终产生相同的结果 引用透明
        > 箭头函数在函数式编程里有一个高大上的名字 叫lambda表达式 对于这种匿名函数在学术上就是叫lambda表达式 JAVA中同样支持

    > 不可变数据
    - 不可变数据是指那些创建后不能更改的数据 与许多其他语言一样 js中有一些基本类型(String Number)从本质上是不可变的 对象可以在任意地方改变

    > 小结
    1. 使用纯函数的代码绝不会更改或破坏全局状态 有助于提高代码的可测试性和可维护性
    2. 函数式编程采用声明式的风格 易于推理 提高代码的可读性
    3. 函数式编程将函数视为积木 通过一等高阶函数来提高代码的模块化和可重用性
    4. 可以利用响应式编程结合各个函数降低事件驱动程序的复杂性    
    
    > 面向切面编程思维
    - 运行时 动态地将代码切入到类的指定方法 指定位置上的编程思想就是面向切面的编程
    - 一般而言 管切入到指定类指定方法的代码片段称为切面 而切入到哪些类 那些方法 为切入点
    - 有AOP 可以把几个类共用的代码抽取到一个切片中 等到需要时再切入到对象中 从而改变其原有的腥味
    - 这样看AOP只是OOP的补充 OOP从横面上区分出一个个的类 AOP 从纵面上向对象中加入特定的代码 
    - 有了AOP OOP立体 加上时间维度 AOP使OOP由原来的二维变成三维 由平面变立体 技术上说 AOP是通过代理机制实现的
4. 前端工程化
    > 可以分为四个方面来说 分别为
    1. 模块化 
        - 将一个文件拆分成多个相互依赖的文件 最后进行统一的打包和加载 这样能很好的保证高效的多人协作 其中包含
        1. JS模块化 CommonJS AMD CMD ES6 Module
        2. CSS模块化 Sass Less
        3. 资源模块化  
    2. 组件化 
        - 不同于模块化 模块化是对文件 对代码和资源拆分 组件化是对UI层面的拆分
        - 考虑细粒度和通用性
    3. 规范化 
        - 工程开发初期以及开发期间指定的系列规范 
        1. 项目目录结构
        2. 编码规范:
        3. 联调规范
        4. 文件命名规范
        5. 样式管理规范
        6. git flow工作流:其中包含分支命名规范 代码合并规范等
        7. 定期code review
    4. 自动化
        - 从最早先的grunt gulp等 
        - 再到目前的webpack parcel
        - 这些自动化工具在自动化合并 构建 打包都能为我们节省很多工作
        - 而这些只是前段自动化其中的一部分 前端自动化还包含持续集成 自动化测试德国方方面面
    - 价值
    1. 为简化用户使用提供技术支持(交互部分)
    2. 为多个浏览器兼容性提供支持
    3. 为提高用户浏览速度(浏览器性能)提供支持
    4. 为跨平台或其他基于webkit或其他渲染引擎的应用提供支持
    5. 为展示数据提供支持(数据接口)
5. 静态类型和动态类型
    > 编程语言按类型检查可分为两大类 
    - 静态类型  Java C/C++ Golang
    - 动态类型  Python Ruby
    > 静态类型和动态类型的区别在于什么时候报类型的错误 
    > 如3/a 静态类型多是在编译时 动态类型多是在程序运行时
    > 编程语言设计时 考虑
    1. 什么程序要类型检查
    2. 怎么执行类型检查
    > 区别
    1. 方便性 Convenience
    动态类型比较方便 因为一个函数可以根据需要返回不同的类型 静态类型需要去构造一个新的数据类型实现
    2. 更早发现错误 Catching bugs earlier
    静态类型在编译时能发现类型上的错误 不用写tests 可以比动态类型更早找到bug 
    3. 性能 Performance
    静态类型程序运行时更快 因为在编译时已进行了检测 不需要存储和检测类型 可以节省程序运行的时间和空间
    4. 代码重用 Code Reuse
    动态类型更好 动态类型代码重用率更高 因为没有严格的类型系统 代码可以被不同类型的数据重用 静态类型有代码重用的很多方法 比如泛型 子类型等 一个list只有一中类型的数据 可以避免一些难找的bug 也可以避免因为类型自由而滥用一些库
    5. 原型开发 Prototyping
    6. 再开发和再维护 Evolution Maintaince
    > 动态语言更合适较小的程序 如Python Ruby 作为脚本语言 简单快速写完对文件的处理  静态语言Java C++ 支持大型的软件工程项目
    - Stctic typing when possible dynamic typing when needed
6. UML（Unified Modeling Language，统一建模语言）:
    > 用来设计软件蓝图的可视化建模语言，一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。
    > 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。
    >基本构件:
        > UML建模核心是模型 模型是现实的简化真实系统的抽象 UML提供了系统的设计蓝图 当给软件系统建模时 需要采用通用的符号语言 这种描述模型所使用的语言被称为建模语言 在UML中 所有的描述由事物 关系 和图这些构建组成
7. 概念
  - OOA(Object-Oriented Analysis)：面向对象的分析
  - OOD(Object-Oriented Design):面向对象的设计

  - POP(Procedure-Oriented Programming):面向过程编程
  - OOP(Object-Oriented Programming):面向对象编程
  - FP(Functional programming):面向函数编程
  - AOP(Aspect Oriented Program):面向切面编程

  - 响应式编程：与异步数据流交互的编程范式
  - 命令式编程
  - 声明式编程

    concurrency并发
    non-blocking 非阻塞
    event-loop 事件轮询
    callback 回调函数
    asynchronous 异步的
    single-threaded 单线程
    FPS(frames-per-second)
    JS有
        call stack
        event loop
        callback quene
        API
    V8有
        heap
        callstack(调用栈)
    web API
        DOM
        AJAX
        timeout(setTimeout setInterval)
    single threaded === single call stack === do one thing at a time
8. API函数的类型有哪些
    1. 一种是阻滞型函数。阻滞型函数会等待操作完成以后再进行下一步。
    2. 另外一种是非阻滞型函数。这种函数使用回调函数来处理当前函数获取的结果。
    > repl
    - Read evaluate print loop， 用于测试，调试和实验用。
    > 测试金字塔
    - 编写测试用例时 底层的单元测试应该远比上层的端到端测试要多
    - 谈到Http API时 可能会涉及到
    1. 有很多针对模型的底层单元测试
    2. 需要测试模型
    > C++和JS交互
    - 如何通过V8实现JS调用C++ 
    - JS调用C++ 分为
    1. JS调用C++函数(全局)
    2. 调用C++类
9. 如何让异步代码同步化
    1. promise
    ```
    const {promisify} = require('util');
    const readFile = promisify(fs.readFile);
    readFile('./01-runnode.js').then(data=>console.log(data))
    ```
    2. Promise API(node的版本在10.0以上)
    ```
    const {promises} = require('fs');
    promises.readFile('./1.js').thenm(data=>{console.log(data)})
    ```
    3. genenrator
    4. aysnc
10. 循环引用/依赖
    - a文件require了b文件 b文件require了a文件
    - 循环引用不会报错 导致的结果是require的结果是空对象{} 原因是b require 了a a又去require了b 此时b还没有初始化好 所以只能拿到初始值{}
    > 两种方法解决循环引用
    1. 通过分离公用的代码到另一个文件解决
    2. 不在最外层require 在用到的地方require 通常在函数内部
11. 同步异步和阻塞非阻塞
    - 同步异步取决于被调用者 阻塞非阻塞取决于调用者
        - 阻塞调用是指调用结果返回之前 当前线程会被挂起 调用线程只有得到结果之后才会返回
        - 非阻塞调用是指在不能立刻得到结果之前 该调用不会阻塞当前线程
12. 前端鉴权方案
    > 常见的前端解决方案
    1. HTTP Basic Authentication
        概念：
            HTTP Basic Authentication授权方式是浏览器遵守http协议实现的基本授权方式，HTTP协议进行通信的过程中，HTTP协议定义了允许HTTP服务器对客户端进行用户身份验证的方法。
        认证过程
            第一步：客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证；
              第二步：服务器向客户端发送验证请求代码401，然后弹出用户登录界面；
              第三步：用户输入用户信息和密码，浏览器会自动以base64形式进行加密；
              第四步：服务器收到请求之后，将信息解密，将其与数据库中的用户信息进行对比，一直的话返回用户需要的请求内容。
              登录失效的方案：在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的Authentication信息为注销用户名密码的时候便注销成功了，而客户端在注销操作的时候，手动的去修改请求头的Authentication，将它设置为服务器默认的注销账号和密码。
    2. session-cookie
        概念：
            利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，由于http请求时是无状态的，需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建seesion，如果有则已经认证成功了，否则就没有认证。
        认证过程：
            1.服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion到内存当中，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。
             2.浏览器中收到请求响应的时候会解析响应头，然后将session_id保存在本地cookie中，浏览器在下次http请求时请求头中会带上该域名下的cookie信息
             3.服务器在接受客户端请求时会去解析请求头cookie中的session_id，然后根据这个session_id去找服务器端保存的该客户端的session，然后判断该请求是否合法.
    3. Token 验证
        认证过程：
            1.客户端使用用户名跟密码请求登录；
            2.服务端收到请求，去验证用户名与密码；
            3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
            4.客户端收到Token以后可以把它存储起来，比如放在Cookie 里或者Local Storage里；
            5.客户端每次向服务端请求资源的时候需要带着服务端签发的Token；
            6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据。
        token验证方案JWT：
            一、JWT概念
                  JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成json对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。
                二、JWT组成
                 Headers： 包括类别（typ）、加密算法（alg）；
                 Claims ：包括需要传递的用户信息；
                 Signature： 根据alg算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密；
    4. OAuth(开放授权)
        概念：
            OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有支付宝，QQ,微信。
        OAuth认证过程
            第一步：向用户请求授权，而当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面；
              第二步：当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址redirect_uri的后面；
              第三步：用户再去请求时携带用户凭证（code），验证服务器返回一个访问令牌（Access Token）；
              第四步：再去拿着令牌请求资源时，就会得到受保护的资源信息。
13. 即时通讯的实现
    - 短轮询/长轮询/SSE(基于HTTP协议) WebSocket(基于TCP协议 典型的应用层协议)
    区别
    (目的都是实现客户端/服务器端一个即时通讯)
    1. 短轮询的基本思路(基于HTTP协议)
    实现原理：
        浏览器每隔一段时间向浏览器发送 HTTP 请求，
        服务器端在收到请求后，不论是否有数据更新，都直接进行响应。
        这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，
        通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
    优点：
        比较简单，易于理解。
    缺点：
        该方式由于需要不断的建立 HTTP 连接
        严重浪费了服务器端和客户端的资源。
        当用户增加时，服务器端的压力就会变大，这是很不合理的。
    2. 长轮询的基本思路(基于HTTP协议)
    - 实现原理:
        (服务器不会直接进行响应而是先将这个请求挂起 判断服务器端数据是否有更新)
        首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起 判断服务器端数据是否有更新。
        如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。
        客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。
    > 长轮询和短轮询相比
    - 优点：
        明显减少了很多不必要的 HTTP 请求次数，相比之下节约了资源。
    - 缺点：
        连接挂起也会导致资源的浪费。
    3. SSE- Server-sent Events (基于HTTP协议 单向 数据流如视频播放 服务端=>客户端)
    (服务端向客户端声明接下来要发送的是流信息 发送的不是一次性的数据包 而是一个数据流 如视频播放)
    - 实现原理:
        服务器使用流信息向服务器推送信息。严格地说，HTTP1.x 协议无法做到服务器主动推送信息。
        有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。
        也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。
        这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。
        SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于HTTP协议目前除了 IE/Edge，其他浏览器都支持。
    优点:   
        它相对于前面两种方式来说，不 需要建立过多的 http 请求，相比之下节约了资源。
    4. WebSocket
    (H5新定义的一个协议 基于TCP协议 全双工 双向 该协议允许服务器主动向客户端推送信息)
    上面三种方式本质上都是基于HTTP协议的.我们还可以使用 WebSocket 协议来实现。
    WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。
    缺点：
        服务器端的配置比较复杂。
    WebSocket与SSE区别：    
    WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息
    而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个HTTP请求了。
    4. WebSocket和SSE
        (WebSocket一个全双工协议 通信双方平等 可以互发消息)
        (SSE服务器端向浏览器端单向通信 如用户需要发送信息 属于下一个HTTP请求)
    5. WebSocket和HTTP
        (相同 一样基于TCP都是可靠性传输协议/应用层协议)
        (不同 WebSocket双向通信协议 模拟Socket协议 可双向发送或接收请求 HTTP单向/WebSocket需握手进行建立连接)
        (联系 WebSocket协议建立握手时 数据通过HTTP传输 建立后真正传输不需要HTTP协议)
        相同点：
        1. 都是一样基于TCP都是可靠性传输协议
        2. 都是应用层协议
        不同点:
        1. Websocket是双向通信协议 模拟Socket协议 可以双向发送或接受请求 HTTP是单向的
        2. WebSocket需要握手进行建立连接
        联系:
        1. WebSocket协议在建立握手时 数据是通过HTTP传输的
        但是建立后真正传输时不需要HTTP协议
    6. WebSocket和Socket关系
        (WebSocket(典型的应用层协议)
        Socket:
            (不是一个协议 是为了方便使用TCB/UDP抽象出来的一层)
            (不是一个协议 是为方便使用TCP/UDP抽象出来位于应用层和传输控制层间的一组接口))
            是位于应用层和传输控制层之间的一组接口
            Sockets是应用层和TCP/IP协议族通信的中间软件抽象层 它是一组接口 
            在设计模式中Socket其实就是一个门面模式 它把复杂的TCP/IP协议族隐藏在Socket接口后面
            对用户来说 一组简单的接口就是全部 让Socket去组织数据以符合指定的标准
            当两台主机通信时 必须通过Socket连接
            Socket则利用TCP/IP协议建立TCP连接 
            TCP连接更依赖于底层的IP协议 
            IP协议的连接则依赖于链路层等更低层次
        WebSocket协议:
            WebSocket是一个典型的应用层协议
        总结：
            Socket是传输控制层协议
            WebSocket是引用层协议
    7. WebSocket和HTML5的关系
        (WebSocket API是H5标准一部分 WebSocket不必一定要用在HTML/基于浏览器应用程序中)
        (许多语言/框架 服务器都提供WebSocket支持)
        WebSocket API是HTML5标准的一部分 
        但这不代表WebSocket一定要用在HTML中
        或者只能在基于浏览器中的应用程序中使用
        实际上许多语言 框架 服务器都提供了WebSocket支持
14. XML与JSON
    XML定义
        扩展标记语言 EXtensible Markup Language XML
        用于标记电子文件使其具有结构性的标记语言 
        可以用来标记数据 定义数据类型 是一种允许用户对自己的标记语言进行定义的源语言
        XML使用DTD文档类型定义来组织数据 格式统一 跨平台和语言 称为业界公认的标准
        XML是标准通用标记语言SGML的子集 非常适合Web传输 
        XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据
    > JSON JavaSript Object Notation
        一种轻量级数据交换格式
        具有良好的可读和便于快速编写的特性
        可在不同平台之间进行数据交换
    - XML优点:
        1. 格式统一 符合标准
        2. 容易与其他系统进行远程交互 数据共享比较简单
    - XML缺点:(庞大 解析费时 )
        1. XML文件庞大 文件格式复杂 传输占带宽
        2. 服务端和客户端都需要花费大量代码解析XML 导致服务器端和客户端代码变得异常复杂且不易维护
        3. 客户端不同 浏览器之间解析XML方式不同 需要重复编写很多代码
    - JSON优点(数据格式简单/易于解析/支持多种语言/同时被服务器端代码使用)
        1. 数据格式比较简单 易于读写 格式都是压缩的 占用带宽小
        2. 易于解析 客户端JS可简单通过eval()进行JSON数据读取
        3. 支持多种语言 包括ActionScript C Java JavaScript Perl PHP Python Ruby等服务器端语言 便于服务器端解析
        4. JSON格式能直接为服务器端代码使用 大大简化了服务器端和客户端的代码开发量 且完成任务不变 易于维护
    - JSON缺点(没有XML那么通用)
        1. 没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性
        2. JSON格式目前在Web Service中推广还属于初级阶段
    XML与JSON优缺点对比
    (可读性/可扩展性/解析手段)
    (JSON编码难度较低/JSON解析难度基本为0/JSON数据体积更小/数据交互更方便/传输速度较快)
    (XML流行度较高/数据描述较好)
        1.可读性方面
            JSON和XML的数据可读性基本相同
            XML可读性较好些
        2.可扩展性方面
            XML天生有很好的扩展性
            JSON也是 
            没有什么是XML能扩展
            JSON不能的
        3.编码难度方面
            XML有丰富的编码工具
            JSON也有json.org提供的工具
            JSON的编码明显比XML容易许多
        4.解码难度方面
            XML解析考虑子节点 父节点
            JSON解析难度几乎为0
        5.流行度方面
            XML已经被业界广泛的使用 而JSON才刚刚开始
            但是在Ajax这个特定的领域 
            未来的发展一定是XML让位于JSON
            到时Ajax应该变成Ajaj
            (Asynchronous Javascript and JSON)
        6.解析手段方面
            JSON和XML同样拥有丰富的解析手段
        7.数据体积方面
            JSON相对于XML 数据体积更小 传递速度更快
        8.数据交换方面
            JSON和JS的交互更加方便 
            更容易解析处理 更好的数据交互
        9.数据描述方面
            JSON对数据的描述性比XML较差
        10.传输速度方面
            JSON的速度远远比XML快
    XML与JSON数据格式比较
    (XML 两种解析方式 DOM&SAX 适合于对大量数据的处理)
    (JSON 只提供整体解析方案 解析较少数据时起到良好作用)
        1.关于轻量级/重量级
            轻量级和重量级是相对而言的
            XML相对于JSON的重量级体现在
            解析上
            XML目前设计了两种解析方式
            DOM&SAX
            JSON只提供整体解析方案
                这种方法只在解析较少的数据时才能起到良好效果
            XML提供对大规模数据的逐步解析方案
                这种方案很适合于对大量数据的处理
    引申XPath(用于在XML文档中通过属性和元素进行导航)
        一门在XML文档中查找信息的语言
        XPath用于在XML文档中通过属性和元素进行导航
    XPath
        1.XPath使用路径表达式在XML文档中进行导航
        2.XPath包含一个标准数据库
        3.XPath是XSLT中的主要元素
        4.XPath是一个W3C标准
15. JSON和JSONP
    - JSON(JavaScript Object Notation)
        一种轻量级的数据交换格式
    - JSONP(JavaScript With Padding) 被包裹的JSON
        一个非官方的协议 它允许在服务器端集成Scripttags返回至客户端 通过JavaScript callback形式实现跨域访问
16. 计算机网络体系结构
    OSI(Open System Interconnection 开放式系统互连)七层协议
        应用层：允许访问OSI环境的手段
    　　表示层：对数据进行翻译、加密和压缩
    　　会话层：建立、管理和终止会话
    　　传输层：提供端到端的可靠报文传递和错误恢复
    　　网络层：负责数据包从源到宿的传递和网际互连
        数据链路层
    　　物理层：通过媒介传输比特,确定机械及电气规范
    TCP/IP四层协议(现在广泛使用的)
        应用层(HTTP HTTPS各种应用层协议和TELNET FTP SMTP)
        运输层(TCP/UDP)
        网际层(IP)
        网络接口层
    五层协议(并不存在 讲课用)
        应用层
        传输层
        网络层
        数据链路层
        物理层
17. 后端接口设计
    一个后端接口大致分为四个部分
        接口地址 URL
        接口请求方式 get/post
        请求数据 request
        响应数据 response
    参数校验
        一个接口一般对参数(请求数据)都会进行安全校验
        1.业务层校验
            1.接收数据
            2.参数验证
            3.连接数据库
            4.根据数据库操作结果返回相应的信息
    错误码设计
        ctx.body={
            state:'success'/'fail'
        }
18. Nodejs解决跨域问题9种方案
    > 什么是跨域
    - 一个域下的文档或脚本尝试去请求另一个域下的资源 这里跨域是广义的
    > 广义的跨域
    1. 资源跳转: A链接 重定向 表单提交
    2. 资源嵌入: <link><script><img><frame>等dom标签 还有央视中background:url(),@font-face()等文件外链
    3. 脚本请求: JS发起的AJAX请求 dom和js对象的跨域操作
    > 狭义
    - 通常所说的跨域是狭义的 是由浏览器同源策略限制的一类请求场景
    > 同源策略/SOP(Same origin policy)是一种约定 由NetScape公司1995年引入浏览器 它是浏览器最核心也最基本的安全功能 如果缺少了同源策略 浏览器很容易瘦到XSS CSRF攻击 
    - 同源是指协议+域名+端口 
    > 同源策略限制行为
    1. Cookie LocalStorage 和IndexDB无法读取
    2. DOM和JS对象无法获得
    3. AJAX请求不能发送
    > axios发起请求
    ```
    axios.get('http://127.0.0.1:3000/user').then(res=>{
        console.log(res.sata)
    }).catch(err=>{
        console.log(err);
    })
    ```
    > 跨域常用解决方案
    1. 通过JSONP跨域
        - 通常为了减轻web服务器负载 把js css html等静态资源分离到另一台独立域名的服务器上 在html页面中再通过相应的标签从不同的域名下加载静态资源 二倍浏览器允许
        - 基于此 可以通过动态创建script 再请求一个带参数网址实现跨域通信
        - axois最新版本已经不支持jsonp了
    2. 跨域资源共享(CORS最常用)
    3. nginx代理跨域
        - 实现原理类似node中间件代理 需要搭建一个中转nginx服务器 用于转发请求
        - 使用nginx反向代理实现跨域是最简单的跨域方式 只要修改nginx的配置即可解决跨域问题 支持所有浏览器 支持session 不需要修改任何代码 并且不会影响服务器性能
        - 实现思路：通过nginx配置一个代理服务器(域名与domain1相同 端口不同)做跳板机 反向代理访问domain2接口 并且可以顺便修改cookie中domain信息 方便当前域cookie写入 实现跨域登录
    4. node中间件代理跨域
        - 实现原理
        - 同源策略是浏览器要遵循的标准 如果是服务器向服务器请求就无需遵循同源策略 代理服务器 需要做以下几个步骤
        1. 接受客户端请求
        2. 将请求转发给服务器
        3. 拿到服务器响应数据
        4. 将响应转发给客户端

    1. document.domain+iframe(只有在主域相同的时候才能使用该方法)
    2. 动态创建script标签(script标签不受同源策略限制)
    3. location.hash+iframe(利用location.hash来进行传值)
    4. window.name+iframe(name值在不同的页面加载后依旧存在 并且可以支持非常长的name值(2MB))
    5. postMessage(HTML5中的XMLHttpRequest Level2中的API)
    6. Web Socket(WebSocket是一种浏览器的API 它的目标是在一个单独的持久连接上提供全双工 双向通信(同源策略对web sockets不适用))
19. 单点登录 多点登录
    - 单点登录SSO
        一个多系统共存的环境下
        用户的一次登录能得到其他所有系统的信任
    - 多点登录
        以微信为例
            可以PC端 phone端同时登陆/收发消息
            但是一个端只能登录一个实例 
            pc1登录 pc2登录 后者会把前者踢出 
        同一个账号可以在不同终端同时登录 同时收发信息
        禁止用户多点在线
        一个端同一个账号只能登录一个实例  
20. > mobx
    > 优点
    1. redux不允许直接修改state，而mobx可随意修改
    2. redux修改状态必须走一套指定的流程比较麻烦，mobx可在任何地方直接修改(非严格模式下)
    3. redux模版代码文件多，而mobx非常简洁，就一个文件
    4. redux只有一个store，state or store 难以取舍，mobx多store 可以把所有的state都放入store中 完全交给mobx管理 减少顾虑
    5. redux需要对监听的组件做scu优化，减少重复render，而mobx都是smartcomponent 不需要手动做scu

    > 原理
    1. 利用了es6的proxy追踪属性(旧版本使用object.defineproperty实现)通过隐式订阅 自动追踪被监听的对象变化 然后触发组件的ui更新

    > 区别
    - redux把要做的事情都交给用户 保证自己的纯净 mobx把最简易的操作给了用户 其他交给mobx内部实现 用户不必关心该过程 mode和view完全分离 完全可以讲业务逻辑写在action里 用户只需操作observeabledata
    - observalbeview会自动做出响应 此即为mobx主打的响应式设计 但编程风格仍然是传统的面向对象的oo范式(vue即利用数据劫持实现双向绑定 react+mobx就是一个复杂点的vue vue3版本的一个重大改变就是将代理交给了proxy)

    > 优点
    1. 代码量少
    2. 基于数据劫持实现精准定位(真正意义上的局部更新)
    3. 多store抽离业务逻辑(model view分离)
    4. 响应式性能良好(频繁的交互依然可以胜任)
    5. 完全可以替代react自身的状态管理
    6. 支持ts

    > 缺点
    1. 没有状态回溯能力：mobx直接修改对象引用 很难去做状态回溯
    2. 没有中间件：和redux一样 mobx也没有很好的方法处理异步数据流 没办法更精细地控制数据流动(redux虽然自己不做 但它提供了applymiddleware)
    3. store太多： 随store数量增多 维护成本也会增加 且多store之间的数据共享以及相互饮用也会出错
    4. 副作用：mobx直接修改数据 和函数式编程模式强调的纯函数相反 这导致了数据的很多未知性

    > 主流数据流管理分为两大派
    1. 以redux为首的函数式库
    2. 以mobx为首的响应式库
    3. redux和mobx有一个共同的短板 即在处理异步数据流时 没有一个较好的解决方案

    > 处理异步数据流 rxjs

    > 前端框架历史
    1. 传统命令式编程的代表jquery 过去绘制一个页面 会用jquery提供的一套api 然后手动操作dom进行绘制 精准 完全手动操作 且改动时性能损耗较大 开发者注意力集中在如何绘制
    2. 响应式编程的react 开发者不关心界面如何绘制 只要告诉react 希望页面 剩下的交给react react会自动帮助绘制界面 ui = render(data) 只要操作data即可 页面ui会自动做出响应 且一切操作都是基于内存之中 不会有较大的性能损耗 这就是react响应式编程的精髓 也是为何它叫react

    > rxjs实现响应式
    > 两种强大的设计模式 观察者模式和迭代器模式

    1. 观察者模式
    - 观察者模式中 有两个重要角色 observable和observer 就是可观察对象和观察者 

    1. 可观察对象(observable)是事件发布者 负责产生事件
    2. 观察者(observer)是事件响应者 负责对发布的时间做出响应
    3. 通过订阅的形式，也就是subscribe方法连接一个发布者和响应者(类似 redux的store.subscribe) 在订阅之前 两者毫无关系 无论observer发出多少时间 observer也不会做出任何响应 订阅关系中断时也不会

    2. 迭代器模式
    > 拉取pull 推送push
    - 拉取和推送是两种不同的协议 用来描述生产者producer如何和消费者consumer进行通信
    > 拉取
    - 拉取体系中由消费者来决定何时从生产者中接收数据 生产者本身不知道数据何时交付到消费者手中
    - 每个js函数都是拉取体系，函数是数据的生产者，调用该函数的代码通过从函数调用中取出一个单个返回值对该函数进行消费
    - es2015引入了generator函数和iterators(function*) 这是另外一种类型的拉取体系 调用iterator.next的代码是消费者 它会从iterator中取出多个值
                生产者                  消费者
    拉取    被动的：当被请求时产生数据      主动的：决定何时请求数据
    推送    主动的：按自己的节奏产生数据    被动的：对收到的数据做出反应
    > 推送
    - 在推送体系中 由生产者决定何时把数据发送给消费者 消费者本身不知道何时会接收到数据
    - 在当今的js世界中 promises是最常见的推送体系类型 promise(生产者)将一个解析过的值传递给已注册的回调函数(消费者) 不同于回调函数的是 由promise来决定何时把值推送给回调函数 rxjs引入observables 一个新的推送体系 observable是多个值的生产者 并将值推送给观察者(消费者)

    > 拉取和推送实际上对于观察者来说就是一个主动和被动的区别 是主动去获取 还是被动接收 rxjs中 作为事件响应者(消费者)的observer对象也有一个next属性(回调函数)用来接受从发布者那推过来的数据

    > 开发者角度 消息是被动接收 因为倡导的就是通过操作data数据层 让view层进行一个响应 则这里data数据层一定是事件发布者 view层是事件响应者 每当data数据层发生变化时 都会主动推送一个值给view层 这符合真正意义上的响应式编程

    > rxjs只是响应式编程在js中的应用
    > 如何配合react 帮助react实现状态管理
    - 只需要将组件作为事件响应者 然后在next回调里定义好更新组件状态的动作setstate 当接收到数据推送时 就会自动触发setstate 完成界面更新 这其实类似mobx (很多人在react项目中没有完全只使用rxjs 而是用了redux-observable中间件 利用rxjs的操作符来处理异步action)

    > rxjs优点
    1. 纯函数：rxjs中数据流动的过程中 不会改变已经存在的observable实例 会返回一个新的observable 没有任何副作用
    2. 强大的操作符：rxjs又被称为lodash forasync 和lodash一样 拥有众多强大的操作符来操作数据流 不只是同步数据 针对各种复杂的异步数据流 可以多种事件流组合搭配 汇总到一起处理
    3. 更独立：rxjs不依赖任何一个框架 它可以任意搭配 因为它的关注点完全就是在数据流的处理上 并且它更偏低层

    > 缺点
    1. 学习曲线陡峭
    2. 事件流高度抽象

    > 总结各类适用场景
    1. 项目中复杂程度较低，建议只用react即可
    2. 项目中跨组件通信 数据流同步等情况较多时 建议搭配react的新context api
    3. 项目复杂度一般时 小规模团队或开发周期较短 mobx
    4. 项目复杂度较高，团队规模较大或要求对事件分发处理可监控可回溯时，建议使用redux
    5. 项目复杂度较高 且数据流(尤其是异步数据)混杂 建议使用rxjs
13. Flux和MVC
    - 在Web应用程序开发中 MVC是客户端和服务器端应用程序的设计模式
    - Flux是Facebook提出的一种新的应用程序体系结构 它与MVC相同 但侧重于单向数据流
    1. MVC
        - MVC设计中 最好将每一层分开 如视图 模型 控制器 
        - 模型: 管理应用程序域的行为和数据
        - 视图: 表示模型在UI中的显示
        - 控制器: 接受用户输入 操纵模型并导致视图更新
        > 优点
        1. 将表示形式与模型分开提高可测试性
        2. 将视图和控制器分离
        > 缺点
        1. 服务器端 MVC是好的 但是在客户端 大多数JS框架都提供了数据绑定支持 该视图直接与模型进行通信
        2. 问题 view1操作model1 model1更新view2 就像系统具有循环依赖关系一样
        1. 不可预测 
        2. 级联修改
        3. 响应顺序
        4. 有条件响应
    2. Flux
        - Facebook用于构建客户端Web应用程序的应用程序体系结构 它通过利用单向数据流来补充React的可组合视图组件 它更像是一种模式 而不是正式的框架
        - Flux是在MVC模式中进行了一些修改的方法
    - MVC设计模式
    - M 就是 model，即数据模型，负责数据相关的任务，包括对数据的增删改查。
    - V 就是 view，即视图层，即用户能看得到的界面。
    - C 就是 Controller,即控制器，负责监听用户事件，然后调用 M 和 V 更新数据和视图。
    - MVC 其实就是将代码变的结构化的一种抽象概念。

    一些建议：
    1. 所有业务代码放在controller中
    2. 所有的数据库操作的代码放在model中
    3. 所有用户可见的页面放在view中
    4. routes路由只是做简单的路由转发
    5. controller和model以及route都可以根据业务复杂度选择是否分拆多个，分拆的原则是数据库中有几张表，对应有几个controller和model
    6. controller中的方法命名规范要和业务相关，比如登录业务，就可以叫signin，注册业务，就可叫signup
    7. model中的方法命名规范就是CRUD，增删改查：查get*, 删除delete*, 改update*, 增save*
    8. mysql数据库操作完的结果results,一般会有以下几种情况
        1. 如果查询不到，results=[], 可以通过results.length是不是>0，来判断查没查到
        2. 如果查询多条，results=[{},{}...]，可以通过results.length是不是>0，来判断查没查到
        3. 如果查询到一条，results=[{}]，只有一个查询结果对象，仍然可以通过results.length是不是>0，来判断查没查到
        4. 如果是添加记录，results返回一个对象，其中有一个insertId属性，用来获取刚刚插入的这条记录的主键值，可以通过这个值是不是>0，来判断插入是否成功
        5. 如果是删除和修改记录，results返回一个对象，其中有一个affectedRows属性，可以通过这个值是不是>0，来判断删除或修改是否成功
13. Flux和Redux
    - React框架本身只应用于View 如果基于MVC模型开发 还需要Model和Controller层 这样催生了Flux的产生 而Redux是基于Flux理念的一种解决方式
    - Flux
        - Flux框架也是一种MVC框架 不同于传统的MVC 它采用单向数据流 不允许Model和Control互相引用
        - Flux框架大致
        1. Actions: 驱动Dispatcher发起改变
        2. Dispatcher: 负责分发动作(事件)
        3. Store: 存储数据 处理数据
        4. View: 视图部分
        - Dispacther只会暴露一个函数dispatch 接受action为参数 发起动作 如果需要增加新功能 不需要改变或增加接口 只需增加Action类型 - - Dispatch初始化和更新如下
        ```
        // Dispatcher.js
        import {Dispatcher } from 'flux'
        export default 

        //actions
        import AppDispatcher from './Dispatcher.js'
        
        export const increment = (number)=>{
           AppDispatcher.dispatch({
               type:'ADD',
               value:number
           }) 
        }
        ```
        - Store一般会继承EventEmitter 实现事件监听 发布 卸载 需要将store注册到Dispatcher实例上才能发挥作用
        - Store可以直接修改对象 这点和Redux不同
        - view组件中的state应该与Flux store保持一致
        > Flux缺点
        1. 一个应用可以拥有多个store 多个store之间可能有依赖关系(相互引用)
        2. Store封装了数据和处理数据的逻辑
        
        - 针对Flux的不足 Redux框架出现
    > Redux
    - 相比Flux Redux有以下两个特点
    1. 在整个应用中只提供一个store 它是一个扁平的树形结构 一个节点状态应该只属于一个组件
    2. 不允许修改数据 即不能修改老状态 只能返回新状态
    - 不同于Flux Redux没有dispatcher的概念(Store已经集成了dispatch方法 所有不需要Dispatcher) 它依赖纯函数Reducer来替代事件处理器 
    > 纯函数
    - 计算机编程中 加入满足下面两个句子的约束 一个函数可能被描述为一个纯函数
    1. 给出相同的参数值 该函数总是求出同样的结果 该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态在程序的两个不同的执行
- 组件Context
    - Flux Redux都需要显性地在View里引入store import store from './Store' 一个应用中 只引入一次store 然后所有组件都可以访问到 React提供Context
    - Context就是上下文环境 让一个树状组件上所有组件都能访问一个共有的对象
13. Redux和Vuex
    > 区别
    1. Vuex改进了Redux中的action和Reducer函数 以mutations变化函数取代Reducer 无需switch 只需在对应的mutation函数里改变state值即可
    2. Vuex由于Vue自动重新渲染的特性 无需订阅重新渲染函数 只要生成新的State即可
    - Vuex弱化了dispatch 通过commit进行store状态的一次更改 取消了action的概念 不必传入特定的action形式进行指定变更 弱化了reducer 基于commit参数直接对数据进行转变 使框架更加简易
    > 共同思想
    1. 单一的数据源
    2. 变化可以预测
    - 本质上 redux和vuex都是对mvvm思想的服务 将数据从视图中抽离的一种方案
13. 几种常见状态管理模式 Flux Redux Vuex Mobx
    > 状态管理
    - 把组件之间需要共享的状态抽取出来 遵循特定的约定 统一来管理 让状态的变化可以预测
    
    > 需要
    1. 状态共享
        - 需要将共享的状态提升至公共的父组件 若无公共的父组件 往往需要自行构造
        - 状态由父组件自上而下逐层传递 若组件层级过多 数据传递会变得很冗杂
    2. 变化追踪

    > Store模式
    - Store模式是一种相对简单的状态管理模式 一般有以下约定
        1. 状态存储在外部变量store里(也可以是全局变量)
        2. store中的state用于存储数据 由store实例维护
        3. store中的actions封装了改变state的逻辑
        - 如果对state的变更均通过actions 则实现记录变更 保存快照 历史回滚就会很简单 但store模式没有对此进行强制约束

    > Flux模式
    - Flux是一种架构思想 类似于MVC MVVM
    - Flux组成 Flux把一个应用分为四部分
        1. View 视图层
        2. Action 动作 即数据改变的消息对象(可通过事件触发 测试用例触发等)
            - Store的改变只能通过Action
            - 具体Action的处理逻辑一般放在Store里
            - Action对象包含type(类型)与payload(传递参数)
        3. Dispatcher 派发器 接收Actions 发送给所有的store
        4. Store 数据层 存放应用状态和更新状态的方法 一旦发生变动 就提醒Views更新页面
        - PS: Action本质是一个纯声明式的数据结构 仅提供对事件的描述 不提供事件的具体逻辑 通常会给Action的type属性赋值一个大写的字符串表明是常量 增强可维护性
    - Flux特点
        1. 单向数据流 视图时间或外部测试用例发出Action 经由Dispatcher派发给Store Store会触发相应的方法更新数据 更新视图
        2. Store可以有多个
        3. Store不仅存放数据 还封装了处理数据的方法

    > Redux模式
    - Redux特点
        1. 单向数据流
        2. 单一数据源 只有一个store
        3. state是只读的 每次状态更新后只能返回一个新的state
        4. 没有Dispatcher 而是在store中集成了dispatch方法 store.dispatch()是View发出Action唯一途径
        5. 支持使用中间件 管理异步数据流

    > Vuex
    - Vuex是Vue的状态管理模式
    - Vuex的核心概念
        1. Store Vuex采用单一状态树 每个应用仅有一个Store实例 该实例包含state actions mutations getters modules
        2. State Vuex为单一数据源
            - 可以通过mapState辅助函数将state作为计算属性访问 或将通过Store将State注入全局后使用this.$store.state访问
            - State更新视图是通过Vue的双向绑定机制实现的
        3. Getter
            - Getter作用和filters有一些相似 可以将State进行过滤后输出
        4. Mutation
            - Mutation是Vuex中改变State的唯一途径(严格模式下)并且只能是同步操作 Vuex中通过store.commit()调用mutation
        5. Action
            - 一些对State的异步操作可以放在Action中 并通过在Action提交Mutation变更状态
                1. Action通过store.dispatch()方法触发
                2. 可以通过mapActions辅助函数将Vue组件的methods映射成store.dispatch调用(需要先在根节点注入store)
        6. Module
            - 当store对象过于庞大 可根据具体业务需求分为多个Module 每个Module具有自己的state mutation action getter
    - Vuex特点
        1. 单向数据流 View通过store.dispatch()调用Action 在Action执行完异步操作之后通过store.commit()调用Mutation更新State 通过Vue的响应式机制进行视图更新
        2. 单一数据源 和Redux一样全局只有一个Store实例
        3. 只能应用于VUex

    > Mobx
    - Mobx背后的哲学是 任何源自应用状态的东西都应该自动地获得 当状态改变时 所有应用到状态的地方都会自动更新
    - Mobx核心概念
        1. State:驱动应用的数据
        2. Computed values:计算值 如果想创建一个基于当前状态的值 使用computed
        3. Reactions:反应 当状态改变时自动发生
        4. Actions:动作 用于改变State
        5. 依赖收集(autoRun):Mobx中的数据以来基于观察者模式 通过autoRun方法添加观察者
    - Mobx特点
        1. 数据流流动不自然 只有用到的数据才会引发绑定 局部精确更新(细粒度控制)
        2. 没有时间回溯能力 因为数据只有一份引用
        3. 基于面向对象
        4. 往往是多个Store
        5. 代码侵入性小
        6. 简单可扩展
        7. 大型项目使用Mobx会使得代码难以维护
    
    > 小结
    1. Flux Redux Vuex均为单向数据流
    2. Redux和Vuex是基于Flux的 Redux较为范用 Vuex只能用于Vue
    3. Flux和Mobx可以有多个Store Redux Vuex全局只有一个Store(单状态树)
    4. Redux Vuex适用于大型项目的状态管理 Mobx在大型项目中应用会使代码可维护性变差
    5. Redux中引入了中间件 主要用来解决异步带来的副作用 可通过约定完成许多复杂工作
    6. Mobx是状态管理库中代码侵入性最小之一 具有细粒度控制 简单可扩展等优势 但是没有时间回溯能力 一般适合应用于中小型项目中
14. 函数式编程的compose和pipe
    - 函数式编程中有一种模式是通过组合多个函数的功能来实现一个组合函数
    - 一般支持函数式编程的工具库都实现了这种模式
    - 这种模式一般被称为compose和pipe
    - 以函数式著称的Ramda工具库为例
    
    > compose函数
    - compose函数可以将需要嵌套执行的函数平铺 嵌套执行就是一个函数的返回值作为另一个函数的参数
    - 嵌套执行时 里面的方法 从右边的方法最开始执行 然后往左边返回
    - compose方法也是从右边的参数开始执行
    - compose方法的实现借助了Array.prototype.reduceRight(从右往左平铺)
    - Redux的中间件就是用compose实现的 webpack的loader的加载顺序也是从右往左 这是因为它也是compose实现的

    > pipe函数
    - pipe函数跟compose函数作用一样 也是将参数平铺 不过顺序是从左往右 
    - 借助Array.prototype.reduce实现
15. AST抽象语法树
    > 为什么要学习AST
    1. AST在开发过程中扮演着一个非常重要的角色 但是我们却很少直接接触他
    2. 无论是代码编译babel 打包wepack 代码压缩 css预处理 代码校验(eslint) 代码美化pretiier Vue对template的编译 这些的实现都离不开AST
    > AST
    - 对源代码的抽象语法结构的树状表现形式 在不同的场景下 会有不同的解析器将源码解析成抽象语法树
    > 生成
    1. 解析器 JS Parser 是把JS源码转化成抽象语法树(AST)的解析器 这个步骤分为两个阶段
        1. 词法分析 代码解析成tokens流
        2. 语法分析 token转换成AST
    > 应用
    1. babel
    - babel是一个编译器 把ES6语法编译成ES5
    > 三个阶段
    1. 解析 Parse
    - 通过解析器babylon将代码解析成抽象语法树
    2. 转换 TransForm
    - 通过babel-traverse plugin对抽象语法树进行深度优先遍历 遇到要转换的就直接在AST对象上 对节点进行添加 更新 以及移除操作 比如遇到箭头函数就转换成普通函数 最后得到新的AST树
    3. 生成 Generate
    - 通过babel-generator将AST树生成ES5代码

    2. Vue模版编译过程
    - Vue提供了两个版本 
    1. 一个是Runtime+Compiler 前置是包含编译代码的 会把编译的过程放在运行时做
    2. 另一个是Runtime only 后者是不包含编译代码的 需要借助webpack的vue-loader把模版编译成render函数
    - 使用哪个版本都有一个环节 就是将模版编译成render函数
    > Vue模版编译过程 分为三个阶段
    1. 解析 Parse
    - 将模版字符串解析生成AST 这里的解析器是Vue自己实现的 解析过程中会使用正则表达式对模板顺序解析，当解析到开始标签、闭合标签、文本的时候都会有相对应的回调函数执行，来达到构造 AST 树的目的。
    2. 优化语法树 Optimize
    - 此阶段会深度遍历生成的AST树 监测它每一颗子树是不是静态节点 如果是静态节点 它们生成的DOM永远不需要改变
    - 遍历过程中 会对整个AST树中的每一个AST元素节点标记static staticRoot(递归该节点的所有children 一旦子节点又不是static的情况 则为false 否则为true)
    3. 生成代码 
    - 通过generate方法 将AST生成render函数

    3. Prettier
    1. 将代码解析成AST树 对AST遍历 
    2. 调整长句 整理空格 括号等 最后输出代码
15. 消息摘要算法
    - 主要特征是加密过程中不需要密钥 并且经过加密的数据无法被解密 目前可以被解密逆向的只有CRC32算法 只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文
16. 
    > CSR 浏览器渲染
    1. 所有的页面渲染 逻辑处理 页面路由 接口请求均是在浏览器中发生
    2. 其实 现代主流的前端框架均是这种渲染方式 这种渲染方式的好处在于实现了前后端架构分离 利于前后端职责分离 减少首屏渲染事件
    3. CSR可以通过在打包编译阶段进行预渲染或骨架屏生成 可以进一步提升首次渲染的用户体验

    > NSR
    - UC浏览器在新闻feed流页面加载中采用了NSR(Native Side Renderfing)首先在列表页中加载离线页面模版 通过Ajax预加载页面数据 通过native渲染生成HTML数据并缓存在客户端
    - NSR本质是分布式SSR 将服务器的渲染工作放在一个个独立的移动设备中 实现了页面的预加载 同时不会增加额外的服务器压力

    > ESR Edge Side Rendering
    - 方案核心思想是 借助边缘计算的能力 将静态内容与动态内容以流式的方式 先后返回给用户 
    - CDN节点相比于Server 距离用户更近 有更短的网络延时 在CDN节点上 可将缓存的页面静态部分 先快速返回给用户 同时在CDN节点上发起动态部分内容请求 并将动态内容在静态部分的响应流后 继续返回给用户
17. Serverless
    > 前端开发模式的演进 四个阶段
    1. 基于模版渲染的动态页面
        - JSP PHP等技术写一些动态模版 然后通过Web Server将模版解析成一个个HTML文件 浏览器只负责渲染这些HTML文件 这个阶段还没有前后端的分工 通常是后端工程师 顺便写了前端页面
    2. 基于AJAX的前后端分离
        - 基于AJAX可以把Web分为前端和后端 
        - 前端负责界面和交互 后端负责业务逻辑的处理
        - 前后端通过接口进行数据交互
        - 网页复杂度由后端的Web Server转向了浏览器端的JS
    3. 基于Nodejs的前端工程化
        - 2009Nodejs出现
        - 由基于一个个页面进行开发 变为基于一个个组件进行开发
        - 开发完成后使用webpack等工具进行打包构建 通过基于Nodejs实现的命令行工具将构建结果发布线上 前端开发 规范化 标准化 工程化
    4. 基于Nodejs的全栈开发
        - 差不多在Nodejs诞生的那个时代
        - 后端普遍开始由巨石应用模式向微服务架构转变 
        - 这也导致以往的前后端分工出现分歧
        - 随着微服务架构的兴起 后端接口渐渐变得原子性 
        - 微服务接口也不再面向页面 前端调用变得复杂
        - BFF(Backend For Fronted)(前端的后端)架构应运而生 在微服务和前端中间 加了一个BFF层 由BFF对接口进行聚合裁剪 再输出给前端
        - BFF这层不是后端本质工具 且距离前端最近和前端关系最大 所以前端工程师自然而然选择Nodejs来实现 这也是当前Nodejs在服务端较为广泛的应用
    
    > 下一代前端开发模式
    - 每一次前端开发模式的变化 都因某个变革性的技术而起 AJAX Nodejs 下一个Serverless

    > Serverless服务中前端解决方案
    - Serverless是指构建和运行不需要服务器管理的应用程序概念

    - 技术角度 Serverles就是Faas(Function as a Service)和Baas(Backend as a Service)的结合
    > Faas 一些运行函数的平台 如阿里云的函数计算 AWS的Lambda等
    > Baas 一些后端云服务 如云数据库 对象存储 消息队列等 
    > Serverless可以理解为运行在Faas中 使用了Baas的函数

    > Serviceless主要特点
    1. 事件驱动
        - 函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。
    2. 无状态
        - 因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 Redis 等。
    3. 无运维
        - 使用 Serverless 我们不需要关心服务器，不需要关心运维。这也是 Serverless 思想的核心。
    4. 低成本
        - 使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源
18. AMD CMD
    > AMD
    - Asynchronous Module Definition 中文名异步模块定义 采用异步方式加载模块 模块的加载不影响它后面语句的运行 所有依赖这个模块的语句 都定义在一个回调函数中 等到加载完成 这个回调函数才会执行
    - 这里介绍用require.js实现AMD规范的模块化
        用require.config()指定引用路径
        用define()定义模块
        用require()加载模块

    - 由于Node.js主要用于服务器编程 模块文件一般都已经存在于本地硬盘 所以加载起来比较快 不用考虑非同步夹杂的方式 所以CommonJS规范比较适用
    如果是浏览器环境 要从服务端加载模块 此时需采用非同步模式 因此浏览器端一般采用AMD规范

    - AMD规范比CommonJS规范在浏览器端实现得早
    AMD规范语法
        定义暴露模块
        定义没有依赖的模块
        define(function(){
            return 模块
        })
        定义有依赖的模块
        define(['module1','module2',function(m1,m2){
            return 模块
        }])
        引入适用模块
        require(['modlue1','module2',function(m1,m2){
            使用m1/m2
        }])
    未使用AMD规范与使用require.js
    通过比较两者实现方法 说明使用AMD规范的好处

    - 未使用AMD规范 
    这种方式缺点很明显
        首先会发送多个请求 其次引入的js文件顺序不能搞错 否则会报错
        使用require.js
        RequireJS是一个工具库 主要用于客户端的模块管理 它的模块管理遵循AMD规范 RequireJS的基本思想是 通过define方法 将代码定义为模块 通过require方法 实现代码的模块加载
    ADM规范在浏览器实现的步骤
        1.下载require.js并引入
            官网: http://www.requirejs.cn/
            github : https://github.com/requirejs/requirejs
            然后将require.js导入项目: js/libs/require.js
        2.创建项目结构
        3.定义require.js的模块代码
        4.页面引入require.js模块
            在index.html引入 <script data-main="js/main" src="js/libs/require.js"></script>
    小结
        AMD模块定义的方法比较清晰 不会污染全局变量 能够清楚地显示依赖关系 AMD模式可用于浏览器环境 并允许非同步加载模块 也可以根据需要动态加载模块
    > CMD
    - (整合了CommonJS和AMD规范的特点 Sea.js中所有JS模块都遵循CMD模块定义规范)
    CMD规范专用于浏览器端 模块的加载是异步的
    模块使用时才会加载执行
    CMD规范整合了CommonJS和AMD规范的特点
    在Sea.js中 所以JS模块都遵循CMD模块定义规范
    SeaJS是一个遵循CMD规范的JS模块加载框架 可以实现JS模块化开发及加载机制
    主要目的是令JS开发模块化便于加载 将前端工程师从繁重的JS文件以及对象依赖处理中解放出来
    CMD规范基本语法
        定义暴露模块
        定义没有依赖的模块
        define(function(require,exports,module){
            exports.xxx = value;
            module.exports = value;
        })
        定义有依赖的模块
        define(function(require,exports,module){
            引入依赖模块(同步)
            var module2 = require('./module2');
            引入依赖模块(异步)
            require.async('./module3',function(m3){

            })
            暴露模块
            exports.xxx = value;
        })
        引入使用模块
        define(function (require) {
        var m1 = require('./module1')
        var m4 = require('./module4')
        m1.show()
        m4.show()
    require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码
    CMD是另一种JS模块化方案 它与AMD很类似
    不同点在于 
        AMD 推崇依赖前置 提前执行
        CMD 推崇依赖就近 延迟执行
    此规范其实是在sea.js推广过程中产生的 
    
    HTML(结构层)：定义结构
    CSS(表示层):定义样式
    JavaScript(行为层)：定义行为
19. 可枚举属性 不可枚举属性
    - 可枚举属性
    1. 是指那些内部 “可枚举”enumable 标志设置为 true 的属性。
        对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true。但是对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。
    2. 其中js中基本包装类型的原型属性是不可枚举的
        如Object, Array, Number等。
    3. 可枚举的属性可以通过for...in循环进行遍历（除非该属性名是一个Symbol），或者通过Object.keys()方法返回一个可枚举属性的数组。
20. MongoDB与MySql区别
    > MySQL 关系型数据库
    - Oracle公司开发 将数据存储在表中 并使用结构化查询语言SQL进行数据库访问
    - 相关信息存储在单独的表中 通过关联查询来关联 使数据重复量被最小化
    
    > MongoDB 非关系型数据库
    - MongoDB inc开发的开源数据库 MongoDB将数据存储在类似JSON的文档中
    - 且文档中每个JSON串结构可能有所不同 相关信息存储在一起 通过MongoDB查询语言进行快速查询访问 

    > 术语和概念
    > MySql     MongoDB
    - 表            集合
    - 行            文档
    - 列            字段
    - joins         潜入文档或链接

    > 特色对比
    1. 像MySQL一样 MongoDB提供丰富的远超出简单的键值存储中提供的功能 MongoDB具有查询语言 功能强大的辅助索引(包括文本搜索和地理空间) 数据分析能力强大的聚合框架 相比使用关系数据库 使用MongoDB

    > 为什么使用MongoDB而不是MySQL
    - 各种规模的组织企业都采用MongoDB 因为它能够更快的构建应用程序 处理高度多样化的数据类型 并更有效的管理应用程序
21. 如何选择图片格式
    图片格式    压缩方式      透明度   动画    浏览器兼容
    JPEG        有损        不支持  不支持      所有    
    GIF         无损        支持    支持        所有
    PNG         无损        支持    不支持      所有
    APNG        无损        支持    支持        Firefox SafariOS Safari
    WebP        有损        支持    支持        Chrome Opera Android Chrome
    SVG         无损        支持    支持        所有(IE8以上)
22. 小程序和H5有什么区别
    - (渲染方式/小程序特有的双线程设计)
    1. 渲染方式和H5不同 
        - 小程序一般是通过Native原生渲染的 但是小程序同时也支持web渲染 如果使用web渲染的方式 需要初始化一个WebView组件 然后在WebView中加载H5页面
        - 所以当我们开发一个小程序时，通常会使用 hybrid 的方式，即会根据具体情况选择部分功能用小程序原生的代码来开发，部分功能通过 WebView 加载 H5 页面来实现。Native 与 Web 渲染混合使用，以实现项目的最优解；这里值得注意的是，小程序下，native 方式通常情况下性能要优于 web 方式。
    2. 小程序特有的双线程设计
        - H5 下我们所有资源通常都会打到一个 bundle.js 文件里（不考虑分包加载），而小程序编译后的结果会有两个bundle，index.js封装的是小程序项目的 view 层，以及 index.worker.js 封装的是项目的业务逻辑，在运行时，会有两条线程来分别处理这两个bundle，一个是主渲染线程，它负责加载并渲染 index.js 里的内容，另外一个是 Service Worker线 程，它负责执行 index.worker.js 里封装的业务逻辑，这里面会有很多对底层api调用。
23. 
    1. Number在JS中如何存储 -- IEEE-754标准
    - JS的数字是IEEE-754标准存储的双精度浮点数类型
    - 双精度浮点数总共有64位bit 第一位用于表示符号 接着十一位用于表示阶码 剩余五十二位用于表示尾数
    > 符号位
    - 0表示正数 1表示负数 
    > IEEE-754标准中 一个浮点数将被使用二进制科学计数法的方式存储
    > 阶码(exponent)
    - 表示的是2的多少次方 范围是-1023-1024
    - 阶码是使用移码表示法存储的
    > 尾数
    2. Number.MAX_SAFE_INTERGE怎么来的
    - 尾数位数决定了最大的整数范围 在做数值运算时 我们会要求数值以及运算结果必须不能超出-Number.MAX_SAFA_INTEGER~Number.MAX_SAFE_INTEGER范围
    3. 为什么0.1+0.2!==0.3
    - 数字0.1 0.2在计算机中表示时 本身就存在精度丢失 尾数的尾数总共只有52位 放不下时会被丢弃 并按照舍0补1来弥补导致最终运算结果不同
    - 浮点数运算误差不是JS特有 所有遵循IEEE-754标准的实现都存在同样的问题

1. 服务器端如何设置cookie存活时间
2. proxy缺点
3. react整个渲染流程
4. JS引擎为什么会阻塞GUI线程


18. Yarn和NPM
    > Yarn
    - 由Facebook Googel Exponent和Tilde联合推出的一个新的JS包管理工具 Yarn是为了弥补npm的一些缺陷而出现的
    > npm缺陷
    1. 安装慢
    2. 同一个项目 安装时无法保持一致性 由于package.json文件中版本号的特点 
        1. "5.0.3" 安装指定的5.0.3版本
        2. "~5.0.3" 安装5.0.x中最新的版本
        3. "^5.0.3" 安装5.x.x中最新的版本
    3. 安装时 包会在同一时间下载和安装 中途某个时间 一个包抛出一个错误 但是npm会继续下载和安装包 因为npm会把所有的日志输出到终端 有关错误包的错误信息就会在一大堆npm打印的警告中丢失 甚至不会注意到实际发生的错误
    > Yarn优点
    1. 速度快
        1. 并行安装
        2. 离线安装 之前已经安装过一个软件包 用Yarn再次安装时会从缓存中获取 不用像npm再从网络中下载
    2. 安装版本统一
        1. 为了防止拉取到不同的版本 Yarn有一个锁定文件lock file 记录被确切安装上的模块的版本号 每次只要新增一个模块 yarn就会创建/更新 yarn.lock这个文件 每一次拉取同一个项目依赖时 使用的都是一样的模块版本
        - npm 可以通过开发者执行npm shrinkwrap命令生成一个锁定文件
        - yarn和npm的区别在于 yarn会默认生成这样的锁定文件 npm要通过shrinkwrap命令生成shrinkwrap.json文件 只有当这个文件存在时 packages版本信息才会被记录和更新
    3. 更简洁的输出
        - yarn默认情况下会结合emoji直观且直接打印出必要的信息 也提供一些供开发者查询额外的安装信息
    4. 多注册来源处理
    5. 更好的语义化
    > npm5.0
    - 在yarn之后 npm做了一些类似改进
    1. 默认新增类似yarn.lock的package-lock.json
    2. git依赖支持优化
    3. 文件依赖优化