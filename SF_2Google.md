1.岛屿数量问题
2.“扫地机器人”问题
3.“合并区间”问题

1.岛屿数量问题
岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
拿到这道题，首先要做的就是把题目中这些干扰性的概念“翻译”成简单直接的算法语言：
已知一个二维数组，定义“相互连接的1”为一个块（这里的相互连接，意思就是1和1之间可以不经过0就相互抵达），求符合条件的块的数量。

看到“所有”，必须想到“枚举”！看到“枚举”，必须回忆起DFS和BFS！
喜欢递归的我，选择用 DFS 来做~~~

在明确了 DFS 的大方向之后，结合题意，我们可以提取出以下关键问题：

如何实现对不同岛屿的统计？
已经计算过的岛屿如何排除？
下面我一一回答这两个问题：

岛屿的统计思路：从起点出发，遵循“不撞水面（也就是0）不回头”的原则，枚举当前可以触及的所有1。当枚举无法继续进行时，说明当前这座岛屿被遍历完毕，记为一个。也就是说每完成一次 DFS，就累加一个岛屿。
避免重复计算的方法：每遍历过一个1，就把它置为0，后续再次路过时就会自动忽略它啦~~
回答完这俩问题，代码也算基本写完了（如果以上描述仍然无法帮你建立清晰的思路，不妨去代码注释里找一下答案~）：

/**
 * @param {character[][]} grid
 * @return {number}
 */
// 入参是二维数组
const numIslands = function(grid) {
  const moveX = [0, 1, 0, -1]  
  const moveY = [1, 0, -1, 0]   
  // 处理二维数组的边界情况
  if(!grid || grid.length === 0 || grid[0].length === 0) {
      return 0
  }  
  // 初始化岛屿数量
  let count = 0  
  // 缓存二维数组的行数和列数
  let row = grid.length, column = grid[0].length  
  // 以行和列为线索，尝试“逐个”遍历二位数组中的坑位
  for(let i=0; i<row; i++) {
      for(let j=0; j<column; j++) {
          if(grid[i][j] === '1') {
              // 每遇到1，就进入dfs，探索岛屿边界
              dfs(grid, i, j)  
              // 每完成一个 dfs，就累加一个岛屿
              count++
          }
      }
      }
  return count

  // 编写探索岛屿边界的逻辑
  function dfs(grid, i, j) {  
      // 如果试图探索的范围已经越界，则return
      if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j] === '0'){
          return  
      }   
      // 遍历过的坑位都置0，防止反复遍历
      grid[i][j] = '0'   
      // 遍历完当前的1，继续去寻找下一个1
      for(let k=0; k<4; k++) {
          dfs(grid, i+moveX[k], j+moveY[k])
      }
  }
}
编码复盘
对初学此类问题的同学来说，这道题里有一个值得关注的做题技巧，就是对 moveX 和 moveY 两个数组的设定：

const moveX = [0, 1, 0, -1]  
const moveY = [1, 0, -1, 0]   
结合代码的上下文可以看出，我们借助这两个数组，可以完成对当前格子的“垂直”和“水平”两个方向上的相邻格子的检查：

for(let k=0; k<4; k++) {
  dfs(grid, i+moveX[k], j+moveY[k])
}
后续我们遇到的一些题目，一旦和这道题一样，强调了“水平”、“垂直”方向上的相邻关系，我们就可以无脑复用这个套路啦~
2.“扫地机器人”问题
3.“合并区间”问题
题目描述：给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

命题关键字：数学问题、数组

思路分析
做完两道应用题，大家放松一下，换换口味，现在我们来一起解决一个并没有许多套路的数学问题。
这个题里，你什么都可以忽略，但是请一定抓住“区间”二字，并记住下面这样一个规律：

对于区间类问题，尝试以区间内的第一个元素为索引进行排序，往往可以帮助我们找到问题的突破点

不信我们来看看这道题，题中给了我们这样一个例子：

[[1,3],[2,6],[8,10],[15,18]] 
这个例子就是一个排序过的区间，当区间排序后，区间与区间之间的重叠关系会变得非常有迹可循:

[1, 3]
  [2, 6]
            [8, 10]
                        [15, 18]
可以看出，对于有序区间，我们其实可以从头开始，逐个合并首尾有交集的区间——比如上面区间关系图中的 [1, 3] 和 [2, 6]，由于前一个区间的尾部（3）和下一个区间的头部（2）是有交错关系的（这个交错关系用数学语言表达出来就是前一个的尾部 >= 下一个的头部），因此我们可以毫不犹豫地把它们合并为一个区间：

[1, 3] + [2, 6] ==> [1, 6]
遵循这个合并规则，我们可以编码如下：

编码实现
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
const merge = function(intervals) {
    // 定义结果数组
    const res = []  
    // 缓存区间个数
    const len = intervals.length
    // 将所有区间按照第一个元素大小排序
    intervals.sort(function(a, b) {
        return a[0] - b[0]
    }) 
    // 处理区间的边界情况
    if(!intervals || !intervals.length) {
        return []
    }
    // 将第一个区间（起始元素最小的区间）推入结果数组（初始化）
    res.push(intervals[0])
    // 按照顺序，逐个遍历所有区间
    for(let i=1; i<len; i++) {
        // 取结果数组中的最后一个元素，作为当前对比的参考
        prev = res[res.length-1]  
        // 若满足交错关系（前一个的尾部 >= 下一个的头部）
        if(prev[1] >= intervals[i][0]) {
            prev[1] = Math.max(prev[1], intervals[i][1])
        } else {
            res.push(intervals[i])
        }
    }
    return res
}