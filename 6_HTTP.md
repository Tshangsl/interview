token鉴权的几种实现方式
1.HTTP状态码
200	|	操作成功	|
301     永久重定向
302     临时重定向
304     缓存
400	|	参数校验失败	|
401 |	未登录或token已过期	|
402	|	用户已禁用	|
403	|	禁止用户访问	|
404	|	用户名或密码错误	|
500	|	服务器端发生错误	|
503     服务器不能处理客户端请求，一段时间后可能恢复正常
2.什么是AJAX，如何实现
    ajax是一种能够实现局部网页刷新的技术，可以使网页异步刷新。
        ajax的实现主要包括四个步骤：
            （1）创建核心对象XMLhttpRequest；
            （2）利用open方法打开与服务器的连接；
            （3）利用send方法发送请求；（"POST"请求时，还需额外设置请求头）
            （4）监听服务器响应，接收返回值。
3.跨域相关
    1.为什么会出现跨域问题？
        出于浏览器的同源策略限制，浏览器会拒绝跨域请求。
        (严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：)
    2.什么情况才算作跨域？
        非同源请求，均为跨域。
    3.同源
        源(origin) = 协议(protocol)+端口(port)+主机/域名(host)
    4.最常用的三种跨域方法 JSONP CORS postMessage(H5新增)
        1.JSONP
            实现原理：
                虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入。
            实现方式(需前后端配合):
            优点:兼容性好（兼容低版本IE）,实现简单
            缺点：
                1.JSONP只支持GET请求；
                2.XMLHttpRequest相对于JSONP有着更好的错误处理机制       
                3.容易受到XSS攻击 
        2.CORS(异步请求 简单请求 非简单请求会先发送一次预检请求)
            CORS 是W3C 推荐的一种新的官方方案，能使服务器支持 XMLHttpRequest 的跨域请求。CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。
            值得注意的是，通常使用CORS时，异步请求会被分为简单请求和非简单请求，非简单请求的区别是会先发一次预检请求。
        3.Node中间件代理
        4.nginx反向代理
        5.postMessage
            window.postMessage(message,targetOrigin) 方法是html5新引进的特性
            可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
3.什么是跨域？怎么解决跨域问题？
    跨域问题实际上是由于同源策略衍生出的一个问题，当传输协议，域名端口任一部分不一致时，便会产生跨域问题，从而拒绝请求，但<img src=XXX> <link href=XXX><script src=XXX>天然允许跨域加载资源
    解决方案
    （1）JSONP
            原理：利用<script>;标签没有跨域限制的漏洞，使得网页     可以得到从其他来源动态产生的JSON数据（前提是服务器支持）。
            优点：实现简单，兼容性好。
            缺点：仅支持get方法，容易受到XSS攻击。
        （2）CORS
        原理：服务器端设置Access-Control-Allow-Origin以开启CORS。该属性表示哪些域名可以访问资源，如设置通配符则表示所有网站均可访问。
        实现实例（express)：
（3）Node中间件代理
            原理：同源策略仅是浏览器需要遵循的策略，故搭建中间件服务器转发请求与响应，达到跨域目的。
（4）nginx反向代理
            原理：类似Node中间件服务器，通过nginx代理服务器实现。
            实现方法：下载安装nginx，修改配置。
    5.postMessage(H5中新增)
4.Cookie、sessionStorage、localStorage区别
    共同点：都是保存在浏览器端，且同源的。 
    区别：
    （1）cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
    （2）cookie数据不能超过4k(适合保存小数据)。 
    sessionStorage和localStorage容量较大，
    （3）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清除；
    cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
    （4）作用域不同。 sessionStorage不在不同的浏览器窗口中共享；
    localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
    应用场景：
    localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。
    sessionStorage ：敏感账号一次性登录；
     cookies与服务器交互。
5.get和post区别
    简单来说：GET产生一个TCP数据包，POST产生两个TCP数据包
    　　严格的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    　　而对于POST请求。浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
    GET请求的参数是放在请求的URL中，而POST方法是放在请求体中
    GET请求在URL中传递参数时会有长度限制，而POST无限制（不是绝对的，只是相对来说）
    GET请求会被浏览器主动缓存，而POST不会
    GET请求的参数会保存在浏览器中，而POST的参数不会保存在浏览器中
6.http和https的区别，https有哪些新特性,SSL协议解决了什么，其依靠的算法有哪些
    HTTPS = HTTP + SSL/TLS(Secure Socket Layer安全套接层)
        TLS(Transport Layer Security 继任者传输层安全)
            TLS和SSL在传输层对网络连接进行加密
　　1、https有CA证书，http一般没有
　　2、http是超文本传输协议，信息是明文传输。https则是具有安全性的SSL加密传输协议
　　3、http默认80端口，https默认443端口。
    HTTPS新特性:
        1.TLS/SSL内容加密
        2.数字证书(CA)验明身份：防范中间人攻击
        3.MD5,SHA-1等散列值方法防止信息篡改
    HTTPS与HTTP比较
        HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。
    原有风险 现有优势
        1.信息窃听  信息加密
        2.信息篡改  完整性校验
        3.信息劫持  身份验证
    SSL协议提供的安全通道有以下三个特性：
        1.机密性：SSL协议使用密钥加密通信数据。
        2.可靠性：服务器和客户都会被认证，客户的认证是可选的。
        3.完整性：SSL协议会对传送的数据进行完整性检查。
    加密算法分为两大类：
        1.对称加密算法
            数据加解密使用同一份密钥，加解密速度快，效率高，缺点是密钥的管理难度大，一旦密钥传输泄露，那就没啥用处了。
        2.非对称加密算法
            数据加解密使用公钥和私钥，公钥用于传输，私钥自己保存，安全性较高，但加解密速度偏慢。
    公钥和私钥的概念
        1.私钥（放在服务器上，用于公钥加密过的数据），不会放在互联网上传输；
        2.公钥（放在互联网上，所有人都能拿到的一串加密的字符串，这个加密的字符串是来加密我们的字符信息的。当加密的数据传到服务器上，只有服务器通过私钥解密，才能把公钥加密的数据拿出来）
    握手阶段分为五步
7.https安全性
    1.服务器身份验证，通过服务器身份验证，用户可以明确当前它正在与对应的服务器进行通信
    2.数据机密性，其他方无法理解发送的数据内容，因为提交的数据是加密的
    3.数据完整性，传输会携带Message Authentication(MAC)用作验证，因此传输的数据不会被另一方更改
8.https的优点和缺点
    优点：
        1.最大限度地提高 Web 上数据和事务的安全性；
        2.加密用户敏感或者机密信息；
        3.提高搜索引擎中的排名
        4.避免在浏览器中出现“不安全”的提示；
        5.提升用户对网站的信赖。
    缺点：
        1.HTTPS 协议在握手阶段耗时相对较大，会影响页面整体加载速度；
        2.在浏览器和服务器上会更多的 CPU 周期来加密/解密数据；
        3.SSL 证书一般都需要支付一定费用来获取，并且费用往往不低；
        4.并不是绝对意义上的安全，在网站遭受攻击，服务器被劫持时，HTTPS 基本起不到任何安全防护作用。
9.TLS(Transport Layer Secure 继承者传输层安全)/SSL(Secure Socket Layer 安全套接层)协议
        TLS/SSL协议为了解决网络通讯中的信息安全问题而产生的
        设计目的：
            身份验证
            保密性
            完整性
        主要包含两部分
            1.Record记录协议
                使用对称加密短发来解决通讯消息加密的部分
            2.Handshake握手协议
                为了完成对称加密，需要通过握手协议来传递密匙  
7.计算机网络体系结构
    OSI(Open System Interconnection 开放式系统互连)七层协议
        应用层：允许访问OSI环境的手段
    　　表示层：对数据进行翻译、加密和压缩
    　　会话层：建立、管理和终止会话
    　　传输层：提供端到端的可靠报文传递和错误恢复
    　　网络层：负责数据包从源到宿的传递和网际互连
        数据链路层
    　　物理层：通过媒介传输比特,确定机械及电气规范
    TCP/IP四层协议(现在广泛使用的)
        应用层(各种应用层协议和TELNET FTP SMTP)
        运输层(TCP/UDP)
        网际层(IP)
        网络接口层
    五层协议(并不存在 讲课用)
        应用层
        传输层
        网络层
        数据链路层
        物理层
8.TCP和UDP的区别
    TCP（Transmission Control Protocol，传输控制协议）
        是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

    UDP（User Data Protocol，用户数据报协议）
        是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境

9.SSL有几次握手，具体过程|HTTPS握手过程
    1.客户端先生成一个随机数，然后传输到服务端，并且会带上客户端这边支持的所有加密套件
    2.服务端拿到这个随机数之后先存的，服务端也生成一个随机数，这个随机数会伴随着服务端的证书，也就是我们之前说到的公钥，一起传输给客户端
    3.客户端拿到了服务端的随机数之后也先存着，通过服务端传给他的公钥生成一个预主秘钥，生成过程当中会产生一个新的随机数，所以总共是有三个随机数，客户端生成的这个随机数用公钥加密后传输给服务器这边，这个过程就是没有办法被中间人解析的一个过程，因为它使用的是公钥进行加密，只有服务端这边的私钥可以对其解密
    4.这个数据传输到服务器之后，服务器通过私钥解密，拿到了预主秘钥也就是我们说的那个随机字符串
    5.最终服务端会选择一个客户端这边支持的加密套件，然后两边确定同时使用这同一个加密套件，对这三个随机数进行一个算法的操作，生成一个主秘钥，因为最后一个随机数只有客户端和服务端知道，中间人根本拿不到，所以他们生成的这个主秘钥也是中间人根本没有办法破解的，后期传输的数据就全部是通过这个主秘钥进行加密的，因为两边主秘钥是一样的，所以两边都能够对数据加密之后进行解密，中间人因为没有办法知道这个主秘钥，所以他没有办法对数据进行解密，所以这中间的数据传输就变成了安全的传输

    总体来说TLS握手就是通过交换三个随机数，然后计算出主会话密钥；由于安全性，会继续扩展出更多的临时密钥。保证通讯过程的绝对安全。
10.ajax请求时，如何解释json数据
    如果是字符串形式的json：eval("("+ajax.response+")")
    如果是本地的json文件：JSON.parse(data)
11.localStorage sessionStorage Cookie Session
    localStorage和sessionStorage：
        两者的共同点在于：
            1、存储大小均为5M左右
            2、都有同源策略限制
            3、仅在客户端中保存，不参与和服务器的通信
        两者的不同点在于：
            1、生命周期 —— 数据可以存储多少时间
                1. localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。
                2.sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。
            2、作用域 —— 谁拥有数据的访问权
                1.localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。
                2.sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。
12.Cookie Session 和Token
    Cookie Session Token 存在的意义
        HTTP是一种无状态协议 无法确保每一次会话是否为同一个用户发出 浏览器不会保留任何会话信息 所以服务器端也就无法确定访问者信息，因此浏览器和服务端会进行一个会话跟踪，在进行一些特殊用户权限才有的操作时，将用户状态用Cookie或Session保存起来
    Cookie：
        一种主要用于客户端和服务端进行会话验证的凭证
        属性表：
            1.name=value String 键值对,字符串类型，用于设置Cookie 的名称和值        
            2.expires 符合 HTTP-date 规范的时间戳 指定Cookie 的生存期，用于设置Cookie的过期时间
            3.max-age non-zero-digit 在 cookie 失效之前需要经过的秒数,与expires功能相似
            4.domain 域名String 指定Cookie 所属的域名，默认为当前域名
            5.path URL 路径 指定 cookie 在哪个路径（路由）下生效，默认是 '/'
        创建方式:
            1.客户端通过js设置，举例，用一个js-cookies库 已封装好document.cookie方法
            2.服务器端通过在HTTP响应头设置Set-Cookie
                服务器端设置后，客户端再次同一服务端发起请求时，就会携带这个Cookie并发到服务端上
                在域名相同(端口号不同的跨域)的情况下，Cookie是可以共享的，而其他跨域情况则无法共享
    Session：
        1.基于Cookie实现的另一种记录服务器端和客户端会话状态的机制
        2.Session存储在服务端，而SessionId会被存储在客户端的Cookie中
        认证过程：
            1.客户端第一次发送请求到服务端，服务端根据信息创建对应的Session，并在响应头返回SessionID(也就是Set-Cookie)
            2.客户端接收到服务器端返回的SessionID后，会将此信息存储在Cookie上，同时会记录这个SessionID属于哪个域名
            3.当客户端再次访问服务器端时，请求会自动判断该域名下是否存在Cookie信息，如果有则发给服务器端，服务器端会从Cookie中拿到SessionID，再根据SessionID找到对应的Session，如果有对应的Session则通过，继续执行请求，否则就中断
        缺点及解决方案：
            扩展性不好，Session面对服务器集群是无法共享Session的。
            Session是存储在Tomcat容器中的，所以如果后端机器是多台的话，多个机器间是无法共享Session的，此时可以使用Spring提供的分布式Session的解决方案，将Session放在Redis中
    Cookie和Session区别：
        1.安全性:因为Cookie可以通过刻划断修改，而Session只能在服务器端设置，所以安全性比Cookie高，一般会用于验证用户登陆状态
        2.适用性：Cookie只能存储字符串数据，而Session可以存储任意类型数据
        3.有效性 Cookie可以设置任意时间有效，而Session一般失效事件端
        4.继承性 一般客户端设置Cookie，如果要用于验证就需要服务器端创建Session
    Token：
        访问资源接口(API-Application Programming Interface)时所需要的资源凭证，与Session相比，token的优点时不需要存储数据在服务端，服务端只需要根据客户端传来的token进行合法验证，通过后则返回请求资源即可，减轻了服务器端的资源占用压力，目前最流行的JWT(JSON WEB TOKEN)就是基于token实现，以下以JWT标准介绍token
    JWT认证流程：
        1.客户端发送用户信息给服务端请求登录
        2.服务端验证用户信息，验证通过后签发一个 Token 返回给客户端，客户端收到后会存储在 Cookie 或 localStorage 中
        3.客户端继续第二次业务请求，请求头的 Authorization 字段携带这个 Token或者直接放在 Cookie(但是这样就不能跨域了)
        4.服务端根据 headers 中的 Token 进行验证，验证通过后返回业务请求的数据
    JWT优点：
        1.可用于应用管理，避开同源策略
        2.避免 CSRF(Cross Site Request Forgery) 跨站请求伪造 攻击
        3.实现无状态服务端，能够在多个服务间使用，可扩展性好











