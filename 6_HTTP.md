token鉴权的几种实现方式
缓存策略
1.HTTP状态码
101     切换请求协议 从HTTP切换到WebSocket
200	|	操作成功	|
301     永久重定向 会缓存
302     临时重定向  不会缓存
303
304     协商缓存命中
400	|	参数校验失败	|
401 |	未登录或token已过期	|
402	|	用户已禁用	|
403	|	禁止用户访问	|
404	|	资源未找到	|
500	|	服务器端发生错误	|
503     服务器不能处理客户端请求，一段时间后可能恢复正常
1xx：表示目前是协议的中间状态 还需要后续请求
2xx：表示请求成功
3xx：表示重定向 需要重新请求
4xx：表示请求报文错误
5xx：服务器端错误
2.什么是AJAX，如何实现
    ajax是一种能够实现局部网页刷新的技术，可以使网页异步刷新。
        ajax的实现主要包括四个步骤：
            （1）创建核心对象XMLhttpRequest；
            （2）利用open方法打开与服务器的连接；
            （3）利用send方法发送请求；（"POST"请求时，还需额外设置请求头）
            （4）监听服务器响应，接收返回值。
3.什么是HTTP
4.线程和进程有什么区别
3.跨域相关
    1.为什么会出现跨域问题？
        出于浏览器的同源策略限制，浏览器会拒绝跨域请求。
        (严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：)
    2.什么情况才算作跨域？
        非同源请求，均为跨域。
    3.同源
        源(origin) = 协议(protocol)+端口(port)+主机/域名(host)
    4.最常用的三种跨域方法 JSONP CORS postMessage(H5新增)
        1.JSONP
            实现原理：
                虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入。
            实现方式(需前后端配合):
            优点:兼容性好（兼容低版本IE）,实现简单
            缺点：
                1.JSONP只支持GET请求；
                2.XMLHttpRequest相对于JSONP有着更好的错误处理机制       
                3.容易受到XSS攻击 
        2.CORS(异步请求 简单请求 非简单请求会先发送一次预检请求)
            CORS 是W3C 推荐的一种新的官方方案，能使服务器支持 XMLHttpRequest 的跨域请求。CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。
            值得注意的是，通常使用CORS时，异步请求会被分为简单请求和非简单请求，非简单请求的区别是会先发一次预检请求。
        3.Node中间件代理
        4.nginx反向代理
        5.postMessage
            window.postMessage(message,targetOrigin) 方法是html5新引进的特性
            可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
3.什么是跨域？怎么解决跨域问题？
    跨域问题实际上是由于同源策略衍生出的一个问题，当传输协议，域名端口任一部分不一致时，便会产生跨域问题，从而拒绝请求，但<img src=XXX> <link href=XXX><script src=XXX>天然允许跨域加载资源
    解决方案
    （1）JSONP
            原理：利用<script>;标签没有跨域限制的漏洞，使得网页     可以得到从其他来源动态产生的JSON数据（前提是服务器支持）。
            优点：实现简单，兼容性好。
            缺点：仅支持get方法，容易受到XSS攻击。
        （2）CORS
        原理：服务器端设置Access-Control-Allow-Origin以开启CORS。该属性表示哪些域名可以访问资源，如设置通配符则表示所有网站均可访问。
        实现实例（express)：
（3）Node中间件代理
            原理：同源策略仅是浏览器需要遵循的策略，故搭建中间件服务器转发请求与响应，达到跨域目的。
（4）nginx反向代理
            原理：类似Node中间件服务器，通过nginx代理服务器实现。
            实现方法：下载安装nginx，修改配置。
    5.postMessage(H5中新增)
4.Cookie、sessionStorage、localStorage区别
    共同点：都是保存在浏览器端，且同源的。 
    区别：
    （1）cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
    （2）cookie数据不能超过4k(适合保存小数据)。 
    sessionStorage和localStorage容量较大，
    （3）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清除；
    cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
    （4）作用域不同。 sessionStorage不在不同的浏览器窗口中共享；
    localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
    应用场景：
    localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。
    sessionStorage ：敏感账号一次性登录；
     cookies与服务器交互。
5.get和post区别
    简单来说：GET产生一个TCP数据包，POST产生两个TCP数据包
    　　严格的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    　　而对于POST请求。浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
    GET请求的参数是放在请求的URL中，而POST方法是放在请求体中
    GET请求在URL中传递参数时会有长度限制，而POST无限制（不是绝对的，只是相对来说）
    GET请求会被浏览器主动缓存，而POST不会
    GET请求的参数会保存在浏览器中，而POST的参数不会保存在浏览器中
6.http和https的区别，https有哪些新特性,SSL协议解决了什么，其依靠的算法有哪些
    HTTPS = HTTP + SSL/TLS(Secure Socket Layer安全套接层)
        TLS(Transport Layer Security 继任者传输层安全)
            TLS和SSL在传输层对网络连接进行加密
　　1、https有CA证书，http一般没有
　　2、http是超文本传输协议，信息是明文传输。https则是具有安全性的SSL加密传输协议
　　3、http默认80端口，https默认443端口。
    HTTPS新特性:
        1.TLS/SSL内容加密
        2.数字证书(CA)验明身份：防范中间人攻击
        3.MD5,SHA-1等散列值方法防止信息篡改
    HTTPS与HTTP比较
        HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。
    原有风险 现有优势
        1.信息窃听  信息加密
        2.信息篡改  完整性校验
        3.信息劫持  身份验证
    SSL协议提供的安全通道有以下三个特性：
        1.机密性：SSL协议使用密钥加密通信数据。
        2.可靠性：服务器和客户都会被认证，客户的认证是可选的。
        3.完整性：SSL协议会对传送的数据进行完整性检查。
    加密算法分为两大类：
        1.对称加密算法
            数据加解密使用同一份密钥，加解密速度快，效率高，缺点是密钥的管理难度大，一旦密钥传输泄露，那就没啥用处了。
        2.非对称加密算法
            数据加解密使用公钥和私钥，公钥用于传输，私钥自己保存，安全性较高，但加解密速度偏慢。
    公钥和私钥的概念
        1.私钥（放在服务器上，用于公钥加密过的数据），不会放在互联网上传输；
        2.公钥（放在互联网上，所有人都能拿到的一串加密的字符串，这个加密的字符串是来加密我们的字符信息的。当加密的数据传到服务器上，只有服务器通过私钥解密，才能把公钥加密的数据拿出来）
    握手阶段分为五步
7.https安全性
    1.服务器身份验证，通过服务器身份验证，用户可以明确当前它正在与对应的服务器进行通信
    2.数据机密性，其他方无法理解发送的数据内容，因为提交的数据是加密的
    3.数据完整性，传输会携带Message Authentication(MAC)用作验证，因此传输的数据不会被另一方更改
8.https的优点和缺点
    优点：
        1.最大限度地提高 Web 上数据和事务的安全性；
        2.加密用户敏感或者机密信息；
        3.提高搜索引擎中的排名
        4.避免在浏览器中出现“不安全”的提示；
        5.提升用户对网站的信赖。
    缺点：
        1.HTTPS 协议在握手阶段耗时相对较大，会影响页面整体加载速度；
        2.在浏览器和服务器上会更多的 CPU 周期来加密/解密数据；
        3.SSL 证书一般都需要支付一定费用来获取，并且费用往往不低；
        4.并不是绝对意义上的安全，在网站遭受攻击，服务器被劫持时，HTTPS 基本起不到任何安全防护作用。
9.TLS(Transport Layer Secure 继承者传输层安全)/SSL(Secure Socket Layer 安全套接层)协议
        TLS/SSL协议为了解决网络通讯中的信息安全问题而产生的
        设计目的：
            身份验证
            保密性
            完整性
        主要包含两部分
            1.Record记录协议
                使用对称加密短发来解决通讯消息加密的部分
            2.Handshake握手协议
                为了完成对称加密，需要通过握手协议来传递密匙  
7.计算机网络体系结构
    OSI(Open System Interconnection 开放式系统互连)七层协议
        应用层：允许访问OSI环境的手段
    　　表示层：对数据进行翻译、加密和压缩
    　　会话层：建立、管理和终止会话
    　　传输层：提供端到端的可靠报文传递和错误恢复
    　　网络层：负责数据包从源到宿的传递和网际互连
        数据链路层
    　　物理层：通过媒介传输比特,确定机械及电气规范
    TCP/IP四层协议(现在广泛使用的)
        应用层(各种应用层协议和TELNET FTP SMTP)
        运输层(TCP/UDP)
        网际层(IP)
        网络接口层
    五层协议(并不存在 讲课用)
        应用层
        传输层
        网络层
        数据链路层
        物理层
8.TCP和UDP的区别
    TCP（Transmission Control Protocol，传输控制协议）
        是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

    UDP（User Data Protocol，用户数据报协议）
        是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境

9.SSL有几次握手，具体过程|HTTPS握手过程
    1.客户端先生成一个随机数，然后传输到服务端，并且会带上客户端这边支持的所有加密套件
    2.服务端拿到这个随机数之后先存的，服务端也生成一个随机数，这个随机数会伴随着服务端的证书，也就是我们之前说到的公钥，一起传输给客户端
    3.客户端拿到了服务端的随机数之后也先存着，通过服务端传给他的公钥生成一个预主秘钥，生成过程当中会产生一个新的随机数，所以总共是有三个随机数，客户端生成的这个随机数用公钥加密后传输给服务器这边，这个过程就是没有办法被中间人解析的一个过程，因为它使用的是公钥进行加密，只有服务端这边的私钥可以对其解密
    4.这个数据传输到服务器之后，服务器通过私钥解密，拿到了预主秘钥也就是我们说的那个随机字符串
    5.最终服务端会选择一个客户端这边支持的加密套件，然后两边确定同时使用这同一个加密套件，对这三个随机数进行一个算法的操作，生成一个主秘钥，因为最后一个随机数只有客户端和服务端知道，中间人根本拿不到，所以他们生成的这个主秘钥也是中间人根本没有办法破解的，后期传输的数据就全部是通过这个主秘钥进行加密的，因为两边主秘钥是一样的，所以两边都能够对数据加密之后进行解密，中间人因为没有办法知道这个主秘钥，所以他没有办法对数据进行解密，所以这中间的数据传输就变成了安全的传输

    总体来说TLS握手就是通过交换三个随机数，然后计算出主会话密钥；由于安全性，会继续扩展出更多的临时密钥。保证通讯过程的绝对安全。
10.ajax请求时，如何解释json数据
    如果是字符串形式的json：eval("("+ajax.response+")")
    如果是本地的json文件：JSON.parse(data)
11.localStorage sessionStorage Cookie Session
    localStorage和sessionStorage：
        两者的共同点在于：
            1、存储大小均为5M左右
            2、都有同源策略限制
            3、仅在客户端中保存，不参与和服务器的通信
        两者的不同点在于：
            1、生命周期 —— 数据可以存储多少时间
                1. localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。
                2.sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。
            2、作用域 —— 谁拥有数据的访问权
                1.localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。
                2.sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。
12.Cookie Session 和Token
    Cookie Session Token 存在的意义
        HTTP是一种无状态协议 无法确保每一次会话是否为同一个用户发出 浏览器不会保留任何会话信息 所以服务器端也就无法确定访问者信息，因此浏览器和服务端会进行一个会话跟踪，在进行一些特殊用户权限才有的操作时，将用户状态用Cookie或Session保存起来
    Cookie：
        一种主要用于客户端和服务端进行会话验证的凭证
        属性表：
            1.name=value String 键值对,字符串类型，用于设置Cookie 的名称和值        
            2.expires 符合 HTTP-date 规范的时间戳 指定Cookie 的生存期，用于设置Cookie的过期时间
            3.max-age non-zero-digit 在 cookie 失效之前需要经过的秒数,与expires功能相似
            4.domain 域名String 指定Cookie 所属的域名，默认为当前域名
            5.path URL 路径 指定 cookie 在哪个路径（路由）下生效，默认是 '/'
        创建方式:
            1.客户端通过js设置，举例，用一个js-cookies库 已封装好document.cookie方法
            2.服务器端通过在HTTP响应头设置Set-Cookie
                服务器端设置后，客户端再次同一服务端发起请求时，就会携带这个Cookie并发到服务端上
                在域名相同(端口号不同的跨域)的情况下，Cookie是可以共享的，而其他跨域情况则无法共享
    Session：
        1.基于Cookie实现的另一种记录服务器端和客户端会话状态的机制
        2.Session存储在服务端，而SessionId会被存储在客户端的Cookie中
        认证过程：
            1.客户端第一次发送请求到服务端，服务端根据信息创建对应的Session，并在响应头返回SessionID(也就是Set-Cookie)
            2.客户端接收到服务器端返回的SessionID后，会将此信息存储在Cookie上，同时会记录这个SessionID属于哪个域名
            3.当客户端再次访问服务器端时，请求会自动判断该域名下是否存在Cookie信息，如果有则发给服务器端，服务器端会从Cookie中拿到SessionID，再根据SessionID找到对应的Session，如果有对应的Session则通过，继续执行请求，否则就中断
        缺点及解决方案：
            扩展性不好，Session面对服务器集群是无法共享Session的。
            Session是存储在Tomcat容器中的，所以如果后端机器是多台的话，多个机器间是无法共享Session的，此时可以使用Spring提供的分布式Session的解决方案，将Session放在Redis中
    Cookie和Session区别：
        1.安全性:因为Cookie可以通过刻划断修改，而Session只能在服务器端设置，所以安全性比Cookie高，一般会用于验证用户登陆状态
        2.适用性：Cookie只能存储字符串数据，而Session可以存储任意类型数据
        3.有效性 Cookie可以设置任意时间有效，而Session一般失效事件端
        4.继承性 一般客户端设置Cookie，如果要用于验证就需要服务器端创建Session
    Token：
        访问资源接口(API-Application Programming Interface)时所需要的资源凭证，与Session相比，token的优点时不需要存储数据在服务端，服务端只需要根据客户端传来的token进行合法验证，通过后则返回请求资源即可，减轻了服务器端的资源占用压力，目前最流行的JWT(JSON WEB TOKEN)就是基于token实现，以下以JWT标准介绍token
    JWT认证流程：
        1.客户端发送用户信息给服务端请求登录
        2.服务端验证用户信息，验证通过后签发一个 Token 返回给客户端，客户端收到后会存储在 Cookie 或 localStorage 中
        3.客户端继续第二次业务请求，请求头的 Authorization 字段携带这个 Token或者直接放在 Cookie(但是这样就不能跨域了)
        4.服务端根据 headers 中的 Token 进行验证，验证通过后返回业务请求的数据
    JWT优点：
        1.可用于应用管理，避开同源策略
        2.避免 CSRF(Cross Site Request Forgery) 跨站请求伪造 攻击
        3.实现无状态服务端，能够在多个服务间使用，可扩展性好
13.HTTP缓存
    1.强缓存
    2.协商缓存

    首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存
    如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：

        若资源更新，那么返回资源和 200 状态码
        如果资源未更新，那么告诉浏览器直接使用缓存获取资源
14.你知道 302(临时) 状态码是什么嘛？你平时浏览网页的过程中遇到过哪些 302 的场景？301(永久)
    而 302 表示临时重定向，这个资源只是暂时不能被访问了，但是之后过一段时间还是可以继续访问，一般是访问某个网站的资源需要权限时，会需要用户去登录，跳转到登录页面之后登录之后，还可以继续访问。
    301 类似，都会跳转到一个新的网站，但是 301 代表访问的地址的资源被永久移除了，以后都不应该访问这个地址，搜索引擎抓取的时候也会用新的地址替换这个老的。可以在返回的响应的 location 首部去获取到返回的地址。301 的场景如下：
    比如从 baidu.com，跳转到 baidu.com
    域名换了
15.HTTP 常用的请求方式，区别和用途
    GET：通用获取数据
    HEAD：获取资源的元信息
    POST：提交数据
    PUT：修改数据
    DELETE：删除数据
    CONNECT：建立连接隧道，用于代理服务器
    OPTIONS：列出可对资源实行的请求方法，常用于跨域    
16.三次握手和四次挥手，为什么不是2/4次
    三次握手
        1.一开始双方处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态
        2.然后客户端主动发起连接，发送 SYN，然后自己变为 SYN-SENT，seq = x
        3.服务端收到之后，返回 SYN seq = y 和 ACK ack = x + 1（对于客户端发来的 SYN），自己变成 SYN-REVD
        4.之后客户端再次发送 ACK seq = x + 1, ack = y + 1给服务端，自己变成 EASTABLISHED 状态，服务端收到 ACK，也进入 ESTABLISHED
    为什么不是两次
        无法确认客户端的接收能力。
    为什么不是4次
        四次以上都可以，只不过 三次就够了
    四次挥手
        一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1
        服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态    
        客户端收到之后进入 FIN-WAIT-2  状态
        过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段
        客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1
        服务端收到之后进入 CLOSED 状态
    客户端这个时候还需要等待两次 MSL 之后，如果没有收到服务端的重发请求，就表明 ACK 成功到达，挥手结束，客户端变为 CLOSED 状态，否则进行 ACK 重发
    。。。。
    17.在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？
        在 HTTP 中响应体的 Connection 字段指定为 keep-alive
    18.你对 TCP 滑动窗口有了解嘛？
        在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。
        TCP 滑动窗口分为两种: 发送窗口和接收窗口。
    19.WebSocket与Ajax的区别
        本质不同
            Ajax（Asynchronous Javascript And XML） 即异步 JavaScript 和 XML。是一种创建交互式网页的应用的网页开发技术
            websocket 是 HTML5 的一种新协议，实现了浏览器和服务器的实时通信
        生命周期不同：
            websocket 是长连接，会话一直保持
            ajax 发送接收之后就会断开
        适用范围：
            websocket 用于前后端实时交互数据    
            ajax 非实时
        发起人：
            AJAX 客户端发起 
            WebSocket 服务器端和客户端相互推送
    20.WebSocket
        长轮询和短轮询，WebSocket 是长轮询。
            具体比如在一个电商场景，商品的库存可能会变化，所以需要及时反映给用户，所以客户端会不停的发请求，然后服务器端会不停的去查变化，不管变不变，都返回，这个是短轮询。
            而长轮询则表现为如果没有变，就不返回，而是等待变或者超时（一般是十几秒）才返回，如果没有返回，客户端也不需要一直发请求，所以减少了双方的压力。
    21.HTTP 如何实现长连接？在什么时候会超时？
        通过在头部（请求和响应头）设置 Connection: keep-alive，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长连接
            。。。
        实际上 HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等
    22.Fetch API与传统Request的区别
        1.fetch 符合关注点分离，使用 Promise，API 更加丰富，支持 Async/Await 
        2.语意简单，更加语意化
        3.可以使用 isomorphic-fetch ，同构方便
    23.POST一般可以发送什么类型的文件，数据处理的问题
        1.文本、图片、视频、音频等都可以
        2.text/image/audio/ 或 application/json 等
    24.TCP 如何保证有效传输及拥塞控制原理。
        tcp 是面向连接的、可靠的、传输层通信协议
        可靠体现在：
            有状态：
                有状态是指 TCP 会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错
            可控制：
                可控制的是指，如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发
        拥塞控制原理:
            原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。
            主要用三种方法：
                1.慢启动阈值 + 拥塞避免
                    对于拥塞控制来说，TCP 主要维护两个核心状态：
                        拥塞窗口（cwnd）
                        慢启动阈值（ssthresh）
                        （在发送端使用拥塞窗口来控制发送窗口的大小。）
                2.快速重传
                    。。。。
                3.快速回复
                    。。。
    25.OPTION是干啥的？举个用到OPTION的例子？
        1.旨在发送一种探测请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。
        2.比如针对跨域资源的预检，就是采用 HTTP 的 OPTIONS 方法先发送的。用来处理跨域请求
    26.http知道嘛？哪一层的协议？（应用层）
        1.灵活可扩展，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源
        2.可靠传输，基于 TCP/IP 所以继承了这一特性
        3.请求-应答，有来有回
        4.无状态，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息
        缺点：
            1.明文传输不安全
            2.复用一个 TCP 链接，会发生对头拥塞
            3.无状态在长连接场景中，需要保存大量上下文，以避免传输大量重复的信息
    27.TCP 协议怎么保证可靠的，UDP 为什么不可靠？
        TCP 是面向连接的、可靠的、传输层通信协议
        UDP 是无连接的传输层通信协议，继承 IP 特性,基于数据报
        为什么 TCP 可靠？TCP 的可靠性体现在有状态和控制
            会精准记录那些数据发送了，那些数据被对方接收了，那些没有被接收，而且保证数据包按序到达，不允许半点差错，这就是有状态
            当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发，这是可控制的
        反之 UDP 就是无状态的和不可控制的
    28.HTTP 2 改进
        改进性能：
            头部压缩
            多路信道复用
            Server Push
    29.计算机网络当中客户端发送请求到客户端可以怎么发送
    30.keep-alive标签的原理 有什么功能
    31.同源的标签里传递数据 用什么方法

创建两个项目
myblog-pc 前端
vue create myblog-pc
npm run serve
npmjs.com中搜索vue-axios 显示相关操作
npm i --save vue-axios axios 

myblog-rd 后端 数据服务 不需要界面展示

npmjs.com中搜索koa-generator 显示相关操作
npm install -g koa-generator
koa2 /tmp/foo 
cd /tmp/foo
npm install
npm start

npmjs.com中搜索koa-cors 显示相关操作
cors解决跨域问题
npm install koa-cors


使用token需要下载下列中间件
npmjs.com中搜索jsonwebtoken中间件 显示相关操作
验证token
npm install jsonwebtoken

JWT -- JSON WEB TOKEN
json:javascript的对象表示法


// err ctx.status即是response.status
        // ctx被翻译成上下文context 
        // 只是koa这个框架用到的一个名词 同时封装了request和response中这些属性
        // express框架中没有ctx这个概念
        // web开发中主要两个名词 request response
        // request 客户端浏览器向服务器端发送的请求 Request Headers
        // 隐式 显式(传送的数据) 可以通过request.xxx 获得请求数据
        // 做了一个简化
        // Response Body
        // 隐式 显式 数据


// jwttoken是无状态的 不在服务器端做任何存储
// jwt 适合做多端登录 session 可以做单点登录
// 解决鉴权问题时 jwttoken只是解决方案中的一个 而不是唯一一个
// 传统方式 session+cookie 服务器端会生成session的一个id 存储在cookie中
// cookie是最早出现的 服务器端可以在客户端存信息的一个文件
// windows系统中 cookie文件被存储在c盘用户名下appdata下一个隐藏文件夹
// cookie文件夹 txt文本文件
// cookie存储信息空间有限制
// session启动时会生成一个id 每一个用户都会有一个session
// 服务器端 保存用户的状态
// 两者差别 jwt 分散在客户端 无状态 

点击超链接/地址栏输入地址跳转页面 都是get方式
get方式 传参 两种
1.？+键值对(?blogid=3)
3.命名传参 (:blogId)












