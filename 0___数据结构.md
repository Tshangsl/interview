1.绪论
2.线性表
    1.线性表/线性结构 随机访问/链式结构 顺序访问
        顺序表
        线性链表    指针描述
        静态链表    数组描述
        循环链表
        双向链表
        双向循环链表
    线性顺序存储结构和链式存储结构区别优缺点
        顺序存储 适用于查找
            优点:存储密度大(=1) 易于查找和修改
            缺点:插入或删除元素时不方便 存储空间利用率低
                预先分配内存可能会造成存储空间的浪费
        链式存储  适用于插入/删除
            优点:插入或删除元素时很方便 使用灵活 存储空间利用率高
            缺点:存储密度小(<1)查找和修改需要遍历整个链表
3.栈和队列
4.串
5.数组和广义表
6.树和二叉树
    DFS 栈
    BFS 队列
    AVL平衡二叉树有什么特点 好处 和红黑树的区别
    AVL
        平衡二叉树又称AVL树，是一种特殊的二叉查找树
        其左右子数都是平衡二叉树且左右子树高度差的绝对值不超过1
        一句话表述为：
        以树中所有结点为根的树的左右子树高度差的绝对值不超过1.将二叉树上结点的左子树深度减去右子树深度称为平衡因子BF
        那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1.只要二叉树上有一个结点的平衡因子的绝对值大于1，该二叉树就是不平衡的。
    红黑树
        是一种二叉查找树
        但在每个结点增加一个存储位表示结点的颜色，可以是红或者黑（非黑即红）。
        通过对任何一条从根到叶子的路径上各个结点着色的方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因此红黑树是一种弱平衡二叉树
        相对于要求严格的AVL树来说，它的旋转次数少
        所以对于搜索、插入、删除操作比较多的情况下，通常使用红黑树。
        性质
            1.每个结点非红即黑
            2.根节点是黑的
            3.每个叶节点（叶节点即树尾端NULL指针或NULL结点）都是黑的
            4.如果一个结点是红色的，则它的子节点必须是黑色的
            5.对于任何结点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑结点。
    区别：
        AVL树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；
        红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。
7.图
数据结构
1.如何判断一个环是一个闭着的
2.JS中对象的数据结构在底层是用什么实现的
3.100个数中找出最大的用什么方法

基础排序算法：
    1.冒泡排序 最好O(n) 最坏O(n^2) 平均(n^2)
        冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动。
        每一轮操作都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了
    2.插入排序 最好O(n) 最坏O(n^2) 平均(n^2)
        插入排序的核心思想是“找到元素在它前面那个序列中的正确位置”。
        具体来说，插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。
    3.选择排序 都是O(n^2)
        选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。
进阶排序算法(分治)
    4.归并排序 O(nlog(n))
        归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：
            分解子问题：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
            求解每个子问题：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
            合并子问题的解，得出大问题的解：当数组被合并至原有的规模时，就得到了一个完全排序的数组
    5.快速排序 最好O(nlog(n)) 最坏O(n^2) 平均(nlog(n))
        快速排序在基本思想上和归并排序是一致的，仍然坚持“分而治之”的原则不动摇。区别在于，快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序。
        思路分析
            快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。
算法
1.递归与分治
    递归
        直接或间接调用自身的算法称为递归算法 用函数自身给出定义的函数称为递归函数
        每个递归函数都必须有非递归定义的初始值 否则递归函数就无法计算
    分治
        将一个难以直接解决的大问题 分割成一些规模较小的相同问题 这些子问题互相独立且与原问题相同
        递归地解这些子问题 然后将各子问题的解合并起来得到原问题的解
        由分治法产生的子问题往往是原问题的较小模式 为使用递归技术提供方便
    二分搜索
        充分利用元素间次序关系 采用分治策略 可在最坏情况下用O(logn)时间完成搜索任务
2.动态规划
    适用于动态规划法求解的问题 经分解得到的子问题往往不是互相独立的
    基本思想
        可以用一个表来记录所有已解决的子问题的答案 不管盖子问题以后是否被用到 只要它被计算过就将其结果填入表中
    动态规划算法适用于解最优化问题
        1.找出最优解的性质 并刻画其结构性质
        2.递归地定义最优值
        3.以自底向上的方式计算出最优值
        4.根据计算最优值时得到的信息 构造最优解
    0-1背包问题
3.贪心
    总是做出在当前看来最好的选择
    并不从整体最优上加以考虑 所做出的选择只是在某种意义上的局部最优解
    两个性质
        1.贪心选择性
        2.最优子结构性质
    与动态规划算法
    相同
        1.都要求最优子结构
    差别
    单源最短路径
    哈夫曼编码
    最小生成树
4.回溯(找出解空间中满足约束条件的所有解)
    有通用的解题方法之称 用它可以系统地搜索一个问题的所有解或任一解
    回溯算法是一个既带有系统性又带有跳跃性的搜索算法
    回溯法搜索解空间树 采用两种策略避免无效搜索
        1.约束函数在扩展结点处剪去不满足约束的子树
        2.用限制函数剪去得不到最优解的子树
        这两类函数统称为剪枝函数
    0-1背包
5.分支限界(找出满足约束条件的一个解)
    类似回溯法 也是在问题的解空间上搜索问题解的算法
    两者求解目标不同
        回溯法
            找出解空间中满足约束条件的所有解
        分支限界法
            找出满足约束条件的一个解
            或是在满足约束条件的解中找出使得木易目标函数值达到极大值或极小值的解
            即在某种意义下的最优解
    对解空间的搜索方式也不同
        回溯法
            深度优先方式搜索解空间
        分支限界法
            广度优先或最小耗费优先方式搜索解空间
6.随机化
    一个基本特征 对所求解问题的同一实例 用同一随机化算法求解两次可能得到完全不同的效果
    大致分四类
        1.数值随机化算法
            常用于数值问题的求解 这类算法得到的往往是近似解 且近似解的精度随计算时间的增加而不断提高
        2.蒙特卡罗算法
            求问题的准确解
            能求得问题的一个解 但是这个解未必是正确的
        3.拉斯维加斯算法
            不会得到不正确的解
            一旦找到一个解 这个解就是正确的解
        4.舍伍德算法
            总能求得问题的一个解 且所求的解总是正确的