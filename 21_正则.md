1. 什么是正则
    > 一门工具 目的是为了字符串模式匹配 从而实现搜索和替换功能 
    > 底层原理 使用状态机的思想进行模式匹配
    > 正则表达式是匹配模式 要么匹配字符 要么匹配位置
2. 字符
    > 两种创建方式
    1. 构造正则表达式
    ```
    new RegExp(pattern,attributes)
    ```
    - pattern 必选参数 用于指定需要进行匹配的模式字符串 以\\开头
    - flags 可选参数 用于指定正则表达式的标志信息 如 g i m 
    2. 正则表达式直接量
    > 正则表达式的基本组成元素
    1. 字符 - 数字 英文字母
    2. 元字符 - 特殊字符 构造表达式模式pattern
    > 正则表达式修饰符
    1. i 大小写不敏感
    2. g 全局
    3. m 多行匹配
    > 单个字符
    - 最简单的正则表达式可以由简单的数字和字母组成 没有特殊语义 纯粹就是一一对应的关系
    - /ab{2,5}c/g g是正则的一个修饰符 表示全局匹配 在目标字符串中按顺序找到满足匹配模式的所有子串
    ```
    /a/
    ```
    - 匹配特殊字符 使用元字符\ 转义字符 让后续的字符失去其本来的含义
    - 匹配*字符 由于*字符本身是个特殊字符 要用到转义字符使其失去原本含义
    ```
    /\*/
    ```
    - 如果本来这个字符不是特殊字符 使用转义符号就会让它拥有特殊含义
    - \n换行 \f换页 \r回车 \s空白 \t制表 \v垂直制表 [\b]回退
    > 多个字符
    - 引入集合区间和通配符方式实现一对多匹配
    1. 集合 [] /[123]/ /[0-9]/ /[a-z]/
    2. .除了换行符之外任何字符 \d单个数字 \D除了[0-9] \w包含下划线在内的但个字符 \W非单个字符 \s空白符 \S非空白符
    3. 排除字符组(反义字符组概念) 如[^abc] 字符组第一位放^脱字符 表示求反概念
    4. 匹配任意字符 可以使用[\d\D] [\w\W] [\s\S] [^]
    > 循环与重复
    1. ? 1个或0个 /colou?r/
    2. * >=0
    3. + >=1
    4. 贪婪匹配和惰性匹配
        1. 贪婪匹配 尽可能多匹配 /\d{2,5}/
        2. 惰性匹配 尽可能少匹配 /\d{2,5}?/g 虽然2到5都行 当2个就够的时候 不再往下尝试 
        - 通过在量词后面加个问号实现惰性匹配
        - {m,n}?
        - {m,} ?
        - ??
        - +?
        - *?
    5. 多选分支 {p1|p2|p3} 分支是惰性的 当前面的匹配上 后面的就不再尝试了
    > 例子
    1. 匹配16进制颜色值
    - /#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}/
    2. 匹配时间
    - /^([01][0-9]|[2][0-3]):[0-5][0-9]$/
    3. 匹配日期
    - 如 yyyy-mm-dd格式
    - /^[0-9]{4}-([0][1-9]|[1][012])-([0][1-9]|[12][0-9]|[3][01])$/
    4. windows操作系统文件路径
    5. 匹配id
    - /id=".*?"/

    > 特定次数
    1. {}给重复匹配设置精确的区间范围 匹配3次/a{3}/ 至少匹配2次/a{2,}/
    > 位置边界
    0. ES5中 有6个锚字符
    - ^ $ \b \B (?=p)p是一个子模式 即p前面的位置正向先行断言 (?!p)负向先行断言
    1. ^ 脱字符 匹配开头 在多行匹配中会匹配行开头
    2. $ 美元符号 匹配结尾 多行匹配中匹配行结尾
    3. \b 单词边界 \W \w[0-9a-zA-Z]之间, \w ^之间, \w $之间
    4. \B
    5. (?=p)
        - 正向先行断言
        - p是一个子模式 p前面的位置
        - 如(?=l)表示l字符前面的位置
        ```
        let res = 'hello'.replace(/(?=l)/g,'#');
        console.log(res);
        // => he#l#lo
        ```
    6. (?!p)
        - 负向先行断言
        - 是(?=p)反面意思
        ```
        let res = 'hello'.replace(/(?!l)/g,'#');
        console.log(res);
        // =>#h#ell#o#
        ```
    7. (?<=p) (?<!p)
        - 环视 看看右边或看看左边
        - 
    > 相关案例
    1. 不匹配任何东西的正则
    /.^/
    2. 数字的千位分隔符表示法
    - 弄出最后一个逗号
    - (?=\d{3}$)
    ```
    let res = '12345678'.replace(/(?=\d{3}$)/g,',')
    // res 12345,678
    ```
    - 匹配其余的案例
    ```
    let res = '123456789'.replace(/(?!^)(?=\d{3})+$)/g,',')
    
    ```

    1. \b 匹配能构成单词的字符(\w)和不能构成单词的字符(\W)中间那个位置
    - /\bcat\b/ 匹配cat单词
    > 字符串边界
    1. 元字符^用来匹配字符串的开头
    2. 元字符$用来匹配字符串的末尾
    > 子表达式
    - 从简单到复杂的正则表达式通常要采用分组 回溯引用 逻辑处理的思想
    1. 分组 ()元字符将所包含的正则表达式分为一组
    2. 回溯引用 模式的后面部分引用前面已经匹配到的子字符串 \1表示引用的第一个子字符串
    3. 前向查找
    > 反向引用
    - \1 表示引用之前的那个分组(-|\/|\.)不管它匹配到什么如- \1都匹配哪个同样的具体某个字符
    - \2 \3分别指代第二个第三个分组

    > JS正则表达式方法
    1. test 
    - 返回Boolean 查找对应的字符串中是否存在模式
    ```
    let str = '112ad'
    let reg = new RegExp('1.',"");
    alert(reg.test(str));//true
    ```
    2. exec
    - 查找并返回当前的匹配结果 并以数组的形式返回
    ```
    let str = '12sd2';
    let reg = new RegExp('1.','');
    let arr = reg.exec(str);
    ```
    - 如果不存在模式 则arr为null 否则arr总是一个长度为1的数组 其值就是当前匹配项 arr还有三个属性 index 当前匹配项的位置 lastIndex 当前匹配项结束的位置(index+当前匹配项的长度) input就是str
    - exec方法受参数g的影响 若指定g 则下次调用exec时 会从上个匹配的lastIndex开始查找
    3. macth
    - match是String对象的一个方法
    ```
    let str = '1ada1'
    let reg = new RegExp('1','');
    alert(str.match(reg));
    ```
    - match方法有些类似exec 但是exec是RegExp对象的方法 math是String对象的方法
    - 两者还有一个不同点 就是对参数g的解释 
    - 如果指定参数g match一次返回所有的结果
    4. search方法
    - 用于检索字符串中指定的子字符串 或检索与正则表达式匹配的子字符串 并返回子串的起始位置
    ```
    var str = 'Visit Runoob';
    var n = str.search(/Runoob/i)
    // 输出6
    ```
    5. replace方法
    ```
    stringObject.replace(regexp/substr,replacement);
    ```
    - replace中 第二个参数里用$1 $2 $3指代相应的分组
    1. 参数1 必需 规定的字符串或正则表达式
    2. 参数2 必需 一个字符串值 规定了替换文本或生成替换文本的函数
    - replacement中的$字符具有特定含义
        > 例子
        - // 把Deo John 转换为John Deo的形式
        ```
        var str = 'Doe,John';
        str.replace(/(\w+)\s*,\s*(\w+)/,"$2 $1")
        ```
        - $1 $2就是按顺序对应小括号里面的小正则 捕获到的内容
    - 用于在字符串中用一些字符替换另一些字符 或替换一个与正则表达式匹配的子串
    ```
    var str = document.getElementById('demo').innerHTML;
    var txt = str.replace(/microsoft/i,'Runoob')
    // 输出 Visit Runoob
    ```
    > tip
    1. \1
    - \1必须与小括号配合使用 正则表达式中的小括号()是代表分组的意思 如果在气候出现/1代表要与第一个小括号匹配的内容相同
    
    > 正则表达式回溯法原理
    - 包括
    1. 没有回溯的匹配
    2. 有回溯的匹配
    3. 常见的回溯形式

    > 锚点
    - 匹配一个位置 而不是自负 如^匹配字符串的开头 \b匹配单词边界 (?=\d)匹配数字前面的位置
    > 分组
    - 非捕获分组
    - (?:ab)+

    > 注意问题
    1. 匹配字符串整体位置
    /^abc|bcd$/ /^(abc|bcd)$/
    2. 量词连缀问题
    /^[abc]{3}+$/ /^([abc]{3})+$/
    3. 元字符转义问题
    - string中\也要转义
    1. 字符组中的元字符 跟字符组有关的元字符有[] ^ - 因此在会引起歧义的地方进行转义
    2. 匹配[abc]{3,5} /\[abc\]/ /\[abc]/ /\{3,5}/