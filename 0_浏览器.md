1.浏览器是如何工作的
    1.浏览器输入url后发生了什么
        1.DNS解析(将我们输入在网页地址栏的URL通过DNS解析成IP地址)
            1.为什么进行DNS解析
                要想得到接收方的MAC地址 需要通过对方的IP地址获取 对方的IP需要通过DNS解析
                DNS解析：
                    将我们输入在网页地址栏的URL通过DNS解析成IP地址
                DNS：
                    将域名转化为IP地址的过程
                DNS解析过程中会发生什么(系统 路由 ISP 缓存查询 DNS递归迭代查询)
            2.系统缓存查询(系统缓存中查找是否存在该域名对应的IP地址)
                1.浏览器会调用一个库函数 检测本地的hosts文件(可以认为是电脑本地的一个地址映射文件)
                    从该文件中查看是否有对应的该域名的IP地址
            3.路由器缓存 ISP缓存
                1.如果系统缓存没有 就会向DNS服务器发送请求 而网络服务一般都会先经过路由器以及网络服务商(电信)
                    所以会先查询路由器缓存 然后再查询ISP的DNS缓存
                2.ISP缓存 本身是一种宽带接入提供商给网页批量访问加速的技术
                            ISP会将当前访问量较大的网页内容放到ISP服务器缓存中
                            当有新的用户请求相同内容的时 可以直接从缓存中发送相关信息
                            而不必每次都去访问真正的网站 从而加快不同用户对相同内容的访问速度 同时也能节省网间流量结算成本
            4.DNS递归查询
                如果路由缓存和ISP缓存的DNS缓存还是没有的话 我们就进行DNS递归查询
                从根域名服务器开始查询 然后再到顶级域名服务器 再到主域名服务器依次查询
                    两种查询方式
                        1.递归查询
                            DNS服务器收到请求时 检查DNS缓存 如果没有就会村问其他服务器 并将返回的查询结果返回给客户端
                        2.迭代查询
                            DNS收到请求时 不是直接返回查询结果 而是告诉客户端另一台DNS服务器地址 然后客户端再向这台DNS服务器提交请求 依次循环
            5.DNS优化
                1.浏览器缓存 本地的DNS缓存服务器
                2.DNS负载均衡 DNS根据每台机器的负载量 地理位置的限制等 去提供高效快速的DNS解析服务
        2.TCP连接
            通过DNS查询到IP地址后 下一步与服务器建立联系 为下面的数据传输做准备
            1.TCP：(Transmission Control Protocol传输控制协议)
                一种面向连接的 可靠的 基于字节流的传输层通信协议
            2.TCP头部报文
                1.源端口号(source port) 目的端口号(destination port)
                    应用程序的端口号和应用程序所在的主机的IP地址统称为socket(套接字)
                    在互联网上socket唯一标识每一个应用程序
                    源端口+源IP+目的端口号+目的IP 称为 套接字对
                        一堆套接字就是一个连接
                2.序列号(Sequence Number)
                    确保数据通信的有序性 保证分割的数据段在原始数据包的位置
                    初始的序列号由自己决定 后续的序列号由对端的ACK决定
                3.TCP flag
                    TCP首部有六个标志比特 它们中的多个可同时被设置为1
                    依次为URG ACK PSH RST SYN FIN
                    1.ACK
                        应答域有效 有两个取值 0 1
                            1 应答域有效 0 无效
                    2.SYN 同步序列号
                        TCP握手发送的第一个数据包 用来建立TCP连接
                        SYN标志位和ACK标志位搭配使用 
                        连接请求时：SYN=1 ACK=0
                        连接被响应时：SYN=1 ACK=1
                        这个标志位的数据包经常用来进行端口扫描 
                        扫描者发送一个只有SYN的数据包 如果对方主机响应了一个数据包回来
                        表明这台主机存在这个端口
                    3.FIN
                        表示发送端已经达到数据末尾 发送FIN标志位的TCP数据包后 连接将被断开
                4.Window Size   
                    滑动窗口的大小 用来进行流量控制
            为什么进行TCP三次握手：
                1.确认双方的接收与发送能力是否正常
                2.指定自己的初始化序列号 为后面的可靠传送做准备
                3.如果是HTTPS协议的话 三次握手这个过程 还会及进行数字证书的验证以及加密密匙的生成
            TCP三次握手过程：
                最重要两点：
                    1.客户端和服务器端状态的变化
                    2.三次握手过程标志信息的变化
                1.初始状态：
                    1.客户端处于closed(关闭)状态
                    2.服务器处于listen(监听)状态
                2.第一次握手
                    客户端发送请求报文 将SYN=1(j)初始化序列发送给客户端
                    发送完后 客户端将处于SYN_Send状态
                3.第二次握手
                    服务端收到SYN请求报文后 如果同意连接 会以自己的SYN(服务端) = 0(K)
                    和ack(1) = SYN(客户端)+1(ACK=1)报文作为答应
                    服务器为SYN_Recieve状态
                4.第三次握手
                    客户端收到服务端的SYN+ACK然后发送ack = SYN(服务端)+1(ACK=1)
                    确认包作为应答 客户端转为established状态
                5.为什么不是一次两次握手
                    防止服务器端一直等待浪费资源
                    防止已经失效的连接请求报文段突然传送到服务端 因而产生错误
            1.三次握手
            2.四次挥手
        3.HTTP请求
            客户端与服务器端通过TCP三次握手建立连接后 客户端开始向服务端主动发起请求
            服务器端接收到客户端发送的信息 返回响应文件和信息 状态码

            浏览器的渲染原型
        4.构建DOM树
        5.构建CSSOM树
        6.生成渲染树
        7.合成绘制

        1.缓存解析
            1.浏览器缓存：浏览器会记录DNS一段事件 因此 只是第一个地方解析DNS请求
            2.操作系统缓存： 如果在浏览器缓存中不包含这个记录 则会使系统调用操作系统 获取操作系统记录(保存最近的DNS查询缓存)
            3.路由器缓存：如果上述两个步骤均不能成功获取DNS记录 继续搜索路由器缓存
            4.ISP缓存：若上述均失败 继续向ISP搜索
        2.域名解析 解析获取相应的ip地址
        3.浏览器像服务器发出TCP连接 与浏览器建立TCP三次握手
        4.握手成功后 浏览器向服务器发送http请求 请求数据包
        5.服务器处理收到的请求 将数据返回至浏览器
        6.浏览器收到HTTP响应
        7.读取页面内容 浏览器渲染 解析html源码
        8.生成DOM树 解析CSS样式 js交互
        9.客户端和服务器交互
        10.AJAX查询

        (DNS 建立TCP连接(三次握手) 浏览器发出读取文件HTTP请求(该请求报文作为TCP三次握手的第三个报文数据发送给服务器) 服务器对浏览器做出响应 把对应的html文本发送给浏览器 释放TCP连接 )
        1.浏览器向 DNS(Domain Name System) 服务器请求解析该 URL 中的域名所对应的 IP 地址;/域名解析 获取相应的IP地址
        2.建立TCP连接（三次握手）;
        3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
        4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
        5.释放 TCP连接（四次挥手）;
        6.浏览器将该 html 文本并显示内容;
2.浏览器渲染引擎工作流程
    1.解析HTML生成DOM树 解析CSS 生成CSSOM树 将DOM树和CSSOM树结合生成渲染树 render
    2.根据渲染树 浏览器计算出页面有哪些节点 各节点的CSS以及从属关系-回流
    3.根据渲染树以及回流得到的节点信息 计算出每个节点在屏幕中的位置-重绘
    4.最后将得到的节点位置信息交给浏览器的图形处理程序 让浏览器显示页面
    ((分析HTML元素)DOM树 (创建StyleRules CSS分析器 分析CSS文件)Rules树 (DOM树和Rules树)Render树 Layout(分析布局信息 计算坐标位置) Painting(绘制))
    (以上流程不一定会严格遵守先后顺序 有可能同时出现)
    1.创建DOM树 HTML分析器 分析HTML元素 构建一棵DOM树
    2.创建StyleRules CSS分析器 分析CSS文件 构建Rules树 生成CSSOM树
    3.创建Render树 将DOM树和Rules树关联起来 构建一颗Render树
    4.布局Layout分析布局信息 计算坐标位置
    5.绘制Painting 开始绘制
        这几个工作流程不会严格遵循先后顺序 而是有可能出现同时进行
2.重绘(Repaint)重排/回流(Reflow)是什么以及如何减少重绘、避免重排
    重排(Reflow)/回流
        1.DOM中各个元素都有自己的盒子模型，
        2.需要浏览器根据样式进行计算，
        3.并根据计算结果将元素放到特定位置，
        4.这就是Reflow
    触发Reflow条件
        1.增、删、改、移DOM
        2.修改CSS样式
        3.Resize窗口
        4.页面滚动
        5.修改网页的默认字体
        1.布局流相关操作
            1.盒模型相关操作
            2.定位相关操作
            3.浮动相关操作
        2.改变节点内的内容
        3.CSS
    重绘（Repaint)
        当节点的部分属性发生变化 但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。
        1.当各种盒子的位置、大小以及其他属性改变时，
        2.浏览器需要把这些元素都按照各自的特性绘制一遍，
        3.这个过程称为Repaint。
        table(渲染树中节点的属性值)
        table及其内部元素可能需要多次计算才能确定好其在 渲染树中节点的属性值，
        比同等元素要多花两倍事件，这就是我们尽量避免使用table布局页面的原因之一
    触发Repaint的条件：
        DOM改动
        CSS改动
    回流：(重构/重排/reflow)
        当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流，每个页面至少需要回流一次，就是在页面加载的时候
    触发条件：
        任何页面布局和几何属性的改变都会触发回流
    重绘和回流：
        在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘
        回流一定会引发重绘 重绘不一定会引发回流
    重绘重排的代价：
        耗时 导致浏览器卡慢
    减少重绘、避免重排
        本质上，就是合并修改。具体的措施有：
            DOM层面：DocumentFragment本质上是一个占位符，真正插入页面的是它的所有子孙节点，所以，将需要变动的DOM节点先汇总到DocumentFragment，然后一次性插入，可以减少DOM操作的次数。

            CSS层面：操作多个样式时，可以先汇总到一个类中，然后一次性修改
    优化：
        1.每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。
        浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
        2.操作时做的优化，减少对渲染树的操作，合并多次的DOM和样式修改，并减少对style样式的请求
3.window.onload的作用
window.onload是等文档和资源都加载完成后调用的事件，保证js获取元素 的时候，已经加载。
4.什么是window对象? 什么是document对象?
    window是js中最大的对象，表示窗口，包含document
    document文档对象，表示HTML
7.OOA(Object-Oriented Analysis)：面向对象的分析
  OOD(Object-Oriented Design):面向对象的设计
  OOP(Object-Oriented Programming):面向对象编程
8.浏览器内的事件队列
    JavaScript是基于单线程运行的,同时又是异步执行的，一般来说，这种既是单线程又是异步的语言都是基于事件来驱动的，恰好浏览器就给JavaScript提供了这么一个环境

    setTimeout的等待时间结束后并不是直接执行的而是先推入浏览器的一个任务队列，在同步队列结束后再一次调用任务队列中的任务

    一般来说 浏览器会有以下几个线程
    1.js引擎线程(解释执行js代码 用户输入 网络请求)
    2.GUI线程(绘制用户界面 与js主线程是互斥的)
    3.http网络请求线程(处理用户的get,post等请求，等返回结果后将回调函数推入任务队列中)
    4.定时触发器线程(setTimeout setInterval等待时间结束后把执行函数推入任务队列中)
    5.浏览器中事件处理线程(将click mouse 等交互事件发生后 将这些事件放入事件队列中)

    当我们调用一个函数，它的地址参数局部变量都会压入一个stack中

    整个js的代码macrotask先执行 同步代码执行完后有microtask执行microtask 没有microtask执行下一个macrotask 如此往复循环至结束
9.window.open方法
10.线程和进程有什么区别
    1.计算机的核心是CPU，它承担了所有的计算任务
    2.单个CPU一次只能运行一个任务
    3.进程它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态
    4.一个进程可以包括多个线程。
    5.一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
    6.一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
    7.一个防止其他线程使用的简单方法"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
    8.某些内存区域，只能供给固定数目的线程使用。
    操作系统的设计，因此可以归结为三点：
    （1）以多进程形式，允许多个任务同时运行；
    （2）以多线程形式，允许单个任务分成不同的部分运行；
    （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
11.浏览器缓存
    1.前言
        1.浏览器缓存 
            是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。
        2.但也不是说缓存没有缺点，如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。
        缓存的优点：
            1.减少了冗余的数据传输，节省网费
            2.减少服务器的负担，提升网站性能
            3.加快了客户端加载网页的速度
    2. 缓存流程
        我们可以认为，浏览器里有一个专门存放缓存规则的一个数据库，也可以说是一个映射表，把缓存资源信息，同电脑磁盘中的实际文件的地址，对应起来。（大概意思，别较真）
        这个缓存规则的表，在浏览器中是可以看到的： chrome://cache/
        不过我升级了浏览器之后，就不好使了，但是找到了 chrome://net-internals/#httpCache ，不知道是不是就是原来的，知道的同学也可以反馈一下
        上面所说的 缓存规则，就是声明所请求的这个资源，要采取哪种缓存策略？缓存多长时间？等等。。。而这个规则，是在http的header中的返回来的。
         是response header ，而不是 request header ！！！
    3.缓存规则
        强缓存和协商缓存
        强缓存
            简单粗暴，如果资源没过期，就取缓存，如果过期了，则请求服务器。
            如何判断资源是否过期
                主要是看 response headers 中的 Cache-Control 的值，图中的max-age = 31xxxxxxx，就是说在这些秒内，都直接使用缓存，超过了就继续请求服务器
                而和 Cache-Control 并列的，还有一个 Expires ，已经基本淘汰了，所以不用管
            Cache-Control 的几个取值含义：(规则可以有多个)
                private： 仅浏览器可以缓存
                public： 浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究）
                max-age=xxx 过期时间（重要）
                no-cache  不进行强缓存（重要）
                no-store   不强缓存，也不协商缓存，基本不用，缓存越多才越好呢
            对于强缓存，我们主要研究 Cache-Control 中的 max-age 和 no-cache
                判断该资源是否命中强缓存，就看 response 中 Cache-Control 的值，如果有max-age=xxx秒，则命中强缓存。如果Cache-Control的值是no-cache，说明没命中强缓存，走协商缓存。
            强缓存流程：
                1.第一次请求 a.js ，缓存表中没该信息，直接请求后端服务器。
                2.后端服务器返回了 a.js ，且 http response header 中 cache-control 为 max-age=xxxx，所以是强缓存规则，存入缓存表中。
                3.第二次请求 a.js ，缓存表中是 max-age， 那么命中强缓存，然后判断是否过期，如果没过期，直接读缓存的a.js，如果过期了，则执行协商缓存的步骤了。
            max-age = 0 ，和 no-cache区别
                no-cache直接不进行强缓存，让你去走协商缓存，而max-age=0是进行强缓存，但是过期了，需要更新。。。虽然实际上看起来两者效果是一样的。
    协商缓存
        触发条件：
            1.Cache-Control 的值为 no-cache （不强缓存）
            2.或者 max-age 过期了 （强缓存，但总有过期的时候）
        ETag：每个文件有一个，改动文件了就变了，可以看似md5
        Last-Modified：文件的修改时间
        协商缓存：
            1.请求资源时，把用户本地该资源的 ETag 同时带到服务端，服务端和最新资源做对比。
            2.如果资源没更改，返回304，浏览器读取本地缓存。
            3.如果资源有更改，返回200，返回最新的资源。
        缓存命中显示：
            1.从服务器获取新的资源
            2.命中强缓存，且资源没过期，直接读取本地缓存
            3.命中协商缓存，且资源未更改，读取本地缓存
            注意：协商缓存无论如果，都要向服务端发请求的，只不过，资源未更改时，返回的只是header信息，所以size很小；而资源有更改时，还要返回body数据，所以size会大。
    如何配置资源的缓存规则
        可以有后端服务器配置，也可以在nginx中配置，稍后会更新一张nginx的配置
    强缓存和协商缓存的区别
        缓存类型  获取资源形式  状态码 发送到服务器
        强缓存    从缓存中取   200(from cache) 否直接从缓存取
        协商缓存  从缓存中取   304(Not Modified) 是 通过服务器来告知缓存是否可用
3.前端如何优化网站性能
    1.减少 HTTP 请求数量
        CSS Sprites
        合并 CSS 和 JS 文件
        采用 lazyLoad
    2.控制资源文件加载优先级
    3.利用浏览器缓存 减少重排（Reflow）
    4.图标由字体图标改成图片图标
4.浏览器有哪些内核 哪些css属性需要设置
    1.IE:Trident内核
    2.Firefox:Gecko内核
    3.Google:Blink内核
    4.Safari:Webkit内核

    -webkit- 针对safari chrome浏览器的内核css写法
    -moz- 针对firefox浏览器的内核css写法
    -ms- 针对IE内核的css写法
    -o- 针对Opera内核的css写法







