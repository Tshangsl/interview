1. 浏览器是如何工作的
    > 浏览器输入url后发生了什么
    - (
        1. DNS解析 将我们输入在地址栏中的URL通过DNS解析成IP地址
        2. TCP连接(传输层)
        3. HTTP请求(应用层)
        > 以下实际进行时不是独立的会有交叉
        4. 构建DOM树
        5. 构建CSSOM树
        6. 构建Render树
        7. 布局Layout
        > 回流:据render渲染树 计算哪些节点 各节点CSS及从属关系
        > 重绘:据render渲染树及回流得到的节点信息 计算每个节点屏幕中位置
        > 绘制Painting(浏览器图形处理程序)
    )
    1. DNS解析
        > (将我们输入在网页地址栏的URL通过DNS解析成IP地址)
        > (查找是否存在该域名对应的IP地址 
        > 系统(浏览器/操作系统)缓存查询=>(向DNS服务器发送请求)路由器缓存/ISP缓存=>DNS递归/迭代查询)
        1. 为什么进行DNS解析
            > 要想得到接收方的MAC地址 需要通过对方的IP地址获取 对方的IP需要通过DNS解析
            - DNS解析：
            > 将我们输入在网页地址栏的URL通过DNS解析成IP地址
            - DNS：
            > 将域名转化为IP地址的过程
            - DNS解析过程中发生什么
            > (系统(浏览器/操作系统)=>(向DNS服务器发送请求)路由=>ISP缓存查询=>DNS递归迭代查询)
        2. 系统缓存查询
            >(系统缓存中查找是否存在该域名对应的IP地址)
            1. 浏览器会调用一个库函数 检测本地的hosts文件(可以认为是电脑本地的一个地址映射文件) 从该文件中查看是否有对应的该域名的IP地址
        3. 路由器缓存 ISP缓存
            1. 如果系统缓存没有 就会向DNS服务器发送请求 而网络服务一般都会先经过路由器以及网络服务商(电信)所以会先查询路由器缓存 然后再查询ISP的DNS缓存
            2. ISP缓存 本身是一种宽带接入提供商给网页批量访问加速的技术
            >ISP会将当前访问量较大的网页内容放到ISP服务器缓存中 
            >当有新的用户请求相同内容的时 可以直接从缓存中发送相关信息 而不必每次都去访问真正的网站 从而加快不同用户对相同内容的访问速度 同时也能节省网间流量结算成本
        4. DNS递归查询
            > 如果路由缓存和ISP缓存的DNS缓存还是没有的话 我们就进行DNS递归查询
            > 从根域名服务器开始查询 然后再到顶级域名服务器 再到主域名服务器依次查询
            > 两种查询方式
            1. 递归查询(服务器端递归查询 返回给客户端查询结果)
                > DNS服务器收到请求时 检查DNS缓存 
                > 如果没有就会询问其他服务器 并将返回的查询结果返回给客户端
            2. 迭代查询(服务器端返回客户端另一台服务器地址 客户端向另一台服务器发起请求)
                > DNS收到请求时 不是直接返回查询结果 而是告诉客户端另一台DNS服务器地址 
                > 然后客户端再向这台DNS服务器提交请求 依次循环
        5. DNS优化(浏览器缓存/DNS负载均衡)
            1. 浏览器缓存 本地的DNS缓存服务器
            2. DNS负载均衡 DNS根据每台机器的负载量 地理位置的限制等 去提供高效快速的DNS解析服务
    2. TCP连接
        >通过DNS查询到IP地址后 下一步与服务器建立联系 为下面的数据传输做准备
        1. TCP
            > (Transmission Control Protocol传输控制协议)
            - 一种面向连接的 可靠的 基于字节流的传输层通信协议
        2. TCP头部报文
            1. 源端口号(source port)目的端口号(destination port)
                - socket(套接字): 应用程序的端口号和 应用程序所在的主机的IP地址
                - 互联网中socket唯一标识每一个应用程序
                - 套接字对 源端口+源IP+目的端口号+目的IP(一对套接字对就是一个连接)                    
            2. 序列号(Sequence Number)
                1. 确保数字通信有序性 
                2. 保证分割数据段在原始数据包位置 
                3. 初始序列号由自己决定 
                4. 后续由对端ACK决定
            3. TCP flag
                > TCP首部有六个标志比特 它们中的多个可同时被设置为1 依次为URG ACK PSH RST SYN FIN
                1. ACK
                    - 应答域有效 有两个取值 0 1
                    - 1 应答域有效 0 无效
                2. SYN 同步序列号
                    - (这个标志位的数据包长用来进行端口扫描)
                    - TCP握手发送的第一个数据包 用来建立TCP连接
                    - SYN标志位和ACK标志位搭配使用 
                    - 连接请求时：SYN=1 ACK=0
                    - 连接被响应时：SYN=1 ACK=1
                        
                    - 扫描者发送一个只有SYN的数据包 如果对方主机响应了一个数据包回来 表明这台主机存在这个端口
                3. FIN
                    - 表示发送端已经达到数据末尾 发送FIN标志位的TCP数据包后 连接将被断开
                4. URG
                5. RSG
                6. PSH
            4. Window Size   
                滑动窗口的大小 用来进行流量控制
        3. 为什么进行TCP三次握手：
            1. 确认双方接收发送数据能力/
            2. 指定自己初始化序列号 为后面可靠传输做准备/
            3. HTTPS协议三次握手 会进行CA证书的验证 以及加密密匙的生成)
        4. TCP三次握手过程：
            > 最重要两点：
            > (客户端服务器端状态变化/标志信息变化)
            - 客户端和服务器端状态的变化
                (Client Server
                closed listen
                SYN_Send Listen
                SYN_Send SYN_Recieve
                Established SYN_Recieve)
            - 三次握手过程标志信息的变化
                - (SYN(Client)=1(j)
                - SYN(Server)=0(k) ACK(1)=SYN(Client)+1(ACK)=1
                - ACK=SYN(Server)+1(ACK=1)
            1. 初始状态：
                1. 客户端处于closed(关闭)状态
                2. 服务器处于listen(监听)状态
            2. 第一次握手(SYN=1(j) 客户端SYN_Send状态)
                - 客户端发送请求报文 将SYN=1(j)初始化序列发送给客户端
                发送完后 客户端将处于SYN_Send状态
            3. 第二次握手(SYN)
                - 服务端收到SYN请求报文后 如果同意连接 会以自己的SYN(服务端) = 0(K) 和ack(1) = SYN(客户端)+1(ACK=1)报文作为答应
                - 服务器为SYN_Recieve状态
            4. 第三次握手
                - 客户端收到服务端的SYN+ACK然后发送ACK = SYN(服务端)+1(ACK=1)
                确认包作为应答 客户端转为established状态
            5. 为什么不是一次两次握手
                1. 防止服务器端一直等待浪费资源
                2. 防止已经失效的 连接请求报文段 突然传送到服务端 因而产生错误
    3. HTTP请求
        - 客户端与服务器端通过TCP三次握手建立连接后 客户端开始向服务端主动发起请求 服务器端接收到客户端发送的信息 返回响应文件和信息 状态码 浏览器的渲染原型
    - 四次挥手释放TCP连接
    4. 构建DOM树
    5. 构建CSSOM树
    6. 生成渲染树
    7. 合成绘制
2. 浏览器渲染引擎工作流程
    1. 解析HTML生成DOM树 解析CSS 生成CSSOM树 将DOM树和CSSOM树结合生成渲染树 render
    2. 根据渲染树 浏览器计算出页面有哪些节点 各节点的CSS以及从属关系-回流 
    3. 根据渲染树以及回流得到的节点信息 计算出每个节点在屏幕中的位置-重绘 
    4. 最后将得到的节点位置信息交给浏览器的图形处理程序 让浏览器显示页面

    (以上流程不一定会严格遵守先后顺序 有可能同时出现)
    1. 创建DOM树 HTML分析器 分析HTML元素 构建一棵DOM树
    2. 创建StyleRules CSS分析器 分析CSS文件 构建Rules树 生成CSSOM树
    3. 创建Render树 将DOM树和Rules树关联起来 构建一颗Render树
    4. 布局Layout分析布局信息 计算坐标位置
    5. 绘制Painting 开始绘制
3. 重绘(Repaint)重排/回流(Reflow)是什么以及如何减少重绘、避免重排
    > 重排(Reflow)/回流/重构
    - DOM中各个元素都有自己的盒子模型，需要浏览器根据样式进行计算，并根据计算结果将元素放到特定位置，这就是Reflow
    - 当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流,每个页面至少需要回流一次，就是在页面加载的时候
    - 触发Reflow条件
        - (任何页面布局和几何属性的改变都会触发回流)
        1. 增、删、改、移DOM
        2. 修改CSS样式
        3. Resize窗口
        4. 页面滚动
        5. 修改网页的默认字体
        
        1. 布局流相关操作
            1. 盒模型相关操作
            2. 定位相关操作
            3. 浮动相关操作
        2. 改变节点内的内容
        3. CSS
    - 重绘（Repaint)
        - 当节点的部分属性发生变化 但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。
        1. 当各种盒子的位置、大小以及其他属性改变时，
        2. 浏览器需要把这些元素都按照各自的特性绘制一遍，
        3. 这个过程称为Repaint。
        - table(渲染树中节点的属性值)
        - table及其内部元素可能需要多次计算才能确定好其在 
        - 渲染树中节点的属性值，比同等元素要多花两倍时间 这就是我们尽量避免使用table布局页面的原因之一
    - 触发Repaint的条件：
        - DOM改动
        - CSS改动
    > 重绘和回流：
    - 在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘
    - 回流一定会引发重绘 重绘不一定会引发回流
    > 重绘重排的代价：
    - 耗时 导致浏览器卡慢
    > 减少重绘、避免重排
    - 本质上，就是合并修改
    - 具体的措施有：
        1. DOM层面：
            - 将需要变动的DOM节点先汇总到DocumentFragment 然后一次性插入 减少DOM操作次数
            - DocumentFragment本质上是一个占位符，真正插入页面的是它的所有子孙节点
        2. CSS层面：
            - 操作多个样式 汇总到一个类中 然后一次性修改 减少对style样式的请求
    - DocumentFragment
        - 文档片段接口 一个没有父对象的最小文档对象
        - 它被作为一个轻量级的Document使用 就像标准的document一样 存储由节点nodes组成的文档结构
        > 与document相比 最大的区别是DocumentFragment不是真实DOM树的一部分 它的变化不会触发DOM树的重新渲染 且不会导致性能等问题
    - 优化：
        1. 每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。
            - 浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。
            - 但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
        2. 操作时做的优化，减少对渲染树的操作，合并多次的DOM和样式修改，并减少对style样式的请求
4. window.onload window.open
    > window.onload
    - 网页加载完毕后立即执行的操作 即当HTML加载完毕后 立即执行某个方法等
    - 因为页面中的代码一般情况下 从上到下 从左到右顺序执行
    - 所以当JS代码需要获取页面中的元素时
    - 如果script标签在元素前面 需要加window.onload
    - 如果script标签在元素后面 不需要加window.onload
    > window.open
    - 用于打开一个新的浏览器窗口或查找一个已命名的窗口
    - 语法 window.open(URL,name,space,replace)
5. window对象 document对象
    > window
    - JS中最大的对象 表示窗口 包含document
    > document
    - 文档对象 表示HTML
6. 浏览器线程
    1. JS引擎线程(解释执行JS代码 用户输入 网络请求)
    2. GUI线程(绘制用户界面 与JS主线程是互斥的)
    3. HTTP网络请求线程(处理用户的get/post等请求 等返回结果后将回调函数推入任务队列中)
    4. 定时触发器线程(setTimeout setInterval等待时间结束后把执行函数推入任务队列中)
    5. 浏览器中事件处理线程(将click mouse 等交互事件发生后 将这些事件放入事件队列中)
7. HTTP缓存和CDN缓存/客户端缓存和服务器端缓存 
    > HTTP缓存
    - 浏览器HTTP缓存由HTTP报文的首部字段决定
    - 客户端缓存 浏览器作为客户端收到服务器端响应后 对响应首部字段进行解析 分析出相应的缓存规则 将资源按规则进行缓存 再次请求时 如果命中缓存 则直接读取本地缓存 不再发出请求
    - 缓存规则
        > HTTP缓存规则由响应首部字段控制
        关键字
        > (确定缓存存储时间 1.0Expires 1.1Cache-Control)
        > (确定缓存是否需要被更新/缓存对比 Last-Modified Etag)
        1. 确定缓存存储时间
            > Expires
            - 服务端返回的到期时间 分为相对文件的最后访问时间 和绝对修改时间
            - 缺点: 返回的是服务器端时间 比较的是客户端时间 如果不一致可能出现错误
            - HTTP1.0中用来控制缓存时间的参数 响应头包含日期/时间 在此时间后 响应过期 过去的时间或无效时间 缓存但立即过期 等同于cache-control = no-cache 未来的时间 缓存到对应时间 
            
            > Cache-Control
            - (public/private/max-age/s-max-age/no-store/no-cache)
            > HTTP1.1中用来控制缓存的参数
            1. public:表示响应可以被任何对象(包括：发送请求的客户端 代理服务器 等等)缓存
            2. private:表示响应只能被单个用户缓存 不能用作共享缓存(即代理服务器不能缓存它)
            3. max-age=<seconds>:设置缓存存储最大周期相对请求时间缓存seconds秒 在此期间 访问资源直接读取本地缓存 不向服务器发起请求 (与expires同时出现 max-age优先级更高)
            4. s-max-age=<seconds>: 规则等同max-age 覆盖max-age/Expires头 但是仅适用于共享缓存(如各个代理)并且私有缓存中它被忽略(于expires/max-age同时出现 s-maxage优先级更高)
            5. no-store:不缓存服务器相应的任何内容 每次访问资源都要服务器完整响应
            6. no-cache:缓存资源 但立即过期 每次请求都要跟服务器对比验证资源是否被修改(等同max-age=0)

            > 区别
            1. 当Cache-Control设置为max-age = xx并且同时设置Expires时 Cache-Control优先级更高
        2. 确定缓存是否要被更新(缓存对比)
            > Last-Modified
            - Last-Modified对应If-Modified-Since
            - (上次修改时间 缓存过期 与请求中If-Modified-Since比对 一致则继续使用之前缓存 不一致则认为失效)
            > (包含If-Modified-Since&If-Unmodified-Since)
            - 源头服务器认定的资源做出的修改的日期及时间 上次修改时间 如果缓存时间过期 该字段将用于 与请求中if-Modified-Since对比 一致则继续使用之前的缓存 不一致则认为缓存失效 精度比Etag低
            - 包含 if-Modified-Since if-Unmodified-Since 首部的条件请求会使用这个字段
            > HTTP服务中静态文件的Last-Modified根据什么生成
            - 一般会选文件的mtime 表示文件内容的修改时间
            - ngin也是同样处理
            > 文件系统中mtime和ctime指什么 有何不同
            - linux中
            - mtime modified time 文件内容改变的时间戳
            - ctime change time 文件属性改变的时间戳 属性包括mtime 在windows上 它表示的是creation time
            - 所以ctime会比mtime大一些
            - http服务选择Last_Modified时一般会选择mtime

            > Etag(服务端的一个资源的标识)
            - 查询服务器端资源是否更新 优先对比Etag 
            - Etag对应If-None-Match 再用对比Last-ModifiedLast-Modified对应If-Modified-Since
            - Entity缩写 可理解为被请求变量的实体值 是服务器的一个资源标识 在HTTP响应头中将其传送给客户端 服务器端资源可以是一个Web页面 JSON/XML 服务器单独负责判断记号是什么及其含义 并在HTTP响应头中将其传送到客户端 HTTP响应头是资源的特定版本的标识符
            > 如果HTTP响应头中Etag值改变 是否意味着文件内容一定已经更改
            - 不一定 由服务器中Etag的生成算法决定
            - 比如nginx中的Etag由last_modified与content_length组成 而last_modified又由mtime组成
            - 当编辑文件却未更改文件内容时 mtime也会改变 此时etag改变但是文件内容没有更改
            > Etag原理
            1. 当浏览器请求服务器的某项资源(A)时 服务器根据A算出一个哈希值 并通过Etag返回给浏览器 
            - 浏览器把hash值和A同时缓存在本地 当下次再次向服务器请求A时 会通过类似If-None-Match:""的请求头把ETag发送给服务器 
            - 服务器再次计算A的哈希值并和浏览器发送的值做比较 如果发现A发生了变化 就把A返回给浏览器200 如果A没有变化 就给浏览器返回一个304协商缓存命中 通过控制浏览器端的缓存 节省服务器的带宽
            2. 首部字段Etag能告知客户端实体标识 
            - 它是一种可将资源以字符串形式作为唯一标识的方式 服务器会为每份资源分配对应的Etag值 当资源更新时 Etag的值也需要更新 
            - 生成Etag时没有统一的算法规则 仅仅是有服务器来分配
            - 分布式系统尽量关闭Etag 因为每台机器生成的Etag都不一样 分布式系统多台服务器间文件的If-Modified-Since必须一致 避免负载均衡不同导致对比失败
            > 资源的内容标识(不唯一 通常为文件的md5或者一段hash值 只要保证写入和验证时的方法一致即可)
            - If-None-Match：客户端保留的资源内容标识
            > 为什么即有last-modifeid又有Etag
            1. 一些文件也许会周期性更改 但他的内容并不改变(仅仅改变了修改时间)此时并不希望客户端认为这个文件被修改了 而重新get
            2. 某些文件修改非常频繁 如在秒以下的事件内进行修改(比如说1s修改了N次) if-Modified-Since能检查到的粒度是s级的 这种修改无法判断
            3. 某些服务器不能精确得到的文件的最后修改时间
            - 所以Etag可以更准确的控制缓存
            > 注意:
            1. 分布式系统尽量关闭Etag 因为每台机器生成的Etag都不一样
            2. 分布式系统里多台机器间文件的Last-Modified必须一致 避免负荷均衡不同导致对比失败
            3. 通常情况下 如果同时发送if-None-Match If-Modified-Since字段 服务器只要比较Etage的内容即可 当然具体的处理方式 看服务器的约定规则
        3. 缓存流程中三个问题
            1. 缓存是否过期
                > 基于该资源上次响应缓存规则 同时满足下列条件 则视为缓存未过期 
                - 判断缓存是否过期只跟客户端相关 与服务端无关 
                - 1&2&3同时满足即认为缓存未过期 相反过期
                1. cache-control值为max-age
                2. max-age>0
                3. 当前data<上次请求时date+max-age
                > PS:expire可同等转化为cache-control=max-age形式 s-maxage与maxage规则相同
            2. 询问服务器资源是否修改
                >(Etag对应If-None-Match优先对比 Last-Modified对应If-Modified-Since) 
                - 判断资源是否修改 需要客户端与服务器共同协作 
                - 客户端在首次拿到资源缓存后会存储Etag(若有)和Last-Modified(若有) 
                - 在下次缓存过期时 会将Etag写在请求头部中的If-None-Match中
                - 将Last-Modified值写在请求头部中的If-Modified-Since中 
                - 服务端优先对Etag进行对比 一致情况下才会继续对比Last-Modified 
                - 完全通过后即视为缓存没有修改 决定返回304 
                - 告诉浏览器资源未更新 可以使用本地缓存 有一项不通过则认为资源已被修改 缓存失效
            3. 缓存规则
                > 缓存规则主要由cache-control字段和expires字段体现 同时出现则以cache-control为准
            > 总结:
            - 对于HTTP缓存的配置 始终要做到两点
            1. 清楚明白HTTP缓存的原理与规则
            2. 明确缓存的配置不是一次性的
        > 强缓存和协商缓存
        1. 浏览器进行资源请求时 回判断response headers是否命中强缓存 如果命中 直接从本地读取缓存 不会向服务器发送请求
        2. 当强缓存没有命中时 会发送请求到服务端 判断协商缓存是否命中 如果命中 服务器将请求返回 不会返回资源 告诉浏览器从本地读取缓存 如果不命中 服务器直接返回资源
        - 强缓存(Expires Cache-Control)命中不会请求服务器 直接请求缓存 
        - 协商缓存命中(Last-Modified If-Modified-Since ETag If-None-Match) 一旦会发请求到服务器 通过资源的请求首部字段验证资源是否命中协商缓存 如果协商缓存命中 服务器会将这个请求返回 但是不会返回这个资源的实体 而是通知客户端可以从缓存中加载这个资源(304 not modified)
    
    > 浏览器缓存    
    - 浏览器将用户请求过的静态资源html、css、js 存储到电脑本地磁盘中
    - 浏览器再次访问时 可以直接从本地加载了 不需再去服务端请求
    
    > 浏览器打开一个页面前端缓存 一般针对如CSS JS image等静态资源
    > 缓存缺点
    - 如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。
    > 缓存的优点：
    1. 减少了冗余的数据传输，节省网费
    2. 减少服务器的负担，提升网站性能
    3. 加快了客户端加载网页的速度
    
    > CDN缓存(Content Delivery Network)内容分发网络 服务器端缓存
    - (缓解源站压力 优化不同用户的访问速度和体验)
        - CDN缓存是一种服务端缓存 
        - CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上 当用户访问相应的业务资源时 用户会被调度至最接近的节点 最近的节点ip返回给用户 
        - web性能优化中 它主要起到了 缓解源站压力 优化不同用户的访问速度和体验的作用
        - 缓存规则：(由CDN服务商制定) 与HTTP缓存不同的是 这个规则不是规范性的 而是有CDN服务商来制定
        - 关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的
        - Cache-control: max-age 
        - 字段来设置CDN边缘节点数据缓存时间。当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端
        - 否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。
    > CDN优势:
    1. CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。
    2. 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。
    > 总结：
    - CDN缓存的配置并不复杂 复杂的情况在于CDN缓存配置会受到HTTP缓存配置的影响 并且不同的CDN运营商对于这种影响的处理也都不一致 实际使用时 建议去对应的CDN服务商文档中找到对应的注意事项
    > HTTP缓存和CDN缓存结合  
    - HTTP缓存和CDN缓存分别作为客户端缓存和服务端缓存共同影响着我们的web请求流向 想做好缓存配置 首先清楚缓存的原理和配置规则 其实是结合项目分析缓存级别 具体情况具体处理
7. DNS缓存
    > DNS缓存
    1. 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。
    2. 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。
    3. 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。
    4. 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。
8. 前端清除缓存几种方法
    1. meta标签清理缓存/
    2. 随机数 随机时间/
    3. Jquery AJAX清除浏览器缓存/
    4. php后端处理)
    
    1. meta标签清理缓存 
        <meta http-equiv="Pragma" content="no-cache">
        - 用于设定禁止浏览器从本地机的缓存中调阅页面内容
        有时谷歌等浏览器不支持
        <meta http-equiv="Cache-Control" content="no-cache">
        - Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程
        <meta http-equiv="Expires" content="0">
        - 可以用于设定网页的到期时间
    2. jquery ajax清除浏览器缓存
        1. 用AJAX请求服务器最新文件 并加上请求头if-Modified-Since和Cache-Control
        2. 直接用cache:false
    3. 随机数
        url参数后面加上"?ran="+Math.random()
    4. 随机时间 和随机数一样
        url参数后面加上"?timestamp="+new Date().getTime();
    5. php后端处理
        在url参数后加上 在服务器端加
        header("Cache-Control:no-cache,must-revalidate")
9. 前端优化网站性能/前端浏览器性能优化
    > 页面流畅的定义
    1. 大多数设备的屏幕刷新率为60次/秒
    2. 每帧的预算事件为16.66毫秒(1000/60 = 16.66毫秒)
    3. 页面滑动过程中 浏览器渲染页面的每一帧速率如果和设备屏幕刷新率保持一致 则滑动顺畅 如无法符合此预算 帧率将下降 并且内容会在屏幕上抖动

    > 雅虎军规
    - 页面请求相关
    1. Server 
    2. Cookie
    3. Mobile
    - 页面渲染相关
    4. Content
    5. Image
    6. CSS

    > 性能指标 用户体验
    1. FCP 首屏加载时间
    2. LCP 最大文本块内容或图片显示在页面中的时间
    3. FID 首次与网站进行交互到浏览器真正响应的时间
    
    1. 减少 HTTP 请求数量 CSS Sprites 采用 lazyLoad
    2. 利用浏览器缓存 
    3. 控制资源文件加载优先级 浏览器加载HTML内容时 将HTML内容从上至下依次解析 解析到link/script标签会加载href/src对应链接内容 为第一时间展示页面给用户 需要将CSS提前加载 不要受JS加载影响 一般情况下都是CSS在头部 JS在尾部
    4. 减少DOM操作 减少重排（Reflow）避免重排
    5. 尽量外链CSS和JS(结构/表现/行为分离)
    6. 图标由字体图标改成图片图标
10. 前端首屏优化
    1. CDN分发 减少传输距离/
    2. 后端在业务层的缓存/
    3. 静态文件缓存方案/
    4. 前端资源动态加载/
    5. 减少请求数量/
    6. 页面使用骨架屏/
    7. 使用SSR渲染/
    8. 引入HTTP2.0/
    9. 利用好HTTP压缩/
    10. 利用好script标签的defer和async两个属性)
    
    1. CDN分发(减少传输距离)
        > 在多台服务器部署相同的副本 用户访问时 服务器根据用户与那台服务器距离近 决定那台服务器去响应这个请求
    2. 后端在业务层的缓存(数据库查询可设置缓存)
        > 数据库查询缓存可设置缓存 此对处于高频率的请求很有用 浏览器一般不会对content-type:application/json; 的接口进行缓存 所以有时需要手动为接口设置缓存 比如一个用户的签到状态 它的缓存时间可以设置到明天之前
    3. 静态文件缓存方案
        > 最常看到 最流行的方式是hash+强缓存方案 如hash+cache control:max-age=1年
    4. 前端资源动态加载
        1. 路由动态加载 最常用的方法 以页面为单位 进行动态加载
        2. 组件动态加载 对于不在当前视窗的组件 先不加载
        3. 图片懒加载 同上 越来越多的浏览器支持原生的懒加载 通过给img标签加上loading='lazy'来开启懒加载模式
    5. 减少请求的数量
        > 该点在HTTP1.1优势很明显 因为HTTP1.1的请求是串行的 (尽管有多个TCP通道) 每个请求都需要往返后才能继续下个请求
        此时合并请求可以减少在路途上浪费的时间 此外还会带来重复的请求头部信息(比如cookie)
        > HTTP2.0 新的二进制格式 多路复用 header压缩 服务器端推送 中该问题会弱化很多 但是也有做的必要
    6. 页面使用骨架屏 
        > 即为在首屏加载完成之前 通过渲染一些简单元素进行占位 骨架屏好处在于可以减少用户的等待时的急躁情绪  这点很有效 在很多成熟的网站(京东 淘宝 Youtube)都有大量应用 没有骨架屏的话 一个loadingdd的菊花图也是可以的
    7. 使用SSR渲染
    8. 引入HTTP2.0 HTTP2.0相对于HTTP1.1 最主要提升是传输性能 在接口小而多时会更加明显
    9. 利用好HTTP压缩
        > 即使是最普通的gzip 也能把bootstrap.min.css压缩到原来的17% 压缩的效果非常明显 特别是对文本类的静态资源 
        > 此外 接口也是能压缩的 接口不大不用压缩 因为性价比低(考虑压缩和解压时间)
    10. 利用好script标签的async和defer这两个属性
        > 功能独立且不要求马上执行的JS文件 可以加入async属性
        > 优先级低且没有依赖的JS 可以加入defer属性
11. 浏览器内核
    > 浏览器内核
    - (浏览器内核不同 对网页的语法解释不同 渲染效果不同)
    - (所有网页浏览器 电子邮件客户端及其他需要编辑 显示网络内容的应用程序都需内核)
    - 渲染引擎Layout Engineer/Rendering Engine
        取得网页的内容(HTML/XML/图像等)
        整理讯息(如加入CSS)
        计算网页显示方式
        输出至显示器/打印机
    > JS引擎
    - 解析执行JS实现网页动态效果
    
    > 常见的浏览器内核
    - Trident:IE 360 搜狗
    - Gecko:FireFox Netscape6及以上版本
    - Presto:Opera
    - Blink:Opera Google
    - Webkit:Safari Chrome
    
    > 浏览器内核引擎
    1. Trident:IE以Trident作为内核引擎 微软开发 Netscape 世界之窗
    2. Gecko:Firefox是基于Gecko开发的 c++编写 Netscpae6至9
    3. Webkit:Safari,Google Chrome,Opera,百度
    4. Presto:Opera的内核 但由于市场选择问题 主要应用在手机平台 Opera mini
    - PS:2013年2月Opera宣布转向Webkit引擎
    - PS:2013年4月Opera宣布放弃Webkit 跟对Google 新开发的blink引擎

    - 最开始渲染引擎和JS引擎没有区分很明确 后来JS引擎越来越独立 内核就倾向于只指渲染引擎

    - -webkit- 针对safari chrome浏览器的内核css写法
    - -moz- 针对firefox浏览器的内核css写法
    - -ms- 针对IE内核的css写法
    - -o- 针对Opera内核的css写法
12. 如何避免页面上商品价格被爬取到
    1. 价格信息AJAX获取
    2. 价格设置图片
    3. JS对价格加密再解密
    4. 字体加密 如#xf076对应100
13. 前端常用的几种弹窗函数
    - (alert/confirm/prompt/HTML+CSS+JS)
    1. alert('')弹窗 提示
        - 主要作为提示 一般经常用来测试JS某段代码是否出错
    2. confirm('')弹窗 判断是否进行某一个操作
        - 点击确定 返回true
        - 点击取消 返回false
        - 点击确定/取消按钮关闭前 将阻止用户对浏览器的所有输入       
    3. prompt('')弹窗 用于输入文本内容 
        - 用于显示可提示用户进行输入的对话框
        - 用户单击取消按钮 返回null
        - 单击确认按钮 返回输入的文本
        - 点击确定或取消关闭之前
        - 它将阻止用户对浏览器的所有输入
        - 调用prompt()时 用户做出响应之前 不会执行下一条语句
    4. HTML+CSS+JS实现浏览器弹窗
        - click控制div.style.display为block/none        
14. 前端文件上传功能
    > (form表单/原生JS+AJAX/Jquery+AJAX/formdata+iframe)
    > Web浏览器上传文件一般有以下几种方式
    1. form表单上传文件
        > 会整个刷新页面 浏览器支持 不使用JS也可以实现
    2. 原生js实现ajax上传文件
        > 基于JS实现 通过formdata对象实现 formdata对象在老版本浏览器中不支持 不会刷新整个页面
    3. jquery实现ajax上传文件
        > 基于JS实现 formdata对象在老版本浏览器中不支持 不会刷新整个页面
    4. form+iframe上传文件
        > 使用iframe方式提交 兼容老版本浏览器
15. Web标准及W3C理解认识
    > Web标准简单来说可以分为
    - 结构：主要由HTML标签组成
    - 表现：CSS样式表
    - 行为: 页面和用户交互
    > Web标准一般将该三部分独立分开 使其更具有模块化
    > 一般产生行为时 会有结构或表现的变化 使该三者界限不够清晰
    > W3C对Web标准提出规范化要求 即实际编码中一些代码规范
    1. 结构要求
        (标签规范可以提高搜索引擎对页面的抓取效率 对SEO较有帮助)
        1. 标签字母小写
        2. 标签闭合
        3. 标签不允许随意嵌套
    2. CSS/JS
        1. 尽量使用外链CSS样式表和JS脚本 使结构表现行为分三块 符合规范 同时提高页面渲染速度 提高用户体验
        2. 样式尽量少使用行内样式 使结构和表现分离 标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版
        3. 不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。
16. 负载均衡(流量分发 提高性能和可用性 消除单点障碍)
    > 高可用架构的一个关键组件 主要用来提高性能和可用性 通过负载均衡将流量分发到多个服务器 同时多个服务器能够消除这部分的单点故障
    - 当然负载均衡器本身就是一个单点故障隐患 可考虑负载均衡双机热备或其他方案消除单点故障提高可用性
    > 负载均衡可以处理的流量类型
    - (HTTP HTTPS流量 TCP/UDP流量 数据库集群访问 DNS)
    1. 一般接触到的负载均衡可能大多是处理HTTP HTTPS流量
    2. 实际上负载均衡还可以处理TCP/UDP流量
    3. 如对数据库集群的访问 DNS等
    > 负载均衡算法(确定流量应该被分发到哪一个健康的服务器上)
    - 用途：用于确定流量应该被分发到哪一个健康的服务器上
    - 常见的几个：(轮转/最少连接/IP hash)
    1. Round Robin 轮转
    - 服务器按顺序选择 比较适合各服务器处理能力相同且每个业务处理量差不多的时候  
    2. Least Connections 最少连接
    - 负载均衡器会选择当前连接最少的服务器
    3. IP hash
    - 负载均衡器根据请求源的IP决定分发给哪个服务器 该方法保证一个特定用户会一直访问相同的服务器
    4. Url Hash Random等
    > 健康检测 health checks
    - 负载均衡算法有一个前提 流量只会被分配到健康的服务器上 
    - 一般会通过配置的协议和端口尝试连接服务器保证服务器正在监听 
    - 如果一个服务器的健康检查失败 即服务器无法正常响应请求 那么就会被自动移除池子中 流量也不会被分配到这个坏掉的服务器 直到它能通过健康检查
    > 负载均衡如何处理状态
    - 基于session的用户认证会在服务器存有session的一些信息 但当系统引入负载均衡时会出现一些问题 在服务器集群下 不能轻易做到状态共享
    - 解决方法(IP hash/sticky session)
    1. IP hash算法
        - 该算法根据IP来分配流量对应的服务器 所以可以保证同一个用户的流量会访问到同一个服务器 
    2. sticky session 粘性会话
        - 负载均衡器会设置一个cookie 然后带有这个cookie的session都会被分配到同一个服务器上
    > 负载均衡双机热备 Hot standby
    - 负载均衡器本身就是一个单点故障隐患 其中一个解决方案 双机热备(提高可用性的一大基本方法就是冗余)
    - 双机热备方案为了解决负载均衡器的单点故障问题 引入第二个负载均衡器 主节点故障则切换到备用节点
    > CDN和负载均衡
    1. CDN
    - 全称是Content Delivery NetWork 内容分发网络
    - 是构建在现有网络基础之上的智能虚拟网络 依靠部署在各地的边缘服务器 通过中心平台的负载均衡 内容分发 调度等功能模块 使用户就近获取所需内容 降低网络阻塞 提高用户访问响应速度和命中率 CDN关键技术主要有内容存储和分发技术
    > CDN是一个经策略性部署的整体系统 包括分布式存储 负载均衡 网络请求的重定向 内容管理四个要件 内容管理和网络流量管理是CDN核心所在
    > CDN最重要的功能就是对于静态文件响应速度快 减轻用户对源服务器访问的负载量 提高用户体验 其中关键技术为内容存储和分发技术
    2. 负载均衡
    - 全程Load Balance 
    - 含义是将负载进行平衡 分摊到多个操作单元上进行运行 如FTP服务器 Web服务器 企业核心应用服务器和其他主要任务服务器 从而协同完成工作任务
    - 负载均衡构建在原有网络结构之上 它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽 加强网络数据处理能力 增加吞吐量 提高网络的可用性和灵活性
    > 将访问流量根据转发策略分发到后端多台云服务器(ESC实例)的流量分发控制服务 负载均衡扩展了应用的服务能力 增强了应用的可用性
    > 负载均衡最重要的功能就是策略分发机制 解决了用户高并发访问的拥堵问题
17. SEO/前端SEO优化
    - (蜘蛛是否能看懂/网页内容是否能被搜索引擎识别
    - 网页内容可以被搜索引擎识别 搜索引擎会提高该网站的权重
    - 增加对该网站的友好度 --SEO)
    - (白帽SEO/黑帽SEO)
    - (提高网站权重/增强搜索引擎友好度)
    > (网站结构布局尽量扁平化/网页代码优化/前端性能优化)
    1. 搜索引擎工作原理
    > (搜索引擎后台有一个非常庞大的数据库 存储海量关键字 每个关键字对应很多网址 搜索引擎蜘蛛/网络爬虫 爬取而来 一个关键字对应多个网址 即出现排序问题 搜索引擎是否理解该关键字 网站内容是Flash和JS 它无法理解 如网站内容能被搜索引擎识别 搜索引擎提高该网站权重 增加对该网站友好度 此过程即为搜索引擎优化 SEO)
    2. SEO(Search Engine Optimization)/搜索引擎优化 简介
    - SEO与搜索引擎
        > 相互促进 互利共生
    - SEO的存在
        > 为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。
        > 优化的目的为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。
    - 分类：
        - 白帽SEO
        > 起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。
        > 作用:
        1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；
        2. 网站内容优化：内容与关键字的对应，增加关键字的密度；
        3. 在网站上合理设置Robot.txt文件；
        4. 生成针对搜索引擎友好的网站地图；
        5. 增加外部链接，到各个网站上宣传。
        - 黑帽SEO
        > 利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎 一般搜索引擎公司不支持鼓励
    3. 为什么要做SEO(提高网络权重/增强搜索引擎友好度)
        1. 提高网站的权重，
        2. 增强搜索引擎友好度，以达到提高排名，
        3. 增加流量，改善（潜在）用户体验，促进销售的作用。
    4. 前端SEO规范
        > 前端是构建网站中很重要的一个环节，前端的工作主要是负责页面的HTML+CSS+JS，优化好这几个方面会为SEO工作打好一个坚实的基础。通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂（提升用户体验），也能让“蜘蛛”看懂（提高搜索引擎友好度）。
        1. 网站结构布局优化 尽量简单 开门见山 提倡扁平化结构
            1. 控制首页链接数量
            2. 扁平化的目录层次
            3. 导航优化
            4. 网站的结构布局
            5. 利用布局 把重要内容HTML代码放在前面
            6. 控制页面大小 减少HTTP请求 提供网站加载速度
        2. 网页代码优化
            1. 突出重要内容
            2. 语义化书写HTML代码 符合W3C标准 合理使用各种H5标签
            3. a标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el="nofollow" 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。
            4. 正文标题要用h1标签：h1标签自带权重“蜘蛛” 认为它最重要，一个页面有且最多只能有一个H1标签，放在该页面最重要的标题上面，如首页的logo上可以加H1标签。副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签。
            5. img应使用 "alt" 属性加以说明
            当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。同时为图片设置高度和宽度，可提高页面的加载速度。
            6. 表格应该使用caption表格标题标签
            caption 元素定义表格标题。caption 标签必须紧随 table 标签之后，您只能对每个表格定义一
            7. br标签：只用于文本内容的换行
        3. 前端网站性能优化
            1. 减少HTTP请求
            2. 控制资源文件加载优先级
            3. 尽量外链CSS和JS（结构、表现和行为的分离）保证网页代码的整洁，也有利于日后维护
            4. 利用浏览器缓存
            5. 减少重排（Reflow）
            6. 减少 DOM 操作
            7. 图标使用IconFont替换
            8. 不使用CSS表达式，会影响效率
            9. 使用CDN网络缓存，加快用户访问速度，减轻服务器压力
            10. 启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大
            11. 伪静态设置
18. 浏览器中执行一段JS代码时做了什么
    - JS引擎的内里
    - (JS引擎 JS解释器 V8引擎 Chrome和NodeJS使用引擎 C++辨析)
    - JS引擎 JS解释器 V8是JS最受欢迎的引擎之一  也是Chrome和NodeJS使用的引擎 是用C++编写的
    > JS引擎工作流程
    > (AST Compiler/interpreter Parser解析器/Profiler分析器)
    1. Parser 解析器
    2. AST 抽象语法树
    3. interpreter生成ByteCode 翻译程序生成字节码
    4. Profiler 分析器
    5. Compiler生成优化后的代码
    -  Parser -> AST -> 通过Interpreter/Compiler/JIT生成ByteCode|Profiler查找可优化的代码传递给Compiler
    - Interpreter和Compiler
        > 通常将代码转换为机器可读语言有两种方法
        - Interpreter-解释器 逐行读取代码并立即执行 可以立即开始执行代码 但不会进行优化
        - Compiler-编译器 读取你的整个代码 进行一些优化 生成优化后的代码 虽然需要花费一些时间编译代码 但是会生成对执行时更优的代码
    - JIT(Just In Time) 即时编译 Interpreter Compiler 结合
        > Interpreter和Compiler结合 现在大多数浏览器都在更快 更高效地实现此功能 V8引擎也使用此功能
    - Parser 解析器(可以通过各种JS关键字来识别 区分代码是一个方法还是一个变量)
        > 一种通过各种JS关键字来识别 分析和分类程序各个部分的解析器 
        > 它可以区分代码是一个方法还是一个变量
    - AST 抽象语法树   
        > 基于Parser的分类构造树状结构
        > 可以使用AST Explorer查看该树的结构
        > 词法分析 语法分析
    - ByteCode 字节码
        > 随后将AST提供给Interpreter生成ByteCode
        > Byte不是最底层的代码 但可以执行
        > 此阶段 浏览器借助V8引擎执行ByteCode1进行工作 因此用户无需等待
    - Profiler 分析器(查找可优化的代码)
        > 同时Profier将查找可以被优化的代码 然后将它们传递给Compiler 
        > Compiler生成优化代码的同时 浏览器暂时用ByteCode执行操作 
        > 一旦Comiler生成优化代码 优化代码将完全替换到临时的ByteCode
        > 通过这种方式 可以充分利用Interpreter和Compiler的优点
        - Interpreter执行代码的同时 Profiler寻找被优化的代码 Compiler创建优化的代码 然后将ByteCode码替换成优化后较为底层的代码 例如机器代码
        - 意味着性能将在逐渐提高 同时不会有阻塞执行的时间
    - ByteCode
        > 作为机器代码 ByteCode不能被所有所有计算机理解及执行 它仍然需要像虚拟机或JS V8引擎这样的中间件才能将其转换为机器可读的语言 
        > 这就是为什么我们的浏览可以在上述5个阶段中 借助JS引擎在Interprter中执行ByteCode的原因
    - JS是一门解释型的语言吗(取决于引擎如何实现)
        > JavaScript 是但不完全是一门解释型语言
        > Brendan Eich 最初是在 JavaScript 的早期阶段创建 JavaScript 引擎 “ SpiderMonkey” 的。
        > 该引擎有一个 Interpreter 来告诉浏览器该怎么执行代码。但是现在我们的引擎不仅包括了 Interpreter，还有 Compiler。
        > 我们的代码不仅可以被转换成 ByteCode，还可以被编译输出优化后的代码。因此，从技术上讲，这完全取决于引擎是如何实现的。
    > V8执行一段JS代码过程
    - 站在V8的角度 理解其中的执行机制 能够帮助我们理解很多上层应用 包括Babel Eslint 前端框架的底层机制 
    - JS属于解释型的语言 对解释型语言 解释器会对源代码做如下分析
        1. 通过Parser词法分析和语法分析生成AST
        2. 生成字节码ByteCode
        3. 然后解释器根据字节码执行程序 Profiler寻找优化 传递给Compiler生成优化代码
        
        1. 生成AST
            > 分为两步 
            1. 词法分析(分词 代码分解为token)
                > 分词 将一行行代码分解成一个个token let name = 'sanyuan'; 关键字 变量名 赋值 字符串 解析成四个token
            2. 语法分析(将生成的token数据 按一定语法规则转化为AST)
                > 将生成的这些token数据 根据一定语法规则转化为AST
                > 生成AST后 编译器/解释器后续的工作都要依赖AST而不是源代码
                > babel的工作原理就是将
                1. ES6的代码解析成生成ES6的AST 
                2. 然后将ES6的AST 转换为ES5的AST 
                3. 最后才将ES5的AST转化为具体的ES5代码
                4. 生成AST后 接下来会生成执行上下文
        1. ES6代码解析生成->ES6 AST 
        2. ES6 AST 转换为-> ES5 AST
        3. ES5 AST 转化为-> 具体的ES5代码
        2. 生成字节码ByteCode
            > 字节码 介于AST和机器码之间的一段代码 但是与特定类型的机器码无关 字节码需要通过解释器将其转换为机器码然后执行
            - 生成AST后 直接通过V8解释器生成字节码
                > 字节码并不能让机器直接运行 (直接转成机器码 体积太大 会引发严重的内存占用问题) 字节码是比机器码轻量得多的代码
                - 字节码仍然需要转换为机器码 但是与原来不同的是 现在不用一次性将全部字节码都转换为机器码 
                - 通过解释器逐行解释字节码 省区生成二进制文件操作 大大降低了内存压力
        3. 执行代码
            > 字节码解释执行的阶段 在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做热点代码(HotSpot)，
            > 然后将这些代码编译成机器码保存起来，这个用来编译的工具就是V8的编译器(也叫做TurboFan) 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高 因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码

            > 其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。
            > 编译器和解释器根本区别在于前者会编译生成二进制文件但后者不会。
            > 这种字节码跟编译器和解释器结合的技术，我们称之为即时编译（JIT）
        > 概括 V8中执行一段JS代码的整个过程
        1. 通过词法分析和语法分析生成AST
        2. 将AST转换为字节码
        3. 由解释器逐行执行字节码 遇到热点代码启动编译器进行编译 生成对应的机器码 以优化执行
19. 关键渲染路径
    - (优化关键渲染路径 优先显示与当前用户操作有关的内容)
    > 性能优化
    - 从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么，即关键渲染路径。
    - 优化关键渲染路径 优先显示与当前用户操作有关的内容。 
    > 通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间。 此外，了解关键渲染路径还可以为构建高性能交互式应用打下基础。
    - 优化关键渲染路径
    - 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。
    > 描述关键渲染路径的词汇
    - 关键资源： 可能阻止网页首次渲染的资源。
    - 关键路径长度： 获取所有关键资源所需的往返次数或总时间。
    -  关键字节： 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。 我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。
20. 移动端300ms延迟
    > 原因:
    > 300ms 延迟的由来,是当初07年初苹果发布首款iPhone之前,苹果工程师提出的一个为了优化交互体验的操作.因为当时的网站基本都是为PC等大屏幕设备而写的,而现在需要用小屏幕浏览桌面端网站.当用户用手指把页面放大以后,就有了一个双击缩放(double tap to zoom)的交互.
    > 即在iOS自带的Safari浏览器中快速双击会将网页缩放到原始比例.因此在此浏览器中 用户会有单击或者双击的需求行为 浏览器并不能立刻判断用户是想要单击还是双击 Safari就等待了300ms.看看用户到底想干嘛.鉴于苹果公司这个操作的成功,后续其他的浏览器也因此借鉴了这种行为 
    > 300ms也因此成为了大多数浏览器的一个约定.在当初移动端兴起的时候,300ms是可以让人接受的,但是随着用户对交互体验的要求越来越高,300ms就成为了用户无法忍受的一个点了.
    >解决延迟:
    - (禁用缩放/更改默认的视图高度/css touch-action不触发默认行为)
    1. 禁用缩放
    2. 更改默认的视图宽度
    3. css touch-action 不触发默认行为
    4. 引用FastClick库 模拟click 阻止默认click
        1. 禁用缩放(在meta标签中设置)Chrom和Firefox支持 Safari比较麻烦它有双击缩放和双击滚动等操作
        <meta name="viewport" content="user-scalable=no,initial-scale=1,maximun-scale=1"/>
        > 页面不可缩放 双击缩放功能没有意义 此时浏览器可以禁用默认的双击缩放行为并去掉300ms的点击延迟
        > 缺点:必须完全禁用缩放来达到目的 但是通常情况下 还是希望能通过双指来进行缩放
        2. 更改默认的视口宽度(在meta标签中设置) Chrome和Firefox支持 Safari比较麻烦 它还有双击缩放和双击滚动操作
            <meta name="viewport" content="width=device-width"/>
            如果能识别出一个网站是响应式的网站 那么移动端浏览器就可以自动禁止双击缩放行为 并去掉300ms的点击延迟
            设置上述的meta标签 则浏览器就可以认为网站已经对移动端做过适配优化
        好处:没有完全禁用缩放 而是禁用浏览器默认的双击缩放行为 但用户仍然可以通过双指缩放操作缩放页面
        3. css touch-action IE支持
            touch-action:指定相应的元素上能触发的用户代理(浏览器)的默认行为
            将该属性值设置为touch-action:none 表示该元素上操作不会触发用户代理的任何默认行为 就无需进行300ms的延迟判断了
        4. FastClick专门为解决移动端浏览器300ms点击延迟问题开发的一个轻量级的库 
            原理:在检测到touchend事件时 会用过DOM自定义事件立即发出模拟一个click事件 并把300ms之后发出的click事件阻止掉
            缺点:脚本相对较大 且有时可能会有bug
21. 移动端点击击穿
    > 概念:
    - 页面俩元素A和B,B在A的上面.在B的上面注册了touchstart事件,回调函数中是让B元素隐藏.
    - 当我们点击B元素的时候,除了B被隐藏外,A的click事件也被触发了.这是因为在移动端浏览器中,事件执行顺序是 touchstart => touchmove =>  touchend => click .click是有300ms的延迟.
    - 当B的touchstart事件触发后,B被隐藏了,300ms之后,浏览器触发了click事件,此时的事件已经被派发到了A元素身上.
    > 事件执行顺序 触摸事件 -> 点击事件
    > 移动端的事件是touch事件 也叫触摸事件 因为是用手指触摸的 当然 点击事件还是存在的
    > 移动端浏览器中
    > 事件执行顺序touchstart=>touchmove=>touched=>click
    - touchstart事件:手指触摸屏幕时触发
    - touchmove事件:手指在屏幕上滑动时触发
    - touchend事件:手指离开屏幕时触发
    > click事件是在最后执行的
    > 一般情况下click是在手指放到屏幕上,并且没有移动过,然后离开,且这个开始触摸到手指离开屏幕的时间较短才能触发
    > 若手指移动了,则不会触发click事件了(看到有的地方说某些浏览器会允许有一个很小的移动值,具体的情况不太清楚).
    > 正确触发顺序是下面两个中一个
    - touchstart=>touchmove=>touchend
    - touchstart=>touchend=>click
        > touchmove可能不会触发 也可能触发很多次 若触发了touchmove 则click就不会触发
        > 和click等事件一样 touch事件也是有事件对象的
        > touchstart和touchmove通过event.touched来获取手指信息
        > (如触摸的点的位置等信息)
    touchend不能通过event.touched获取
    因为此时手指已经离开了 但是可以通过event.changeTouces获取手指信息
    > 解决点击穿透
    1. 元素阻挡
    2. 阻止默认事件
    3. pointer-events
    4. fastclick库

    1. 元素阻挡
        新增一个看不见的元素阻止事件穿透.解决思路基本就是在触发事件的位置动态生成一个新的透明元素,
        这样当300ms之后的click事件来临时,点到的就是这个透明元素,然后再把这个元素删除即可.
        缺点就是写法麻烦,而且有时候用户快速点击的时候,下面元素的事件有可能不会触发,因为此时的透明元素还没有被定时器清理掉.
        弄一个隐藏动画,时间大于300ms,在延迟之后的点击事件来临时,上面的元素还没有消失,这样就不会点到下面的元素了.
    2. 阻止默认事件
        event.preventDefault()
    3. pointer-events
        这是CSS3中的一个属性 其中用的比较多的属性值有auto和none 其他属性基本都是为SVG服务的
    4. fastclick库
        引入fastclick库
22. 微信扫描二维码登陆的实现原理
    > UUID Universally Unique Identifier:通用唯一标识码
    > 二维码
        > 又称二维条码 常见的二维码为QR Code QR全称为Quick Response 是一个近几年在移动设备上很流行的一种编码方式 它比传统的Bar Code条形码能存更多信息 也能表示更多数据类型
    > 移动端基于token的认证机制 
        登陆时 传入账号 密码 手机的设备信息 在服务端验证账号 密码正确后 服务端会做两件事
    1. 将账号与设备关联起来 某种意义上 设备信息就代表着账号
    2. 生成一个token令牌 并将token与账号 设备关联 类似key/value token作为key 账号设备信息作为value 持久化在磁盘上
    - 将 token 返回给移动端，移动端将 token 存入在本地，往后移动端都通过 token 访问服务端 API ，当然除了 token 之外，还需要携带设备信息，因为 token 可能会被劫持。带上设备信息之后，就算 token 被劫持也没有关系，因为设备信息是唯一的。
    > 二维码扫描登陆的原理
    > 扫码登录可分为三个阶段
    > (待扫描/已扫描待确认/已确认)
    1. 待扫描(PC端与服务端交互)
        > 二维码生成阶段 这个计算和移动端没有关系 是PC端和服务端交互过程 PC端携带设备信息向服务端发起生成二维码请求
        > 服务器端会生成唯一的二维码ID 可以理解为UUID 并将二维码ID跟PC设备信息关联起来
        
        > PC端接收到二维码ID后 将二维码ID以二维码形式展示 等待移动端扫码 
        > 此时PC端会开启一个定时器 轮询查询二维码状态 如果移动端未扫描 则一段时间后 二维码失效
    2. 已扫描待确认(移动端与服务端交互)
        > PC端登录微信时 手机扫码后 PC端的二维码会变成已扫码 请在手机端确认 这个阶段是移动端跟服务端交互的过程
        - 首先移动端扫描二维码 获取二维码ID 然后将手机端登录的信息凭证(token)和二维码ID作为参数发送给服务端 此时手机一定是登录的 不存在没登录的情况
        - 服务端结束请求后 会将token与二维码ID关联 
        - 关联原因 使用微信时 移动端退出 PC端也需要退出 然后生成一个一次性的token 这个token会返回给移动 端 一次性token用作确认时的凭证
        - PC端的定时器 会轮循到二维码状态已经发生改变 会将PC端的二维码更新为已扫描请确认 
    3. 已确认
        - 扫码登录的最后阶段 移动端携带上一步骤中获取的临时token 确认登录 服务端校对完成后会更新二维码状态 并给PC端生成一个正式的token 后续PC端就是持有这个token访问服务端
        - PC端的定时器 轮循到二维码状态未登录状态 并且会获取到生成的token 完成登录 后续访问都基于token完成
        - 在此服务器端会和手机端一样 维护着token和二维码 PC设备信息 账号信息
    到此，二维码扫描登录原理就差不多了，二维码扫描登录在原理上不难理解，跟 OAuth2.0 有一丝的相似之处，但是实现起来可能就比较复杂。                
23. 移动端高清方案 解决图片模糊问题 1px细线问题 
    > 物理像素 设备独立像素 设备像素比
    - 在CSS中我们一般使用px作为单位 CSS样式里面的px和物理像素并不是相等的
    - CSS中的像素只是一个抽象的单位，在不同的设备或不同的环境中，CSS中的1px所代表的物理像素是不同的
    - PC端，CSS的1px一般对应着电脑屏幕的1个物理像素
    - 移动端，CSS的1px等于几个物理像素是和屏幕像素密度有关的。
    > pixel[piksl]像素
    1. 物理像素(physical pixel)
        > 物理像素又被称为设备像素、设备物理像素，它是显示器（电脑、手机屏幕）最小的物理显示单位，每个物理像素由颜色值和亮度值组成。所谓的一倍屏、二倍屏(Retina)、三倍屏，指的是设备以多少物理像素来显示一个CSS像素，也就是说，多倍屏以更多更精细的物理像素点来显示一个CSS像素点
        > 在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素（参照下文田字示意图理解）
    2. 设备独立像素(device-independent pixel)CSS像素
        > 设备独立像素又被称为CSS像素，是我们写CSS时所用的像素，它是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容
    3. 设备像素比(device pixel ratio)dpr
        > 设备像素比简称为dpr，定义了物理像素和设备独立像素的对应关系：设备像素比 ＝ 物理像素 / 设备独立像素。
        > CSS的1px等于几个物理像素，除了和屏幕像素密度dpr有关，还和用户缩放有关系。例如，当用户把页面放大一倍，那么CSS中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，CSS中1px所代表的物理像素也会减少一倍。
    4. viewport 视区
        > viewport就是设备上用来显示网页的那一块区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。
    > 明确三种不同的viewport视口
    1. visual viewport 可见视口，指屏幕宽度
        > 获取屏幕宽度(visual viewport)的尺寸：window. innerWidth/Height
    2. layout viewport 布局视口，指DOM宽度
        > 获取DOM宽度(layout viewport)的尺寸：document. documentElement. clientWidth/Height
    3. ideal viewport 理想适口，使布局视口就是可见视口即为理想适口
        > 设置理想视口ideal viewport：
        <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
        > 该meta标签的作用是让layout viewport的宽度等于visual viewport的宽度，同时不允许用户手动缩放，从而达到理想视口。
        meta[name="viewport"]里各参数的含义为：
        - width: 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”。
        - initial-scale: 设置页面的初始缩放值，为一个数字，可以带小数。
        - minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数。
        - maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数。
        > height: 设置layout viewport 的高度，这个属性对我们并不重要，很少使用。
        > user-scalable:是否允许用户进行缩放，值为“no”或“yes”。            
    > rem适配方案
    1. 用JS设置rem基准值
    2. 用密集的媒体查询设置font-size
    3. 用vw设置font-size
    
    > 图片模糊问题
    1. (多倍图片)
    2. (不同的dpr下 加载不同尺寸的图片 可用CSS媒体查询 JS条件判断)
        一个位图像素是栅格图像(如：png, jpg, gif等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。对于dpr=2的Retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，导致图片看起来比较模糊，如下图。

        对于图片模糊问题，比较好的方案就是用多倍图片(@2x)。如：一个200×300(CSS pixel)的img标签，对于dpr=2的屏幕，用400×600的图片，如此一来，位图像素点个数就是原来的4倍，在Retina屏幕下，位图像素点个数就可以跟物理像素点个数形成 1 : 1的比例，图片自然就清晰了。

        最好的解决办法是：不同的dpr下，加载不同的尺寸的图片。不管是通过CSS媒体查询，还是通过JS条件判断都是可以的。
    
    > 1px细线问题(设备独立像素和物理像素是不同的)
    > 在上文我们已经知道，CSS像素为1px宽的直线，对应的物理像素是不同的，可能是2px或者3px,而设计师想要的1px宽的直线,其实就是1物理像素宽
    1. 媒体查询根据dpr用 伪元素+transform对边框进行缩放 构建一个伪元素 border为1px 再以transform缩放到50% 
    2. 用JS根据屏幕尺寸和dpr精确地设置不同屏幕所应有的rem基准值和initial-scale缩放值 JS计算rem基准值和viewport缩放值
23. webworker
    - 是H5标准的一部分 这一规范定义了一套API 它允许一段JS程序运行在主线程之外的另一个线程中
    > 创建worker线程
    - WebWorker允许在主线程之外再创建一个worker线程 在主线程执行任务同时 worker线程也可以在后台执行它自己的任务 互不干扰
    - 把高延迟 花费大量时间的运算 分给worker线程 然后把结果返回给主线程就可以
    > 主线程
    1. 创建worker对象
    - 主线程调用new Worker()构造函数 新建一个worker线程 构造函数的参数是一个url 生成这个url的方法有两种
        1. 脚本文件
            ```
            const worker = new Worker('https://~.js')
            ```
            - worker的两个限制
            1. 分配给Worker线程运行的脚本文件必须与主线程的脚本文件同源
            2. worker不能读取本地的文件(不能打开本机的文件系统file://)它所加载的脚本必须来自网络
        2. 字符串形式
            ```
            const data = `worker线程 do something`
            //转成二进制对象
            const blob = new Blob([data]);
            // 生成url
            const url = window.URL.createObjectURL(blob);
            // 加载url
            const worker = new Worker(url);
            ```
            - 项目中 可以把worker线程的逻辑写在js文件里面 然后字符串化 export import配合webpack进行模块化管理
    > 主线程的其他API
    1. 主线程与worker线程通信
    ```
    worker.postMessage({
        hello:['hello','world']
    })
    ```
    - 它们相互之间的通信可以传递对象和数组 这样就可以根据相互之间传递的消息 进行一些操作 比如可以设置一个type属性 当值为hello时执行什么函数 当值为world时执行什么函数
    - 它们之间通信是通过拷贝的形式来传递数据的 进行传递的对象需要经过序列化 接下来在另一端还要反序列化 
        1. 不能传递不能被序列化的数据 比如函数 回抛出错误
        2. 在一端改变数据 另外一端不会受影响 因为数据不存在引用 是拷贝过来的
    2. 监听worker线程返回的信息
    ```
    worker.onmessage = function(e){
        console.log('父进程接收的数据是',e.data);
    }
    ```
    3. 主线程关闭worker线程
    - worker线程一旦新建成功 就会始终运行 这样有利于随时响应主线程的通信
    - 这也是worker比较耗费计算机计算资源(CPU)的原因 一旦使用完毕 就应该关闭worker进程
    ```
    worker.terminate();//主线程关闭worker线程
    ```
    4. 监听错误
    ```
    // worker线程报错
    worker.onerror = e=>{
        //e.filename- 发生错误的脚本文件名 e.lineno- 出现错误的行号 e.messgae- 可读性良好的错误消息
        console.log('onerror',e);
    }
    ```
    > worker线程
    - self代表worker进程自身
    - worker线程的执行上下文是一个叫做WorkerGlobalScope的东西 跟主线程的上下文(window)不一样
    - 可以使用self/WorkerGlobalScope访问全局对象
    1. 监听主线程传过来的消息
    ```
    self.onmessage = e =>{
        console.log('主线程传来的消息',e.data);
    }
    ```
    2. 发送消息给主线程
    ```
    self.postMessage({
        hello:['这条消息','来自worker线程']
    })
    ```
    3. worker线程关闭自身
    ```
    self.close()
    ```
    4. worker线程加载脚本
    - Worker线程能够访问一个全局函数importScripts()来引入脚本 该函数接受0个或多个URI作为参数
    ```
    importScripts('http~.js','http~2.js');
    ```
    1. 脚本的全局变量都能被worker线程使用
    2. 脚本的下载顺序是不固定的 但执行时会按照传入importScripts()中的文件名顺序进行 这个过程是同步的

    > Worker线程限制
    - 因为worker创造了另外一个线程 不在主线程上 相应的会有一些限制 无法使用下列对象
    1. window对象
    2. document对象
    3. DOM对象
    4. parent对象
    
    > 可以使用下列对象/功能
    1. 浏览器:navigator对象
    2. URL:location对象 只读
    3. 发送请求:XMLHttpRequest对象
    4. 定时器:setTimeout/setInterval 在worker线程轮训
    5. 应用缓存:Application Cache
    
    > 多个Worker线程
    1. 在主线程内可以创建多个worker线程
    2. worker线程内还可以新建worker线程 使用同源的脚本文件创建
        - 在worker线程内再新建worker线程就不能使用window.URL.createObjectURL(blob)需要使用同源的脚本文件来创建新的worker线程 因为无法访问到window对象
    
    > 线程间转移二进制数据
    - 因为主线程和worker线程之间的通信是拷贝关系 要传递一个巨大的二进制文件给worker线程处理时 使用拷贝方式传递数据 回造成性能问题
    - Web Worker提供一种中转数据的方式 允许主线程把二进制数据直接转移给子线程
    - 一旦数据转移到其他线程 原先线程就无法再使用这些二进制数据了 这是为了防止出现多个线程同时修改数据的麻烦局面
    
    > 小结
    - Web Worker的出现 给浏览器带来了后台计算额能力 把耗时的任务分配给worker线程来做 很大程素上缓解了主线程UI渲染阻塞的问题 提升页面性能
24. postMessage
    > 定义
    - postMessage是H5引入的API postMessage()方法允许来自不同源的脚本采用异步方式进行有效通信 可实现跨文本文档 多窗口 跨域消息传递 多用于窗口间数据通信 使它成为跨域通信的一种有效解决方案
    - 兼容性
    - 除IE浏览器支持度较低 其他浏览器的支持度良好
    > postMessage API介绍
    1. 发送数据
    ```
    otherWindow.postMessage(message,targetOrigin,[transfer])
    ```
    2. otherWindow
    - 窗口的一个引用 比如iframe的contentWindow属性 执行window.open返回的窗口对象 或者是命名过的或数值索引的window.frames
    3. message
    - 要发送到其他窗口的数据 它会被结构化克隆算法序列化 可以不受什么限制的将数据对象安全的传送给目标窗口 而无需自己序列化
    4. targetOrigin
    5. transfer|可选属性
    6. 接收数据:监听messae事件的发生
    > 使用场景
    1. 跨域通信(包括Get请求和post请求)
        - 父窗体创建跨域iframe并发送消息
        - 子窗体接收信息并处理
    2. WebWorker
        - WebWorker为web内容在后台线程中运行脚本提供了一种简单的方法 线程可以执行任务而不干扰用户界面 一旦创建 一个worker可以将消息发送到创建它的JS代码 通过消息发布到改代码指定的事件处理程序
        - 一个worker是使用一个构造函数创建一个对象 运行一个命名的JS文件 这个文件将包含工作线程中运行的代码 worker运行在另一个全局上下文中 不同于当前window 不能使用window来获取全局属性
        - workers和主线程间的数据传递通过这样的消息机制进行 双方都使用postMessage()方法发送各自的消息 使用onmessage事件处理函数响应消息
    3. Service Worker
        - 可在浏览器控制台的application中看到Service Worker的存在
        - Service Worker是web应用做离线存储的一个最佳的解决方案 Service Worker和Web Worker的相同点是在常规的JS引擎线程以外开辟了新的JS线程去处理一些不适合在主线程上处理的业务
        > 不同点
        1. Web Worker服务于特定页面 Service Worker在被注册安装之后能够在多个页面使用
        2. Service Worker常驻在浏览器中 不会因为页面的关闭而被销毁 本质上 它是一个后台线程 只有你主动终结 或浏览器回收 这个线程才会结束
        3. 生命周期 可调用的API也不同
        - 可以使用Service Worker进行缓存 用JS来拦截浏览器的HTTP请求 并设置缓存的文件 从而创建离线web应用
        - 主要介绍使用postMessage方法进行Service Worker和页面之间的通讯
25. MutationObserver监控DOM变化
    - MutationObserver是现代浏览器提供的用来检测DOM变化的网页接口 可以使用这个接口来监听新增或删除节点 属性更改 或文本节点的内容改变
    
    > MutationObserver用途
    1. 通知用户当前所在页面所发生的一些变化
    2. 通过使用一些很棒的JS框架来根据DOM的变化来动态加载JS模块
    3. 在开发一个所见即所得编辑器时使用MutationObserver接口收集任意时间点上的更改 从而轻松实现撤销/重做功能
    
    > 如何使用
    - 通过往构造函数MutationObserver中传入一个函数作为参数来初始化一个MutationObserver实例 该函数会在每次发生DOM变化时调用
    - MutationObserver函数的第一个参数即为单个批处理中的DOM变化集 每个变化包含了变化的类型和所发生的改变
    ```
    var mutationObserver = new MutationObserver(function(mutations){
        mutations.forEach(function(mutation){
            console.log(mutation);
        })
    })
    ```
    
    > 创建的实例对象拥有三个方法
    1. observe 开始进行监听 接收两个参数 要观察的DOM节点以及一个配置对象
    2. disconnect 停止监听变化
    3. takeRecords 触发回调前返回最新的批量DOM变化
    
    > 没有Mutation时如何监听DOM变化
    1. 轮询
        - setInterval 可以理解为脏检查
    2. MutationEvents
        - 每个单一的DOM班婳都会触发mutation事件 结果又会造成性能问题
    3. CSS动画
        - 创建一个动画 一旦在DOM中添加一个元素就会触发该动画
        - 开始执行CSS动画时就会触发animationstart事件 
        - 假设为该事件添加事件监听器 就可以准确知晓DOM中添加元素
26. MessageChannel
    - window.MessageChannel 是一个异步操作的API
    - 它可以抽象成一个管道
    - 有两个端口 这两个端口是信息源也是消息源 可以互相通信
    > Tip:
    1. MessageChannel并不是一定要new出来才能用
    2. window和Worker对象下也有对应postMessage方法 同样可以监听message事件
    3. window和worker用DOM2级事件处理不需要调用start()方法
    > MessageChannel含有的属性
    - channel有两个属性对应两个端口 分别是port1 port2 它们是只读的
    > Tip:
    - 可以用ES6解构直接获取port1 port2
    ```
    const {port1,port2} = new MessageChannel();
    ```
    > MessageChannel应用场景
    1. MessageChannel提供一个安全的方法来解决跨域问题(主要是Iframe之间的)
    2. MessageChannel支持在Web Worker中使用
    3. Vue的nextTick降级方案用到了MessageChannel
    
    - 这三种场景所用到的postMessage方法形参有所不同
    1. iframe跨域通信场景
    - postMessage和监听message都是由MessageChannel对象下的MessagePort完成的
    2. web worker
    - 主要通过new MessageChannel实现两个Worker线程通信
    3. Vue nexttick
    - 为了在DOM更新后可以执行回调函数获取最新的DOM数据
    - Vue2.5+之后 nextTick的实现单独有一个JS文件维护它

    > nextTick对宏任务和微任务有各自的降级方案
    1. 宏任务
    setImmediate->MessageChannel->setTimout 0
    2. 微任务
    Promise -> 转换成宏任务执行
27. requestAnimationFrame
    > Web应用中 实现动画效果的方法较多
    1. JS中可以通过定时器setTimeout来实现
    2. CSS3可以使用transition和animation实现
    3. H5中的canvas也可以实现
    4. 除此之外H5还提供一个专门用于请求动画的API 即requestAnimationFrame

    > 是什么
    1. H5新增的API 类似于setTimeout定时器
    2. window对象的一个方法 window.requestAnimationFrame
    3. 浏览器(只能专门在浏览器中使用) 专门为动画提供的API 让DOM动画 Canvas动画 SVG动画 WebGl动画等有一个统一的刷新机制

    > 做什么
    - 浏览器重绘频率一般会和显示器的刷新率保持同步 大多数浏览器采取W3C规范的建议 浏览器的渲染页面的标准帧率也为60FPS
    1. 按帧对网页进行重绘
    2. 由系统来决定回调函数的执行时机
28. Google V8 JavaScrit引擎:
    - 是由谷歌开源的一个高性能 JavaScript 引擎。
    - 该引擎采用 C++ 编写，Google Chrome 浏览器用的就是这个引擎。
    - V8 可以单独运行，也可以嵌入 C++ 应用当中。和其他的 JavaScript 引擎一样，V8 会编译、执行 JavaScript 代码，并一样会管理内存、垃圾回收等。
    - 就是因为 V8 的高性能以及跨平台等特性，所以它也是 Node.js 的 JavaScript 引擎。
28. V8 concept
    - 现在JS引擎执行过程大致是 
        - 源代码 -> 抽象语法树 -> 字节码 -> JIT即时编译 ->本地代码
    - V8更加直接的将抽象语法树通过JIT技术转换成本地代码 放弃在字节码阶段可以进行的一些性能优化 但保证了执行速度
    - 在V8生成本地代码后 也会通过Profier采集一些信息 来优化本地代码 虽然少了生成字节码这一阶段的性能优化 但极大减少了转换时间
    1. isolate
        - 一个isolate是一个独立的虚拟机 对应一个或多个线程 但同一时间只能被一个线程进入 
        - 所有的isolate彼此之间是完全隔离的 它们不能有任何共享的资源
        - 如果不显式创建Isolate 会自动创建一个默认的isolate
        - 后面提到的 Context Scope Handle概念都是一个Isolate内部的
    2. Handle
        - V8中 内存分配都是在V8的Heap中进行分配的 JS的值和对象也都存放在V8的Heap中 这个Heap由V8独立维护 失去引用的对象将会被V8的GC掉 并可以重新分配给其他对象
        - Handle即是对Heap中对象的引用 V8为了对内存分配进行管理 GC需要对v8中的所有对象进行跟踪 而对象都是用Handle方式引起的
        - 所以GC需要对Handle进行管理 这样GC能知道Heap中一个对象的引用情况 当一个对象的Handle引用发生改变时 GC即可对该对象进行回收或者移动 
        - 因此V8编程中必须使用Handle去引用一个对象 而不是直接通过C++方式去获取对象引用 直接通过C++方式引用一个对象 会使得该对象无法被V8管理
        > Handle分为Local和Persisrent两种
        1. Local是局部的 它同时被HandleScope进行管理
        2. presistent类似于全局的 不受HandleScope的管理 其作用域可以延伸到不同的函数 而Local是局部的 作用域比较小
    3. Scope
        - 作用域可以看成是一个句柄的容器 在一个作用域中可以有很多很多个句柄 一个scope中可以包含很多个句柄(即一个scope中可以包含很多很多个v8引擎相关的对象)
    4. Context
        - 从概念上 这个上下文环境也可以理解为运行环境 在执行JS脚本时 总要有一些环境变量或全局函数
    5. 垃圾回收
        1. 好处 简化程序内存管理 内存管理无需程序员操作 减少了长时间运转的程序的内存泄漏 
        2. 缺点 无法预期的停顿 影响了交互体验
28. V8的垃圾回收机制
    > GC概念
    - Garbage Collection 程序工作过程中会产生很多垃圾 这些垃圾是程序不用的内存或是之前使用过的 以后不会再使用的内存空间
    - GC就是负责回收垃圾的
    - 不是所有语言都有GC 一般高级语言会自带GC 如Java Python JS等
    - 无GC的语言 如C C++ 需要程序员手动管理内存 相对麻烦
    > 垃圾回收策略
    - JS内存管理中有一个概念叫做可达性 即那些以某种方式可访问或可用的值 它们被保证存储在内存中 反之不可访问则需回收
    > 原理
    - 找到那些不再用到的内存(变量) 释放其内存
    > 常见算法策略
    1. 标记清除法
    - 最常用 
    - 打标记的方法
    - 当变量进入执行环境时 反转某一位(通过一个二进制字符表示标记)
        > 整个过程
        1. 垃圾收集器在运行时会给内存中所有变量都加上一个标记 假设内存中所有对象都是垃圾 全标记为0
        2. 从各个根对象开始遍历 把不是垃圾的节点改成1
        3. 清理所有标记为0的垃圾 销毁并回收它们所占用的内存空间
        4. 把所有内存中对象标记修改为0 等待下一轮垃圾回收
    > 优点
    - 实现简单
    > 缺点
    1. 内存碎片化 
    2. 分配速度慢
    - 标记整理法可补全上述缺点

    2. 引用计数法
    - 最早的一种垃圾回收算法
    - 把对象是否不再需要简化定义为对象有没有其他对象引用到它 如果没有引用只想该对象(0引用)对象将被垃圾回收机制回收
    > 优点
    1. 引用值为0可回收 即可立即回收
    > 缺点
    1. 循环引用

    > V8对GC的优化
    1. 分代式垃圾回收
    - V8的垃圾回收策略主要基于分代式垃圾回收机制 V8中将堆内存分为新生代和老生代两区域 采用不同的垃圾回收器也就是不同的策略管理垃圾回收
    - 新生代 存活时间较短的对象 新产生的对象 通常只支持1-8M容量
    - 老生代 存活时间较长或常住内存的对象 即经历过新生代垃圾回收后还存活下来的对象 容量通常较大
    - 对于新老两块内存区域的垃圾回收 V8采用两个垃圾回收器来管控
    > 新生代垃圾回收
    - 通过一个名为Scavenge算法进行垃圾回收 Scavenge算法具体实现中 主要采用一种复制式方法即为Cheney算法
    > 老生代垃圾回收
    2. 并行回收
    3. 增量标记与懒性清理

    1. 如何查看V8的内存使用情况
        - 使用process.memoryUsage() 返回如下
        ```
        {
            rss:,
            heapTotal,
            heapUsed,
            external
        }
        ```
        - heapTotal和heapUsed代表V8的内存使用情况
        - external代表V8管理的绑定到JS的C++对象的内存使用情况
        - rss 驻留集大小 给这个进程分配了多少物理内存(占总分配内存的一部分) 让这些无力内存中包含堆 栈和代码段
    2. v8的内存限制是多少 为何这样设计
        - 64位系统下是1.4GB 32位系统下是0.7GB
        - 1.5gb的垃圾回收堆内存 V8需要花费50ms以上 做一次非增量式的垃圾回收甚至要1秒以上 
        - 这是垃圾回收中引起JS线程暂停执行的事件 在这样的花销下 应用的性能和影响力都会直线下降
    3. V8的内存分代和回收算法
        - V8中 主要讲内存分为新生代和老生代两代
        1. 新生代 对象存活时间较短
            - 对象主要通过Scavenge算法进行垃圾回收 
        2. 老生代 对象存活时间较长 或常驻内存的对象
            - 标记清除进行垃圾回收
    4. 哪些情况会造成V8无法立即回收内存
        - 闭包和全局变量
    25. JS内存管理及3中常见的内存泄漏
    > JS代码执行分三部分
    1. runtime 运行时提供window dom 等API注入
    2. js engine JS引擎负责内存管理 代码编译执行
    3. event loop 事件循环负责处理异步逻辑

    >内存区域 
    - 分为栈/堆两部分 
    1. 内存静态分配(static allocation)
        - 对于可以确定大小的变量 它们会被存储在栈空间中
    2. 动态分配(dynamic allocation)
        - 不能在编译阶段就确定其需要多大的存储空间 其占用内存大小是在运行时确定的
    > 内存生命周期 不管什么程序语言，内存生命周期基本是一致的：
    1. 分配你所需要的内存
        JS中通过做变量声明赋值自动完成
    2. 使用分配到的内存（读、写）
    3. 不需要时将其释放归还   

    > 内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。 
    
    > GC(Garbage Collection System)垃圾回收系统算法
    - 引用计数
    - 标记清除(较常用)
    - 复制算法
    
    > 造成内存泄露的原因
    1. 意外的全局变量
    2. 没有清理的DOM元素引用
    3. 被遗忘的定时器或回调
    4. 闭包(存在堆内存中)
    5. 子元素存在引起的内存泄漏
    6. IE7/8引用计数使用循环引用产生的问题
    
    >避免内存泄漏
    1. 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；
    2. 注意程序逻辑，避免“死循环”之类的 ；
    3. 避免创建过多的对象  原则：不用了的东西要及时归还。
28. JS内存管理机制
    - 不管什么程序语言，内存生命周期基本是一致的：
    1. 分配你所需要的内存
    2. 使用分配到的内存（读、写）
    3. 不需要时将其释放归还
    - 与其他需要手动管理内存的语言不通，在JavaScript中，当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。
    - 当系统发现这些变量不再被使用的时候，会自动释放（垃圾回收）这些变量的内存，开发者不用过多的关心内存问题。

    - JavaScript中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。
        - 基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的引用类型：
        - 引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。
    
    > 栈的内存空间
    - 只保存简单数据类型的内存 由操作系统自动分配和自动释放
    
    > 堆的内存空间
    - 大小不固定 系统无法进行自动释放 此时需要JS引擎来手动释放这些内存
    
    > 为什么需要垃圾回收  
    1. 表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景
    2. 深层原因是，V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）
   
    - 栈内的内存，操作系统会自动进行内存分配和内存释放，而堆中的内存，由JS引擎（如Chrome的V8）手动进行释放，当我们代码的按照正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露），从而使得浏览器占用的内存不断增加，进而导致JavaScript和应用、操作系统性能下降。
28. JS垃圾回收机制
    > 问题引出 
    - 使用不当的闭包将会在IE(IE9之前)造成内存泄漏
    - IE9的JS引擎使用的垃圾回收算法是引用计数法 对于循环引用将会导致GC无法回收该回收的内存 造成无意义的内存占用 就是内存泄漏
    
    > 在变量进入执行环境时 会添加一个标记 当变量离开时 会添加一个离开标记 标记清除是GC在运行时会给所有变量加上标记 然后去掉那些还在环境中或还被环境中变量引用的变量 清除剩下还被标记的所有变量
    
    > GC定义   
    - Garbage Collection缩写 意为垃圾回收 垃圾:程序不用的内存空间(可能是之前用过了 以后不会再用) GC工作在JS引擎内部
    > GC做了什么
    1. 找到内存空间中的垃圾
    2. 回收垃圾 让程序员能再次利用这部分空间
    - PS:不是所有语言都有GC 
        Java JavaScript Python
        手动管理内存 C malloc/free C++ new/delete
    
    > 为什么要使用GC
    - 省去开发者手动管理内存的麻烦 从而减少Bug的产生 把精力留给更本质的编程工作
    
    > 必备的基础知识    
    - 堆(HEAP) 关于动态存放对象的内存空间 对象在JS中是引用类型
    - mutator GC中代表应用程序本身 暂且理解为mutator需要大量内存
    - allocator mutator将需要内存的申请提交到此 allocator负责从推中调取足够内存空间供mutator使用
    - 活动对象/非活动对象 代表通过mutator引用的对象   
    
    > 常见的几种GC算法    
    1. 引用计数法
        (该方法已经逐渐被标记-清除算法替代 V8引擎中使用最多的就是标记-清除算法)
        让所有对象实现记录下有多少程序在引用自己 让各对象都知道自己的被引用值
        优势:
            1.可即刻回收垃圾
            2.因为是即时回收 程序不会暂停去单独使用很长一段时间GC 最大暂停时间很短
            3.不用去遍历堆里面所有活动对象和非活动对象
        劣势:
            1.计数器需要占很大位置
            2.最大劣势无法解决循环引用无法回收问题
            (算法是将引用次数为0的对象销毁 此处都不为0 导致GC不会回收他们 这就是内存泄漏问题)
    2. 标记清除法
        主要将GC的垃圾回收过程分为两个阶段
            标记阶段：把所有活动对象做上标记
                根可以理解为我们的全局作用域 GC从全局作用域的变量 沿作用域逐层向里遍历(深层遍历)当遍历到堆中对象时 说明该对象被引用 则打上一个标记 继续递归遍历(因为肯定存在堆中对象引用另一个堆中对象)直到遍历到最后一个(
                    最深的一层作用域节点
                )
            清除阶段: 把没有标记(也就是非活动对象)销毁
                遍历整个堆 回收没有打上标记的对象
                这种方法可以解决循环引用问题 因为两个对象从全局对象出发无法获取 因此他们无法被标记 他们会被垃圾回收机制回收
        优势:
            1.实现简单 打标记也就是打/不打两种可能 所以就一位二进制位就可以表示
            2.解决了循环引用问题
        缺点：
            1.造成碎片化(有点类似磁盘碎片化)
            2.再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端
    3. 复制算法
        只把某个空间的活动对象复制到其他空间
        实现：
            将一个内存空间分为两部分
            一部分是From空间
            另一部分是To空间
            将From空间中的活动对象复制到To空间
            然后释放掉整个From空间
            然后此刻将From空间和To空间的身份互换
            完成一次GC
28. 首屏和白屏时间如何计算
    > 首屏时间的计算 可以由Native WebView提供的类似onload的方法实现 在ios下对应的是webViewDidFinishLoad 在android下对应的是onPageFnished事件
    
    > 白屏定义
    1. 没有任何内容
    2. 网络或服务异常
    3. 数据加载中
    4. 图片加载不出来 
    - 场景不同 白屏的计算方式就不同

    1. 页面元素数小于x时 认为页面白屏 如没有任何内容 可以获取页面的DOM节点数 判断DOM节点树少于某个阀值x 
    2. 当页面出现业务定义的错误码时 认为是白屏 如网络或服务异常
    3. 当页面出现业务定义的特征值时 认为是白屏 如数据加载中
30. load和DOMContentLoaded
    > load
    - 监测一个完全加载完成的页面 当一个资源及其依赖资源已完成加载时 将触发load事件
    - 页面的HTML CSS JS 图片等资源都已经加载完成后才会触发load事件
    
    > DOMContentLoaded
    - 当初始的HTML文档被完全加载和解析完成之后 DOMContentLoaded事件被触发 而无需等待样式表 图片和子框架的完成加载
    - HTML下载解析完触发
    - 在html文档加载完毕 且html所引用的内联js 外链js的同步代码都执行完毕后出发
    
    > 下载加载
    - 将浏览器资源下载到本地
    
    > 解析
    - 将一个元素通过一定的方式转换成另一种形式 如HTML的解析
    - HTML下载到浏览器的表现形式就是包含字符串的文件 浏览器将HTML文件中的字符串读取到内存中 按照HTML规则 对字符串进行取词编译 将字符串转化为另一种易于表达的数据结构
    - 浏览器会对转化后的数据结构自上而下进行分析 首先开启下载进程 对所有的资源进行优先级排序下载 同时主线程对文档进行解析
    1. 遇到script标签 首先阻塞后续内容的解析 同时检查该script是否已经下载下来 如果已下载 便执行代码
    2. 遇到link标签 不会阻塞后续内容的解析(比如DOM构建) 检查link资源是否已经下载 如果已经下载 则构建cssom
    3. 遇到dom标签 执行dom构建 将该dom元素添加到文档树中
    - PS:在body的第一个script资源下载完成之前 浏览器会进行首次渲染 将该script标签前面的DOM树和CSSOM树合并成一棵Render树 渲染到页面中 这是页面从白屏到首次渲染的时间节点
    
    > DOM构建
    - 将文档中的所有DOM元素构建成一个树形结构 DOM构建是自上而下构建 会受到JS执行的干扰
    
    > CSS构建
    - 将文档中所有的css资源合并
    
    > render树
    - 将DOM树和CSS合并成一颗渲染树 render树在合适的实际会被渲染到页面中 如遇到script 该script还未下载到本地时
    
    > 浏览器对同一域名下的资源并发下载线程数 chrome为6个