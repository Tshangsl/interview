1.浏览器是如何工作的
    1.浏览器输入url后发生了什么
        (
            1.DNS解析 
                将我们输入在地址栏中的URL通过DNS解析成IP地址
            2.TCP连接(传输层)
            3.HTTP请求(应用层)
            以下实际进行时不是独立的会有交叉
            4.构建DOM树
            5.构建CSSOM树
            6.构建Render树
            7.布局Layout绘制Painting
        )
        1.DNS解析
            (将我们输入在网页地址栏的URL通过DNS解析成IP地址)
            (查找是否存在该域名对应的IP地址 系统(浏览器/操作系统)缓存查询=>(向DNS服务器发送请求)路由器缓存/ISP缓存=>DNS递归/迭代查询)
            1.为什么进行DNS解析
                要想得到接收方的MAC地址 需要通过对方的IP地址获取 对方的IP需要通过DNS解析
                DNS解析：
                    将我们输入在网页地址栏的URL通过DNS解析成IP地址
                DNS：
                    将域名转化为IP地址的过程
                DNS解析过程中会发生什么
                (系统 路由 ISP 缓存查询 DNS递归迭代查询)
            2.系统缓存查询
                (系统缓存中查找是否存在该域名对应的IP地址)
                1.浏览器会调用一个库函数 检测本地的hosts文件(可以认为是电脑本地的一个地址映射文件)
                    从该文件中查看是否有对应的该域名的IP地址
            3.路由器缓存 ISP缓存
                1.如果系统缓存没有 就会向DNS服务器发送请求 而网络服务一般都会先经过路由器以及网络服务商(电信)
                    所以会先查询路由器缓存 然后再查询ISP的DNS缓存
                2.ISP缓存 本身是一种宽带接入提供商给网页批量访问加速的技术
                    ISP会将当前访问量较大的网页内容放到ISP服务器缓存中
                    当有新的用户请求相同内容的时 可以直接从缓存中发送相关信息
                    而不必每次都去访问真正的网站 
                    从而加快不同用户对相同内容的访问速度 
                    同时也能节省网间流量结算成本
            4.DNS递归查询
                如果路由缓存和ISP缓存的DNS缓存还是没有的话 我们就进行DNS递归查询
                从根域名服务器开始查询 然后再到顶级域名服务器 再到主域名服务器依次查询
                两种查询方式
                    1.递归查询
                        DNS服务器收到请求时 检查DNS缓存 
                        如果没有就会询问其他服务器 
                        并将返回的查询结果返回给客户端
                    2.迭代查询
                        DNS收到请求时 不是直接返回查询结果 
                        而是告诉客户端另一台DNS服务器地址 
                        然后客户端再向这台DNS服务器提交请求 
                        依次循环
            5.DNS优化
                1.浏览器缓存 本地的DNS缓存服务器
                2.DNS负载均衡 DNS根据每台机器的负载量 地理位置的限制等 去提供高效快速的DNS解析服务
        2.TCP连接
            通过DNS查询到IP地址后 下一步与服务器建立联系 为下面的数据传输做准备
            1.TCP
                (Transmission Control Protocol传输控制协议)
                一种面向连接的 可靠的 基于字节流的传输层通信协议
            2.TCP头部报文
                1.源端口号(source port) 
                目的端口号(destination port)
                    应用程序的端口号和
                    应用程序所在的主机的IP地址
                    统称为socket(套接字)
                    在互联网上socket唯一标识每一个应用程序
                    源端口+源IP+目的端口号+目的IP-套接字对
                    (一对套接字对就是一个连接)                    
                2.序列号(Sequence Number)
                    (确保数字通信有序性 
                    保证分割数据段在原始数据包位置 
                    初始序列号由自己决定 
                    后续由对端ACK决定)
                3.TCP flag
                    TCP首部有六个标志比特 它们中的多个可同时被设置为1
                    依次为URG ACK PSH RST SYN FIN
                    1.ACK
                        应答域有效 有两个取值 0 1
                            1 应答域有效 0 无效
                    2.SYN 同步序列号
                    (这个标志位的数据包长用来进行端口扫描)
                        TCP握手发送的第一个数据包 用来建立TCP连接
                        SYN标志位和ACK标志位搭配使用 
                        连接请求时：SYN=1 ACK=0
                        连接被响应时：SYN=1 ACK=1
                         
                        扫描者发送一个只有SYN的数据包 如果对方主机响应了一个数据包回来
                        表明这台主机存在这个端口
                    3.FIN
                        表示发送端已经达到数据末尾 
                        发送FIN标志位的TCP数据包后 
                        连接将被断开
                    4.URG
                    5.RSG
                    6.PSH
                4.Window Size   
                    滑动窗口的大小 用来进行流量控制
            为什么进行TCP三次握手：
            (确认双方接收发送数据能力/
            指定自己初始化序列号 为后面可靠传输做准备/
            HTTPS协议三次握手 会进行CA证书的验证 以及加密密匙的生成)
            TCP三次握手过程：
                最重要两点：
                    (客户端服务器端状态变化/标志信息变化)
                    1.客户端和服务器端状态的变化
                    (Client Server
                    closed listen
                    SYN_Send Listen
                    SYN_Send SYN_Recieve
                    Established SYN_Recieve)
                    2.三次握手过程标志信息的变化
                    (SYN(Client)=1(j)
                     SYN(Server)=0(k) ACK(1)=SYN(Client)+1(ACK)=1
                     ACK=SYN(Server)+1(ACK=1)
                    )
                1.初始状态：
                    1.客户端处于closed(关闭)状态
                    2.服务器处于listen(监听)状态
                2.第一次握手(SYN=1(j) 客户端SYN_Send状态)
                    客户端发送请求报文 将SYN=1(j)初始化序列发送给客户端
                    发送完后 客户端将处于SYN_Send状态
                3.第二次握手(SYN)
                    服务端收到SYN请求报文后 如果同意连接 
                    会以自己的SYN(服务端) = 0(K)
                    和ack(1) = SYN(客户端)+1(ACK=1)报文作为答应
                    服务器为SYN_Recieve状态
                4.第三次握手
                    客户端收到服务端的SYN+ACK然后发送ACK = SYN(服务端)+1(ACK=1)
                    确认包作为应答 客户端转为established状态
                5.为什么不是一次两次握手
                    1.防止服务器端一直等待浪费资源
                    2.防止已经失效的 连接请求报文段 突然传送到服务端 因而产生错误
        3.HTTP请求
            客户端与服务器端通过TCP三次握手建立连接后 
            客户端开始向服务端主动发起请求
            服务器端接收到客户端发送的信息 
            返回响应文件和信息 状态码
            浏览器的渲染原型
        四次挥手释放TCP连接
        4.构建DOM树
        5.构建CSSOM树
        6.生成渲染树
        7.合成绘制
2.浏览器渲染引擎工作流程
    1.解析HTML生成DOM树 解析CSS 生成CSSOM树 将DOM树和CSSOM树结合生成渲染树 render
    2.根据渲染树 浏览器计算出页面有哪些节点 各节点的CSS以及从属关系-回流
    3.根据渲染树以及回流得到的节点信息 计算出每个节点在屏幕中的位置-重绘
    4.最后将得到的节点位置信息交给浏览器的图形处理程序 让浏览器显示页面
    (以上流程不一定会严格遵守先后顺序 有可能同时出现)
    1.创建DOM树 HTML分析器 分析HTML元素 构建一棵DOM树
    2.创建StyleRules CSS分析器 分析CSS文件 构建Rules树 生成CSSOM树
    3.创建Render树 将DOM树和Rules树关联起来 构建一颗Render树
    4.布局Layout分析布局信息 计算坐标位置
    5.绘制Painting 开始绘制
3.重绘(Repaint)重排/回流(Reflow)是什么以及如何减少重绘、避免重排
    重排(Reflow)/回流/重构
        DOM中各个元素都有自己的盒子模型，
        需要浏览器根据样式进行计算，
        并根据计算结果将元素放到特定位置，
        这就是Reflow

        当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流
        每个页面至少需要回流一次，就是在页面加载的时候
    触发Reflow条件
        (任何页面布局和几何属性的改变都会触发回流)
        1.增、删、改、移DOM
        2.修改CSS样式
        3.Resize窗口
        4.页面滚动
        5.修改网页的默认字体
        1.布局流相关操作
            1.盒模型相关操作
            2.定位相关操作
            3.浮动相关操作
        2.改变节点内的内容
        3.CSS
    重绘（Repaint)
        当节点的部分属性发生变化 但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。
        1.当各种盒子的位置、大小以及其他属性改变时，
        2.浏览器需要把这些元素都按照各自的特性绘制一遍，
        3.这个过程称为Repaint。
        table(渲染树中节点的属性值)
        table及其内部元素可能需要多次计算才能确定好其在 
        渲染树中节点的属性值，
        比同等元素要多花两倍时间
        这就是我们尽量避免使用table布局页面的原因之一
    触发Repaint的条件：
        DOM改动
        CSS改动
    重绘和回流：
        在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘
        回流一定会引发重绘 重绘不一定会引发回流
    重绘重排的代价：
        耗时 导致浏览器卡慢
    减少重绘、避免重排
        本质上，就是合并修改
        具体的措施有：
            DOM层面：DocumentFragment本质上是一个占位符，真正插入页面的是它的所有子孙节点，所以，
                将需要变动的DOM节点先汇总到DocumentFragment，然后一次性插入，可以减少DOM操作的次数。
            CSS层面：操作多个样式时，可以先汇总到一个类中，然后一次性修改
    优化：
        1.每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。
        浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。
            但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
        2.操作时做的优化，减少对渲染树的操作，合并多次的DOM和样式修改，并减少对style样式的请求
4.window.onload window.open
    window.onload
    网页加载完毕后立即执行的操作
    即当HTML加载完毕后 立即执行某个方法等
    因为页面中的代码一般情况下 从上到下 从左到右顺序执行
    所以当JS代码需要获取页面中的元素时
    如果script标签在元素前面 需要加window.onload
    如果script标签在元素后面 不需要加window.onload
    window.open
    用于打开一个新的浏览器窗口或查找一个已命名的窗口
    语法 window.open(URL,name,space,replace)
5.window对象 document对象
    window
        JS中最大的对象
        表示窗口
        包含document
    document
        文档对象
        表示HTML
5.OOA(Object-Oriented Analysis)：面向对象的分析
  OOD(Object-Oriented Design):面向对象的设计
  OOP(Object-Oriented Programming):面向对象编程
6.浏览器几个线程
    1.JS引擎线程(解释执行JS代码 用户输入 网络请求)
    2.GUI线程(绘制用户界面 与JS主线程是互斥的)
    3.HTTP网络请求线程(处理用户的get/post等请求 等返回结果后将回调函数推入任务队列中)
    4.定时触发器线程(setTimeout setInterval等待时间结束后把执行函数推入任务队列中)
    5.浏览器中事件处理线程(将click mouse 等交互事件发生后 将这些事件放入事件队列中)
6.线程和进程有什么区别
    进程：
    (资源分配的最小单位/有自己独立的地址空间/资源独立)
        1.进程是资源分配的最小单位
        2.进程有自己独立的地址空间
        3.进程之间的资源是独立的
    线程
    (程序执行的最小单位/共享进程的地址空间/共享本进程资源)
        1.线程是程序执行的最小单位
        2.线程共享进程的地址空间
        3.线程共享本进程的资源
    操作系统的设计 由此可归结为三点
        1.以多进程形式，允许多个任务同时运行；
        2.以多线程形式，允许单个任务分成不同的部分运行；
        3.提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
7.HTTP缓存和CDN缓存
    HTTP缓存
        客户端缓存 
        浏览器作为客户端收到服务器端响应后
        对响应首部字段进行解析 
        分析出相应的缓存规则 
        将资源按规则进行缓存 
        再次请求时 
        如果命中缓存 则直接读取本地缓存 不再发出请求
    缓存规则
        HTTP缓存规则由响应首部字段控制
        关键字
        (确定缓存存储时间 1.0Expires 1.1Cache-Control)
        (确定缓存是否需要被更新/缓存对比 Last-Modified Etag)
            确定缓存存储时间
            Expires
                HTTP1.0中用来控制缓存时间的参数
                响应头包含日期/时间
                在此时间后 响应过期

                过去的时间或无效时间 缓存但立即过期
                等同于cache-control = no-cache
                未来的时间 缓存到对应时间 
            Cache-Control
                (public/provate/max-age/s-max-age/no-store/no-cache)
                HTTP1.1中用来控制缓存的参数
                1.public:表示响应可以被任何对象
                (包括：发送请求的客户端 代理服务器 等等)缓存
                2.private:表示响应只能被单个用户缓存
                不能用作共享缓存(即代理服务器不能缓存它)
                3.max-age=<seconds>:设置缓存存储最大周期相对请求时间缓存seconds秒 
                在此期间 访问资源直接读取本地缓存 不想服务器发起请求
                (与expires同时出现 max-age优先级更高)
                4.s-max-age=<seconds>:规则等同max-age 覆盖max-age/Expires头 但是仅适用于共享缓存(如各个代理)并且私有缓存中它被忽略(于expires/max-age同时出现 s-maxage优先级更高)
                5.no-store:不缓存服务器相应的任何内容 每次访问资源都要服务器完整响应
                6.no-cache:缓存资源 但立即过期 每次请求都要跟服务器对比验证资源是否被修改(等同max-age=0)
            确定缓存是否要被更新(缓存对比)
            Last-Modified
                (上次修改时间 缓存过期 与请求中If-Modified-Since比对 一致则继续使用之前缓存 不一致则认为失效)
                (包含If-Modified-Since&If-Unmodified-Since)
                源头服务器认定的资源做出的修改的日期及时间
                    上次修改时间 如果缓存时间过期 
                    该字段将用于
                    与请求中if-Modified-Since对比 
                    一致则继续使用之前的缓存 
                    不一致则认为缓存失效
                精度比Etag低
                包含
                if-Modified-Since
                if-Unmodified-Since
                首部的条件请求会使用这个字段
            Etag
                HTTP响应头是资源的特定版本的标识符
            缓存流程中三个问题
            1.缓存是否过期
                基于该资源上次响应缓存规则 同时满足下列条件 则视为缓存未过期 
                判断缓存是否过期只跟客户端相关 与服务端无关 
                1&2&3同时满足即认为缓存未过期 相反过期
                    1.cache-control值为max-age
                    2.max-age>0
                    3.当前data<上次请求时date+max-age
                PS:expire可同等转化为cache-control=max-age形式 s-maxage与maxage规则相同
            2.询问服务器资源是否修改
                (Etag If-None-Match 优先对比
                Last-Modified If-Modified-Since)
                判断资源是否修改 需要客户端与服务器共同协作 
                客户端在首次拿到资源缓存后会存储Etag(若有)
                和Last-Modified(若有) 
                在下次缓存过期时 
                会将Etag写在请求头部中的If-None-Match中
                将Last-Modified值写在请求头部中的If-Modified-Since中 
                服务端优先对Etage进行对比
                一致情况下才会继续对比Last-Modified 
                完全通过后即视为缓存没有修改
                决定返回304 
                告诉浏览器资源未更新 可以使用本地缓存
                有一项不通过则认为资源已被修改 缓存失效
            Etag：
                。。。
            3.缓存规则
                缓存规则主要由cache-control字段和expires字段体现 同时出现则以cache-control为准
            总结:
                对于HTTP缓存的配置 始终要做到两点
                1.清楚明白HTTP缓存的原理与规则
                2.明确缓存的配置不是一次性的
            总结:
                。。。
    CDN缓存(Content Delivery Network)内容分发网络
        (缓解源站压力 优化不同用户的访问速度和体验)
        CDN缓存是一种服务端缓存 
        CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上
        当用户访问相应的业务资源时
        用户会被调度至最接近的节点
        最近的节点ip返回给用户
        在web性能优化中 它主要起到了
        缓解源站压力 优化不同用户的访问速度和体验的作用
        缓存规则：(由CDN服务商制定)
            与HTTP缓存不同的是 这个规则不是规范性的
            而是有CDN服务商来制定
            。。。
            关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的
            Cache-control: max-age 
            字段来设置CDN边缘节点数据缓存时间。
            当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。
        CDN优势:
            1.CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。
            2.大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。
        总结：
            CDN缓存的配置并不复杂 
            复杂的情况在于CDN缓存配置会受到HTTP缓存配置的影响 并且不同的CDN运营商对于这种影响的处理也都不一致
            实际使用时 建议去对应的CDN服务商文档中找到对应的注意事项
    HTTP缓存和CDN缓存结合
        。。。
        总结：
            HTTP缓存和CDN缓存分别作为客户端缓存和服务端缓存共同影响着我们的web请求流向 
            想做好缓存配置 首先清楚缓存的原理和配置规则
            其实是结合项目分析缓存级别 具体情况具体处理
    DNS缓存 查询过程
        1.首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。
        2.如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。
        3.如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。
        4.如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。
7.浏览器缓存
    定义
        是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，
        当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。
    浏览器打开一个页面前端缓存
        一般针对如CSS JS image等静态资源
    缓存缺点
        如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。
        所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。
    缓存的优点：
        1.减少了冗余的数据传输，节省网费
        2.减少服务器的负担，提升网站性能
        3.加快了客户端加载网页的速度

        Etag：
            资源的内容标识(不唯一 通常为文件的md5或者一段hash值 只要保证写入和验证时的方法一致即可)
        If-None-Match：
            客户端保留的资源内容标识
        PS:
            1.分布式系统尽量关闭Etag 因为每台机器生成的Etage都不一样
            2.分布式系统里多台机器间文件的Last-Modified必须一致 避免负荷均衡不同导致对比失败
            通常情况下 如果同时发送if-None-Match If-Modified-Since字段 服务器只要比较Etage的内容即可 当然具体的处理方式 看服务器的约定规则
8.前端清除缓存几种方法
    (meta方法/
    Jquery AJAX清除浏览器缓存/
    随机数/
    随机时间/
    php后端处理)
    1.meta方法 有时谷歌等浏览器不支持
    2.jquery ajax清除浏览器缓存
        1.用AJAX请求服务器最新文件 并加上请求头if-Modified-Since和Cache-Control
        2.直接用cache:false
    3.随机数
        url参数后面加上"?ran="+Math.random()
    4.随机时间 和随机数一样
        url参数后面加上"?timestamp="+new Date().getTime();
    5.用php后端处理
        在url参数后加上 在服务器端加
        header("Cache-Control:no-cache,must-revalidate")
9.前端如何优化网站性能/前端浏览器性能优化
    (减少HTTP请求数量/
    利用浏览器缓存/
    控制资源文件加载优先级/
    减少重排/减少DOM操作
    图标从字体图标改为图片图标
    尽量外链JS CSS)
    1.减少 HTTP 请求数量
        CSS Sprites
        采用 lazyLoad
    2.利用浏览器缓存 
    3.控制资源文件加载优先级
        浏览器加载HTML内容时
        将HTML内容从上至下依次解析
        解析到link/script标签会加载href/src对应链接内容
        为第一时间展示页面给用户
        需要将CSS提前加载 不要受JS加载影响
        一般情况下都是CSS在头部 JS在尾部
    4.减少DOM操作 减少重排（Reflow）避免重排
    5.尽量外链CSS和JS(结构/表现/行为分离)
    6.图标由字体图标改成图片图标
10.前端首屏优化
    (CDN分发 减少传输距离/
    后端在业务层的缓存/
    静态文件缓存方案/
    前端资源动态加载/
    减少请求数量/
    页面使用骨架屏/
    使用SSR渲染/
    引入HTTP2.0/
    利用好HTTP压缩/
    利用好script标签的defer和async两个属性)
    1.CDN分发(减少传输距离)
        在多台服务器部署相同的副本
        用户访问时 服务器根据用户与那台服务器距离近
        决定那台服务器去响应这个请求
    2.后端在业务层的缓存
        数据库查询缓存可设置缓存
        此对处于高频率的请求很有用
        浏览器一般不会对content-type:application/json;
        的接口进行缓存
        所以有时需要手动为接口设置缓存
        比如一个用户的签到状态 它的缓存时间可以设置到明天之前
    3.静态文件缓存方案
        最常看到
        最流行的方式是hash+强缓存方案
        如hash+cache control:max-age=1年
    4.前端资源动态加载
        a.路由动态加载 最常用的方法 以页面为单位 进行动态加载
        b.组件动态加载 对于不在当前视窗的组件 先不加载
        c.图片懒加载 同上 越来越多的浏览器支持原生的懒加载
            通过给img标签加上loading='lazy'来开启懒加载模式
    5.减少请求的数量
        该点在HTTP1.1优势很明显 因为HTTP1.1的请求是串行的
        (尽管有多个TCP通道) 每个请求都需要往返后才能继续下个请求
        此时合并请求可以减少在路途上浪费的时间 此外还会带来重复的请求头部信息(比如cookie)
        HTTP2.0 新的二进制格式 多路复用 header压缩 服务器端推送
            中该问题会弱化很多 但是也有做的必要
    6.页面使用骨架屏 
        即为在首屏加载完成之前 通过渲染一些简单元素进行占位 
        骨架屏好处在于可以减少用户的等待时的急躁情绪 
        这点很有效 在很多成熟的网站(京东 淘宝 Youtube)都有大量应用 没有骨架屏的话 一个loadingdd的菊花图也是可以的
    7.使用SSR渲染
    8.引入HTTP2.0 
        HTTP2.0相对于HTTP1.1 最主要提升是传输性能 在接口小而多时会更加明显
    9.利用好HTTP压缩
        即使是最普通的gzip 也能把bootstrap.min.css压缩到原来的17% 
        压缩的效果非常明显 特别是对文本类的静态资源 
        此外 接口也是能压缩的 接口不大不用压缩 因为性价比低(考虑压缩和解压时间)
    10.利用好script标签的async和defer这两个属性
        功能独立且不要求马上执行的JS文件 可以加入async属性
        优先级低且没有依赖的JS 可以加入defer属性
11.浏览器内核
    浏览器内核
        (浏览器内核不同 对网页的语法解释不同 渲染效果不同)
        (所有网页浏览器 电子邮件客户端及其他需要编辑 显示网络内容的应用程序都需内核)
        渲染引擎Layout Engineer/Rendering Engine
            取得网页的内容(HTML/XML/图像等)
            整理讯息(如加入CSS)
            计算网页显示方式
            输出至显示器/打印机
        JS引擎
            解析执行JS实现网页动态效果
    常见的浏览器内核
        Trident:IE 360 搜狗
        Gecko:FireFox Netscape6及以上版本
        Presto:Opera
        Blink:Opera Google
        Webkit:Safari Chrome
    最开始渲染引擎和JS引擎没有区分很明确
    后来JS引擎越来越独立 内核就倾向于只指渲染引擎

    -webkit- 针对safari chrome浏览器的内核css写法
    -moz- 针对firefox浏览器的内核css写法
    -ms- 针对IE内核的css写法
    -o- 针对Opera内核的css写法
12.如何避免页面上商品价格被爬取到
    1.价格信息AJAX获取
    2.价格设置图片
    3.JS对价格加密再解密
    4.字体加密 如#xf076对应100
13.前端常用的几种弹窗函数
    (alert/confirm/prompt/HTML+CSS+JS)
    1.alert('')弹窗 提示
        主要作为提示
        一般经常用来测试JS某段代码是否出错
    2.confirm('')弹窗 判断是否进行某一个操作
        点击确定 返回true
        点击取消 返回false
        点击确定/取消按钮关闭前 将阻止用户对浏览器的所有输入       
    3.prompt('')弹窗 用于输入文本内容 
        用于显示可提示用户进行输入的对话框
        用户单击取消按钮 返回null
        单击确认按钮 返回输入的文本
        点击确定或取消关闭之前
        它将阻止用户对浏览器的所有输入
        调用prompt()时 用户做出响应之前 不会执行下一条语句
    4.HTML+CSS+JS实现浏览器弹窗
        click控制div.style.display为block/none        
14.前端文件上传功能
    Web浏览器上传文件一般有以下几种方式
        1.form表单上传文件
        2.原生js实现ajax上传文件
        3.jquery实现ajax上传文件
        4.form+iframe上传文件
    form提交数据后会整个刷新页面
    原生js实现ajax上传文件 
        不会刷新整个页面
        它们都是通过使用formdata对象实现的
        formdata对象在老版本的浏览器中并不支持
    为了兼容老版本浏览器 
        使用iframe方式提交
15.Web标准及W3C理解认识
    Web标准简单来说可以分为
    结构：
        主要由HTML标签组成
    表现：
        CSS样式表
    行为:
        页面和用户交互
    Web标准一般将该三部分独立分开 使其更具有模块化
    一般产生行为时 会有结构或表现的变化 使该三者界限不够清晰
    W3C对Web标准提出规范化要求
        即实际编码中一些代码规范
        1.结构要求
            (标签规范可以提高搜索引擎对页面的抓取效率 对SEO较有帮助)
            1.标签字母小写
            2.标签闭合
            3.标签不允许随意嵌套
        2.CSS/JS
            1.尽量使用外链CSS样式表和JS脚本 
                使结构表现行为分三块 符合规范 同时提高页面渲染速度 提高用户体验
            2.样式尽量少使用行内样式 使结构和表现分离 标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版
            3.不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。
16.负载均衡
        高可用架构的一个关键组件 主要用来提高性能和可用性
        通过负载均衡将流量分发到多个服务器
        同时多个服务器能够消除这部分的单点故障
    负载均衡可以处理那些类型的流量
        一般接触到的负载均衡可能大多是处理HTTP HTTPS流量
        实际上负载均衡还可以处理TCP/UDP流量
        如对数据库集群的访问 DNS等
    负载均衡算法
        用途：
        用于确定流量应该被分发到哪一个健康的服务器上
        常见的几个：
        (轮转/最少连接/IP hash)
            1.Round Robin 轮转
                服务器按顺序选择
                这种方式比较适合各服务器处理能力相同且每个业务处理量差不多的时候  
            2.Least Connections 最少连接
                负载均衡器会选择当前连接最少的服务器
            3.IP hash
                负载均衡器根据请求源的IP决定分发给哪个服务器
                该方法保证一个特定用户会一直访问相同的服务器
            4.Url Hash Random等
    健康检测
        负载均衡算法有一个前提
        流量只会被分配到健康的服务器上

        一般会通过配置的协议和端口尝试连接服务器保证服务器正在监听
        如果一个服务器的健康检查失败 
        即服务器无法正常响应请求
        那么就会被自动移除池子中 
        流量也不会被分配到这个坏掉的服务器
        直到它能通过健康检查
    负载均衡处理状态
        session用户认证 在服务器集群下 不能轻易做到状态共享
        解决该问题可以
            1.IP hash算法
            2.sticky session 粘性会话
                负载均衡器会设置一个cookie
                然后带有这个cookie的session都会被分配到同一个服务器上
    负载均衡双机热备 Hot standby
        负载均衡器本身就是一个单点故障隐患
        其中一个解决方案
            双机热备(提高可用性的一大基本方法就是冗余)
                为解决负载均衡器的单点故障问题
                引入第二个负载均衡器 
                主节点故障则切换到备用节点
17.WebGL-Web Graphics Library 
    一种3D绘图协议
18.面向切面编程 函数式编程
    面向切面编程
    函数式编程
        引入了纯函数的概念来帮助编程，纯函数对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。它是一种编程范式。RXJS用到了它。
19.SEO/前端SEO优化
(蜘蛛是否能看懂/网页内容是否能被搜索引擎识别
网页内容可以被搜索引擎识别 搜索引擎会提高该网站的权重
增加对该网站的友好度 --SEO)
(白帽SEO/黑帽SEO)
(提高网站权重/增强搜索引擎友好度)
    1.搜索引擎工作原理
        在搜索引擎网站的后台会有一个非常庞大的数据库
        里面存储了海量的关键词
        每个关键词对应着很多网址
        这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序
        从茫茫的互联网上一点一点下载收集而来的
        随着各种各样网站的出现
        这些勤劳的“蜘蛛”每天在互联网上爬行
        从一个链接到另一个链接，下载其中的内容
        进行分析提炼，找到其中的关键词
        如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中
        反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。一个关键词对用多个网址，因此就出现了排序的问题，
        相应的当与关键词最吻合的网址就会排在前面了。
        在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。
        如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。
        相应的，如果网站内容可以被搜索引擎能识别，
        那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为SEO。
    2.SEO(Search Engine Optimization)/搜索引擎优化 简介
        SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。
        分类：
            白帽SEO
                起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。
                作用:
                    1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；
                    2. 网站内容优化：内容与关键字的对应，增加关键字的密度；
                    3. 在网站上合理设置Robot.txt文件；
                    4. 生成针对搜索引擎友好的网站地图；
                    5. 增加外部链接，到各个网站上宣传。
            黑帽SEO
                利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？
    3.为什么要做SEO(提高网络权重/增强搜索引擎友好度)
        提高网站的权重，
        增强搜索引擎友好度，
        以达到提高排名，
        增加流量，改善（潜在）用户体验，促进销售的作用。
    4.前端SEO规范
        前端是构建网站中很重要的一个环节，前端的工作主要是负责页面的HTML+CSS+JS，优化好这几个方面会为SEO工作打好一个坚实的基础。通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂（提升用户体验），也能让“蜘蛛”看懂（提高搜索引擎友好度）。
        1.网站结构布局优化 尽量简单 开门见山 提倡扁平化结构
            1.控制首页链接数量
            2.扁平化的目录层次
            3.导航优化
            4.网站的结构布局
            5.利用布局 把重要内容HTML代码放在前面
            6.控制页面大小 减少HTTP请求 提供网站加载速度
        2.网页代码优化
            1.突出重要内容
            2.语义化书写HTML代码 符合W3C标准
            3.<a>标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el="nofollow" 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。
            4.正文标题要用<h1>标签：h1标签自带权重“蜘蛛” 认为它最重要，一个页面有且最多只能有一个H1标签，放在该页面最重要的标题上面，如首页的logo上可以加H1标签。副标题用<h2>标签, 而其它地方不应该随便乱用 h 标题标签。
            5.<img>应使用 "alt" 属性加以说明
            当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。同时为图片设置高度和宽度，可提高页面的加载速度。
            6.表格应该使用<caption>表格标题标签
            caption 元素定义表格标题。caption 标签必须紧随 table 标签之后，您只能对每个表格定义一
            7.<br>标签：只用于文本内容的换行
        3.前端网站性能优化
            1.减少HTTP请求
            2.控制资源文件加载优先级
            3.尽量外链CSS和JS（结构、表现和行为的分离）
            保证网页代码的整洁，也有利于日后维护
            4.利用浏览器缓存
            5.减少重排（Reflow）
            6.减少 DOM 操作
            7.图标使用IconFont替换
            8.不使用CSS表达式，会影响效率
            9.使用CDN网络缓存，加快用户访问速度，减轻服务器压力
            10.启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大
            11.伪静态设置
19.递归和迭代区别 优缺点 尾调用
    递归
        函数调用自己
    迭代
        循环调用别的函数
    尾调用
        在return的地方执行递归






















