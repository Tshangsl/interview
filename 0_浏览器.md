1.浏览器是如何工作的
    1.浏览器输入url后发生了什么
        (
            1.DNS解析 
                将我们输入在地址栏中的URL通过DNS解析成IP地址
            2.TCP连接(传输层)
            3.HTTP请求(应用层)
            以下实际进行时不是独立的会有交叉
            4.构建DOM树
            5.构建CSSOM树
            6.构建Render树
            7.布局Layout绘制Painting
        )
        1.DNS解析(将我们输入在网页地址栏的URL通过DNS解析成IP地址)
                (查找是否存在该域名对应的IP地址 系统(浏览器/操作系统)缓存查询=>(向DNS服务器发送请求)路由器缓存/ISP缓存=>DNS递归/迭代查询)
            1.为什么进行DNS解析
                要想得到接收方的MAC地址 需要通过对方的IP地址获取 对方的IP需要通过DNS解析
                DNS解析：
                    将我们输入在网页地址栏的URL通过DNS解析成IP地址
                DNS：
                    将域名转化为IP地址的过程
                DNS解析过程中会发生什么(系统 路由 ISP 缓存查询 DNS递归迭代查询)
            2.系统缓存查询(系统缓存中查找是否存在该域名对应的IP地址)
                1.浏览器会调用一个库函数 检测本地的hosts文件(可以认为是电脑本地的一个地址映射文件)
                    从该文件中查看是否有对应的该域名的IP地址
            3.路由器缓存 ISP缓存
                1.如果系统缓存没有 就会向DNS服务器发送请求 而网络服务一般都会先经过路由器以及网络服务商(电信)
                    所以会先查询路由器缓存 然后再查询ISP的DNS缓存
                2.ISP缓存 本身是一种宽带接入提供商给网页批量访问加速的技术
                            ISP会将当前访问量较大的网页内容放到ISP服务器缓存中
                            当有新的用户请求相同内容的时 可以直接从缓存中发送相关信息
                            而不必每次都去访问真正的网站 从而加快不同用户对相同内容的访问速度 同时也能节省网间流量结算成本
            4.DNS递归查询
                如果路由缓存和ISP缓存的DNS缓存还是没有的话 我们就进行DNS递归查询
                从根域名服务器开始查询 然后再到顶级域名服务器 再到主域名服务器依次查询
                    两种查询方式
                        1.递归查询
                            DNS服务器收到请求时 检查DNS缓存 如果没有就会村问其他服务器 并将返回的查询结果返回给客户端
                        2.迭代查询
                            DNS收到请求时 不是直接返回查询结果 而是告诉客户端另一台DNS服务器地址 然后客户端再向这台DNS服务器提交请求 依次循环
            5.DNS优化
                1.浏览器缓存 本地的DNS缓存服务器
                2.DNS负载均衡 DNS根据每台机器的负载量 地理位置的限制等 去提供高效快速的DNS解析服务
        2.TCP连接
            通过DNS查询到IP地址后 下一步与服务器建立联系 为下面的数据传输做准备
            1.TCP：(Transmission Control Protocol传输控制协议)
                一种面向连接的 可靠的 基于字节流的传输层通信协议
            2.TCP头部报文
                1.源端口号(source port) 目的端口号(destination port)
                    应用程序的端口号和
                    应用程序所在的主机的IP地址
                    统称为socket(套接字)

                    在互联网上socket唯一标识每一个应用程序
                    源端口+源IP+目的端口号+目的IP-套接字对
                        (一堆套接字对就是一个连接)                    
                2.序列号(Sequence Number)
                    (确保有序性 初始序列号由自己决定 后续由对端ACK决定)
                    确保数据通信的有序性 
                    保证分割的数据段在原始数据包的位置
                    初始的序列号由自己决定 
                    后续的序列号由对端的ACK决定
                3.TCP flag
                    TCP首部有六个标志比特 它们中的多个可同时被设置为1
                    依次为URG ACK PSH RST SYN FIN
                    1.ACK
                        应答域有效 有两个取值 0 1
                            1 应答域有效 0 无效
                    2.SYN 同步序列号
                        TCP握手发送的第一个数据包 用来建立TCP连接
                        SYN标志位和ACK标志位搭配使用 
                        连接请求时：SYN=1 ACK=0
                        连接被响应时：SYN=1 ACK=1
                        这个标志位的数据包经常用来进行端口扫描 
                        扫描者发送一个只有SYN的数据包 如果对方主机响应了一个数据包回来
                        表明这台主机存在这个端口
                    3.FIN
                        表示发送端已经达到数据末尾 发送FIN标志位的TCP数据包后 连接将被断开
                    4.URG
                    5.RSG
                    6.PSH
                4.Window Size   
                    滑动窗口的大小 用来进行流量控制
            为什么进行TCP三次握手：
            (确认双方接收发送数据能力/
            指定自己初始化序列号 为后面可靠传输做准备/
            HTTPS协议三次握手 进行CA证书的验证 以及加密密匙的生成)
                1.确认双方的接收与发送能力是否正常
                2.指定自己的初始化序列号 
                    为后面的可靠传送做准备
                3.如果是HTTPS协议的话 
                    三次握手这个过程 
                    会进行数字证书的验证
                    以及加密密匙的生成
            TCP三次握手过程：
                最重要两点：
                    (客户端服务器端状态变化/标志信息变化)
                    1.客户端和服务器端状态的变化
                    (Client Server
                    closed listen
                    SYN_Send Listen
                    SYN_Send SYN_Recieve
                    Established SYN_Recieve)
                    2.三次握手过程标志信息的变化
                    (SYN(Client)=1(j)
                     SYN(Server)=0(k) ACK(1)=SYN(Client)+1(ACK)=1
                     ACK=SYN(Server)+1(ACK=1)
                    )
                1.初始状态：
                    1.客户端处于closed(关闭)状态
                    2.服务器处于listen(监听)状态
                2.第一次握手(SYN=1(j) 客户端SYN_Send状态)
                    客户端发送请求报文 将SYN=1(j)初始化序列发送给客户端
                    发送完后 客户端将处于SYN_Send状态
                3.第二次握手(SYN)
                    服务端收到SYN请求报文后 如果同意连接 
                    会以自己的SYN(服务端) = 0(K)
                    和ack(1) = SYN(客户端)+1(ACK=1)报文作为答应
                    服务器为SYN_Recieve状态
                4.第三次握手
                    客户端收到服务端的SYN+ACK然后发送ACK = SYN(服务端)+1(ACK=1)
                    确认包作为应答 客户端转为established状态
                5.为什么不是一次两次握手
                    1.防止服务器端一直等待浪费资源
                    2.防止已经失效的 连接请求报文段 突然传送到服务端 因而产生错误
                    防止已经失效的 连接请求报文段 突然发送到服务端 因而产生错误
            1.三次握手
            2.四次挥手
        3.HTTP请求
            客户端与服务器端通过TCP三次握手建立连接后 
            客户端开始向服务端主动发起请求
            服务器端接收到客户端发送的信息 
            返回响应文件和信息 
            状态码

            浏览器的渲染原型
        4.构建DOM树
        5.构建CSSOM树
        6.生成渲染树
        7.合成绘制

        1.缓存解析
            1.浏览器缓存：浏览器会记录DNS一段事件 因此 只是第一个地方解析DNS请求
            2.操作系统缓存： 如果在浏览器缓存中不包含这个记录 则会使系统调用操作系统 获取操作系统记录(保存最近的DNS查询缓存)
            3.路由器缓存：如果上述两个步骤均不能成功获取DNS记录 继续搜索路由器缓存
            4.ISP缓存：若上述均失败 继续向ISP搜索
        2.域名解析 
            解析获取相应的ip地址
        3.浏览器向服务器发出TCP连接 
            与浏览器建立TCP三次握手
        4.握手成功后 
            浏览器向服务器发送http请求 请求数据包
        5.服务器处理收到的请求 
            将数据返回至浏览器
        6.浏览器收到HTTP响应
        7.读取页面内容 
            浏览器渲染 解析html源码
        8.生成DOM树 解析CSS样式 js交互
        9.客户端和服务器交互
        10.AJAX查询

        (DNS 建立TCP连接(三次握手) 浏览器发出读取文件HTTP请求(该请求报文作为TCP三次握手的第三个报文数据发送给服务器) 服务器对浏览器做出响应 把对应的html文本发送给浏览器 释放TCP连接 )
        1.浏览器向 DNS(Domain Name System) 服务器请求解析该 URL 中的域名所对应的 IP 地址;/域名解析 获取相应的IP地址
        2.建立TCP连接（三次握手）;
        3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
        4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
        5.释放 TCP连接（四次挥手）;
        6.浏览器将该 html 文本并显示内容;
2.浏览器渲染引擎工作流程
    1.解析HTML生成DOM树 解析CSS 生成CSSOM树 将DOM树和CSSOM树结合生成渲染树 render
    2.根据渲染树 浏览器计算出页面有哪些节点 各节点的CSS以及从属关系-回流
    3.根据渲染树以及回流得到的节点信息 计算出每个节点在屏幕中的位置-重绘
    4.最后将得到的节点位置信息交给浏览器的图形处理程序 让浏览器显示页面
    ((分析HTML元素)DOM树 (创建StyleRules CSS分析器 分析CSS文件)Rules树 (DOM树和Rules树)Render树 Layout(分析布局信息 计算坐标位置) Painting(绘制))
    (以上流程不一定会严格遵守先后顺序 有可能同时出现)
    1.创建DOM树 HTML分析器 分析HTML元素 构建一棵DOM树
    2.创建StyleRules CSS分析器 分析CSS文件 构建Rules树 生成CSSOM树
    3.创建Render树 将DOM树和Rules树关联起来 构建一颗Render树
    4.布局Layout分析布局信息 计算坐标位置
    5.绘制Painting 开始绘制
        这几个工作流程不会严格遵循先后顺序 而是有可能出现同时进行
2.重绘(Repaint)重排/回流(Reflow)是什么以及如何减少重绘、避免重排
    重排(Reflow)/回流
        1.DOM中各个元素都有自己的盒子模型，
        2.需要浏览器根据样式进行计算，
        3.并根据计算结果将元素放到特定位置，
        4.这就是Reflow
    触发Reflow条件
        1.增、删、改、移DOM
        2.修改CSS样式
        3.Resize窗口
        4.页面滚动
        5.修改网页的默认字体
        1.布局流相关操作
            1.盒模型相关操作
            2.定位相关操作
            3.浮动相关操作
        2.改变节点内的内容
        3.CSS
    重绘（Repaint)
        当节点的部分属性发生变化 但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。
        1.当各种盒子的位置、大小以及其他属性改变时，
        2.浏览器需要把这些元素都按照各自的特性绘制一遍，
        3.这个过程称为Repaint。
        table(渲染树中节点的属性值)
        table及其内部元素可能需要多次计算才能确定好其在 
        渲染树中节点的属性值，
        比同等元素要多花两倍时间
        这就是我们尽量避免使用table布局页面的原因之一
    触发Repaint的条件：
        DOM改动
        CSS改动
    回流：(重构/重排/reflow)
        当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流，每个页面至少需要回流一次，就是在页面加载的时候
    触发条件：
        任何页面布局和几何属性的改变都会触发回流
    重绘和回流：
        在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘
        回流一定会引发重绘 重绘不一定会引发回流
    重绘重排的代价：
        耗时 导致浏览器卡慢
    减少重绘、避免重排
        本质上，就是合并修改。具体的措施有：
            DOM层面：DocumentFragment本质上是一个占位符，真正插入页面的是它的所有子孙节点，所以，
                将需要变动的DOM节点先汇总到DocumentFragment，然后一次性插入，可以减少DOM操作的次数。

            CSS层面：操作多个样式时，可以先汇总到一个类中，然后一次性修改
    优化：
        1.每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。
        浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。
            但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
        2.操作时做的优化，减少对渲染树的操作，合并多次的DOM和样式修改，并减少对style样式的请求
3.window.onload的作用
    window.onload是等文档和资源都加载完成后调用的事件，
    保证js获取元素 的时候，已经加载。
4.什么是window对象? 什么是document对象?
    window是JS中最大的对象
    表示窗口，包含document
    document文档对象，表示HTML
7.OOA(Object-Oriented Analysis)：面向对象的分析
  OOD(Object-Oriented Design):面向对象的设计
  OOP(Object-Oriented Programming):面向对象编程
8.浏览器内的事件队列
    JavaScript是基于单线程运行的,同时又是异步执行的，一般来说，这种既是单线程又是异步的语言都是基于事件来驱动的，恰好浏览器就给JavaScript提供了这么一个环境

    setTimeout的等待时间结束后并不是直接执行的而是先推入浏览器的一个任务队列，在同步队列结束后再一次调用任务队列中的任务

    一般来说 浏览器会有以下几个线程
    1.js引擎线程(解释执行js代码 用户输入 网络请求)
    2.GUI线程(绘制用户界面 与js主线程是互斥的)
    3.http网络请求线程(处理用户的get,post等请求，等返回结果后将回调函数推入任务队列中)
    4.定时触发器线程(setTimeout setInterval等待时间结束后把执行函数推入任务队列中)
    5.浏览器中事件处理线程(将click mouse 等交互事件发生后 将这些事件放入事件队列中)

    当我们调用一个函数，它的地址参数局部变量都会压入一个stack中

    整个js的代码macrotask先执行 同步代码执行完后有microtask执行microtask 没有microtask执行下一个macrotask 如此往复循环至结束
9.window.open方法
    用于打开一个新的浏览器窗口或查找一个已命名的窗口
    语法
        window.open(URL,name,space,replace)
10.线程和进程有什么区别
    1.计算机的核心是CPU，它承担了所有的计算任务
    2.单个CPU一次只能运行一个任务
    3.进程它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态
    4.一个进程可以包括多个线程。
    5.一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
    6.一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
    7.一个防止其他线程使用的简单方法"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
    8.某些内存区域，只能供给固定数目的线程使用。
    操作系统的设计，因此可以归结为三点：
    （1）以多进程形式，允许多个任务同时运行；
    （2）以多线程形式，允许单个任务分成不同的部分运行；
    （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
11.HTTP缓存和CDN缓存
    HTTP缓存
        客户端缓存 浏览器作为客户端收到服务器端响应后
        对响应首部字段进行解析 分析出相应的缓存规则 
        将资源按规则进行缓存 再次请求时 如果命中缓存
        则直接读取本地缓存 不再发出请求
    缓存规则
        HTTP缓存规则由响应首部字段控制
        关键字
            确定缓存存储时间
            Expires
                HTTP1.0中用来控制缓存时间的参数
                响应头包含日期/时间
                在此时间后 响应过期

                过去的时间或无效时间 缓存但立即过期
                等同于cache-control = no-cache
                未来的时间 缓存到对应时间 
            Cache-Control
                HTTP1.1中用来控制缓存的参数
                1.public:表示响应可以被任何对象
                (包括：发送请求的客户端 代理服务器 等等)缓存
                2.private:表示响应只能被单个用户缓存
                不能用作共享缓存(即代理服务器不能缓存它)
                3.max-age=<seconds>:设置缓存存储最大周期相对请求时间缓存seconds秒 在此期间 访问资源直接读取本地缓存 不想服务器发起请求
                (与expires同时出现 max-age优先级更高)
                4.s-max-age=<seconds>:规则等同max-age 覆盖max-age/Expires头 但是仅适用于共享缓存(如各个代理)并且私有缓存中它被忽略(于expires/max-age同时出现 s-maxage优先级更高)
                5.no-store:不缓存服务器相应的任何内容 每次访问资源都要服务器完整响应
                6.no-cache:缓存资源 但立即过期 每次请求都要跟服务器对比验证资源是否被修改(等同max-age=0)
            确定缓存是否要被更新(缓存对比)
            Last-Modified
                源头服务器认定的资源做出的修改的日期及时间
                    上次修改时间 如果缓存时间过期 该字段将用于与请求中if-Modified-Since对比 一致则继续使用之前的缓存 不一致则认为缓存失效
                精度比Etag低
                包含
                if-Modified-Since
                if-Unmodified-Since
                首部的条件请求会使用这个字段
            Etag
                HTTP响应头是资源的特定版本的标识符
            缓存流程中三个问题
            1.缓存是否过期
                基于该资源上次响应缓存规则 同时满足下列条件 则视为缓存未过期 
                判断缓存是否过期只跟客户端相关 与服务端无关 
                1&2&3同时满足即认为缓存未过期 相反过期
                    1.cache-control值为max-age
                    2.max-age>0
                    3.当前data<上次请求时date+max-age
                PS:expire可同等转化为cache-control=max-age形式 s-maxage与maxage规则相同
            2.询问服务器资源是否修改
                判断资源是否修改 需要客户端与服务器共同协作 
                客户端在首次拿到资源缓存后会存储Etag(若有)
                和Last-Modified(若有) 
                在下次缓存过期时 
                会将Etag写在请求头部中的If-None-Match中
                将Last-Modified值写在请求头部中的If-Modified-Since中 
                服务端优先对Etage进行对比
                一致情况下才会继续对比Last-Modified 
                完全通过后即视为缓存没有修改
                (Last-Modified/If-Modified-Since
                Eatag/If-None-Match)
                决定返回304 告诉浏览器资源未更新 可以使用本地缓存
                有一项不通过则认为资源已被修改 缓存失效
            Etag：
                。。。
            3.缓存规则
                缓存规则主要由cache-control字段和expires字段体现 同时出现则以cache-control为准
            总结:
                对于HTTP缓存的配置 始终要做到两点
                1.清楚明白HTTP缓存的原理与规则
                2.明确缓存的配置不是一次性的
            总结:
                。。。
    CDN缓存(Content Delivery Network)内容分发网络
        CDN缓存是一种服务端缓存 
        CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上
        当用户访问相应的业务资源时
        用户会被调度至最接近的节点
        最近的节点ip返回给用户
        在web性能优化中 它主要起到了
        缓存源站压力 优化不同用户的访问速度和体验的作用
        缓存规则：
            与HTTP缓存不同的是 这个规则不是规范性的
            而是有CDN服务商来制定
            。。。
            关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的
            Cache-control: max-age 
            字段来设置CDN边缘节点数据缓存时间。
            当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。
        CDN优势:
            1.CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。
            2.大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。
        总结：
            CDN缓存的配置并不复杂 
            复杂的情况在于CDN缓存配置会受到HTTP缓存配置的影响 并且不同的CDN运营商对于这种影响的处理也都不一致
            实际使用时 建议去对应的CDN服务商文档中找到对应的注意事项
    HTTP缓存和CDN缓存结合
        。。。
        总结：
            HTTP缓存和CDN缓存分别作为客户端缓存和服务端缓存共同影响着我们的web请求流向 
            想做好缓存配置 首先清楚缓存的原理和配置规则
            其实是结合项目分析缓存级别 具体情况具体处理
    DNS缓存 查询过程
        1.首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。
        2.如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。
        3.如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。
        4.如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。
  
11.浏览器缓存
    1.前言
        1.浏览器缓存 
            是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，
            当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。
        缓存缺点
            如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。
            所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。
        缓存的优点：
            1.减少了冗余的数据传输，节省网费
            2.减少服务器的负担，提升网站性能
            3.加快了客户端加载网页的速度
    2. 缓存流程
        我们可以认为，浏览器里有一个专门存放缓存规则的一个数据库，也可以说是一个映射表，把缓存资源信息，同电脑磁盘中的实际文件的地址，对应起来。（大概意思，别较真）
        这个缓存规则的表，在浏览器中是可以看到的： chrome://cache/
        不过我升级了浏览器之后，就不好使了，但是找到了 chrome://net-internals/#httpCache ，不知道是不是就是原来的，知道的同学也可以反馈一下
        缓存规则
            声明所请求的这个资源 要采取哪种缓存策略 缓存多长时间 该规则 在HTTP的response header中的返回来的。
    3.缓存规则(强缓存/协商缓存)
        概念:
        强缓存：(不与服务器交互 直接从客户端缓存中获取)
            用户发送的请求 直接从客户端缓存中获取 不发送请求到服务器 不与服务器发生交互行为
        协商缓存：(与服务器交互 由服务器判断是否从缓存中获取资源)
            用户发送的请求 发送到服务器后 由服务器判断是否从缓存中获取资源
        共同点:
            客户端获得的数据最后都是从客户端缓存中获得
        区别：
            从名字可以直观看出 
            强缓存不与服务器交互 
            协商缓存需要与服务器端交互
        四个过程详解：
            (
                1.浏览器判断是否有缓存
                2.浏览器缓存是否过期
                3.与服务器协商是否使用缓存
                4.协商缓存
            )
            1.浏览器判定是否有缓存
                (浏览器读取本地缓存的地方是否有该对应的请求)
                客户端缓存:
                指用户设备中的本地资源 
                不同浏览器缓存文件的地址也不尽相同
                chrome为例查看浏览器缓存文件的地址
                    1.首先在chrome中输入 chrome://chrome-urls/ ，看到一堆列表 , 里面隐藏了许多浏览器的奥秘，
                    2.找到   chrome://cache （当然也可以直接输入这个地址）
                方法：
                    浏览器去读取本地放缓存的地方(不同浏览器不同系统都不同)是否由该对应的请求
            2.缓存是否过期 expires Cache-Control
                (服务器端ResponseHeader中Date字段中两个字段expires Cache-Control判断)
                客户端保留了一个服务器端的
                responseHeader
                里面的Date字段
                表明此次缓存时服务器的时间
                里面有两个字段
                expires(HTTP1.0标准 表明过期时间)
                    HTTP1.0中的标准 表明过期时间
                    PS：此处的时间都是指服务器的时间
                    存在的问题:
                        服务器时间和客户端时间的不一致
                        会导致缓存跟期待效果出现偏差
                Cache-Control(HTTP1.1标准 expires补充 相对时间概念)
                    HTTP1.1中的标准 可以看成是expires的补充
                    使用相对时间概念
                    属性配置：
                        1.max-age:(普通缓存)
                            设置缓存最大有效时间 单位为s max-age会覆盖掉Expires
                        2.s-maxage：(共享缓存)
                            只用于共享缓存 比如CDN换粗 与max-age区别 即max-age用于普通缓存
                        3.public：
                            响应会被缓存 并且在多用户间共享 默认是public
                        4.private 
                            响应只用作私有的缓存 不能在用户间共享 如果要求HTTP认证 响应会自动设置为private
                        5.no-cache 
                            指定不响应缓存 表明资源不进行缓存 但是设置no-cache之后 不代表浏览器不缓存 而是在缓存之前要向服务器确认资源是否被更改 因此有的时候只设置no-cache防止缓存还是不够保险 可以加上private指令 将过期时间设为过去时间
                        6.no-store 
                            绝对禁止缓存
                        7.must-revalidate：
                            如果页面过期 则去服务器进行获取
                判断缓存是否过期的具体步骤
                    1.查看是否有cache-control的max-age/s-maxage 
                    如果有则用服务器时间data值+max-gae/s-maxage的秒数计算出新的过期时间
                    将当前时间与过期时间进行比较 判断是否过期
                    2.没有 则用expires作为过期时间比较
            总结:判断缓存是否过期执行完成胡 如果判断未过期 则使用客户端缓存 即属于强缓存
            3.与服务器协商是否使用缓存
                到这一步的时候
                浏览器会向服务器发送请求
                同时如果上一次的缓存中有Last-modified和Etag字段
                浏览器将在request header 中加入if-Modified-Since(对应于Last-modified)
                和if-None-Match(对应于Etag)
                Last-modified:
                    表明请求的资源上次的修改时间
                If-Modified-Since：
                    客户端保留资源上次的修改时间
                Etag：
                    资源的内容标识(不唯一 通常为文件的md5或者一段hash值 只要保证写入和验证时的方法一致即可)
                If-None-Match：
                    客户端保留的资源内容标识
                PS:
                    1.分布式系统尽量关闭Etag 因为每台机器生成的Etage都不一样
                    2.分布式系统里多台机器间文件的Last-Modified必须一致 避免负荷均衡不同导致对比失败
                    通常情况下 如果同时发送if-None-Match If-Modified-Since字段 服务器只要比较Etage的内容即可 当然具体的处理方式 看服务器的约定规则
            4.协商缓存
                这个阶段 服务器一般会将Cache-control expires last-modified date etag等字段在response header中返回 便于下次缓存
                当然具体的场景 也是看服务器的约定规则设定
12.前端如何优化网站性能/前端浏览器性能优化
    (减少HTTP请求数量/利用浏览器缓存
    控制资源文件加载优先级
    减少重排/减少DOM操作
    图标从字体图标改为图片图标)
    1.减少 HTTP 请求数量
        CSS Sprites
        采用 lazyLoad
    2.利用浏览器缓存 
    3.控制资源文件加载优先级
        浏览器加载HTML内容时
        将HTML内容从上至下依次解析
        解析到link/script标签会加载href/src对应链接内容
        为第一时间展示页面给用户
        需要将CSS提前加载 不要受JS加载影响
        一般情况下都是CSS在头部 JS在尾部
    4.减少DOM操作 减少重排（Reflow）避免重排
    5.尽量外链CSS和JS(结构/表现/行为分离)
    6.图标由字体图标改成图片图标
13.浏览器有哪些内核 哪些css属性需要设置
    1.IE:Trident内核
    2.Firefox:Gecko内核
    3.Google:Blink内核
    4.Safari:Webkit内核

    -webkit- 针对safari chrome浏览器的内核css写法
    -moz- 针对firefox浏览器的内核css写法
    -ms- 针对IE内核的css写法
    -o- 针对Opera内核的css写法
14.浏览器事件循环机制
    1.基本知识点 宏任务 微任务
    2.事件循环机制过程
    3.async/await执行顺序 chrome的优化做法其实是违反了规范的
    4.node事件循环
    1.浏览器中的事件循环
        事件循环：
        JS代码执行过程中 除了依靠函数调用栈来搞定函数的执行顺序外 还依靠任务队列(task queue)来搞定另外一些代码的执行
        任务队列：
        一个线程中 事件循环是唯一的 但是任务队列可以拥有多个
        任务队列分macro-task/task(宏任务)与micro-task/jobs(微任务)
        macro-task大概包括：
            script(整体代码)
            setTimeout
            setInterval
            setImmediate
            I/O
            UI render
        micro-task大概包括：
            process.nextTick
            Promise
            async/await(实际Promise)
            MutationObserver(H5新特性)
        执行:
            1.执行宏任务
            2.执行该宏任务产生的微任务
            3.如微任务在执行过程中产生了新的微任务
                则继续执行微任务 微任务执行完毕后
                再回到宏任务 进行下一轮循环
        async/await执行顺序
            async隐式返回Promise作为结果的函数
            简单理解为
            await后面的函数执行完毕时 
            await产生一个微任务(Promise.then是微任务)
            这个微任务产生的时机
            执行完await之后 直接跳出async函数 执行其他代码
            其他代码执行完毕后 再回到async函数执行剩下的代码
            然后把await后面的代码注册到微任务队列中
15.浏览器打开一个页面前端缓存了那些东西
    前端缓存一般针对如CSS JS image等静态资源
16.前端清除缓存的几种方法
    1.meta方法 有时谷歌等浏览器不支持
    2.jquery ajax清除浏览器缓存
        1.用AJAX请求服务器最新文件 并加上请求头if-Modified-Since和Cache-Control
        2.直接用cache:false
    3.随机数
        url参数后面加上"?ran="+Math.random()
    4.随机时间类似随机数
        url参数后面加上"?timestamp="+new Date().getTime();
    5.用php后端处理
        在url参数后加上在服务器端加
        header("Cache-Control:no-cache,must-revalidate")
17.如何避免页面上商品价格被爬取到
    1.价格信息AJAX获取
    2.价格设置图片
    3.JS对价格加密再解密
    4.字体加密 如#xf076对应100
18.前端常用的几种弹窗函数
    1.alert('')弹窗 提示
        主要作为提示
        一般经常用来测试JS某段代码是否出错
    2.confirm('')弹窗 判断是否进行某一个操作
        点击确定 返回true
        点击取消 返回false
        点击确定/取消按钮关闭前 将阻止用户对浏览器的所有输入       
    3.prompt('')弹窗 用于输入文本内容 
        用于显示可提示用户进行输入的对话框
        用户单击取消按钮 返回null
        单击确认按钮 返回输入的文本
        点击确定或取消关闭之前
        它将阻止用户对浏览器的所有输入
        调用prompt()时 用户做出响应之前 不会执行下一条语句
    4.HTML+CSS+JS实现浏览器弹窗
        click控制div.style.display为block/none        
19.前端文件上传功能
    Web浏览器上传文件一般有以下几种方式
        1.form表单上传文件
        2.原生js实现ajax上传文件
        3.jquery实现ajax上传文件
        4.form+iframe上传文件
    form提交数据后会整个刷新页面
    原生js实现ajax上传文件 
        不会刷新整个页面
        它们都是通过使用formdata对象实现的
        formdata对象在老版本的浏览器中并不支持
    为了兼容老版本浏览器 
        使用iframe方式提交
20.Web标准及W3C理解认识
    Web标准简单来说可以分为
    结构：
        主要由HTML标签组成
    表现：
        CSS样式表
    行为:
        页面和用户交互
    Web标准一般将该三部分独立分开 使其更具有模块化
    一般产生行为时 会有结构或表现的变化 使该三者界限不够清晰
    W3C对Web标准提出规范化要求
        即实际编码中一些代码规范
        1.结构要求
            (标签规范可以提高搜索引擎对页面的抓取效率 对SEO较有帮助)
            1.标签字母小写
            2.标签闭合
            3.标签不允许随意嵌套
        2.CSS/JS
            1.尽量使用外链CSS样式表和JS脚本 
                使结构表现行为分三块 符合规范 同时提高页面渲染速度 提高用户体验
            2.样式尽量少使用行内样式 使结构和表现分离 标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版
            3.不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。
21.WebGL-Web Graphics Library 
    一种3D绘图协议
22.浏览器内核
    浏览器内核
        (浏览器内核不同 对网页的语法解释不同 渲染效果不同)
        (所有网页浏览器 电子邮件客户端及其他需要编辑 显示网络内容的应用程序都需内核)
        渲染引擎Layout Engineer/Rendering Engine
            取得网页的内容(HTML/XML/图像等)
            整理讯息(如加入CSS)
            计算网页显示方式
            输出至显示器/打印机
        JS引擎
            解析执行JS实现网页动态效果
    常见的浏览器内核
        Trident:IE 360 搜狗
        Gecko:Netscape6及以上版本
        Presto:Opera
        Blink:Opera
        Webkit:Safari Chrome
    最开始渲染引擎和JS引擎没有区分很明确
    后来JS引擎越来越独立 内核就倾向于只指渲染引擎
23.面向切面编程 函数式编程
    面向切面编程
    函数式编程
        引入了纯函数的概念来帮助编程，纯函数对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。它是一种编程范式。RXJS用到了它。
24.前端性能优化
    资源加载优化
        1.减少资源
        2.减少HTTP请求次数
        3.提高HTTP响应速度
        4.优化资源加载实际
        5.优化加载方式
    页面渲染优化
        JS-Style-Layout-Paint-Composite
        基于浏览器渲染原理
        主要在代码层优化
        1.优化HTML代码
            对页面整体结构的优化
            尽快生成DOM树 CSSOM 触发渲染 不要发生阻塞情况
            将像素管道中的Style和Layout尽可能提前
        2.优化JS和CSS代码
            优化JS
                减轻主线程压力 防止主线程因长时间执行JS代码
                阻塞页面渲染 即减少像素管道中的JS耗时
            优化CSS
                减少像素管道中Style的耗时 尽量减少重排避免重绘
                方式像素管道被中断然后从头再次触发
            优化动画效果
                尽可能跳过上述像素管道中的Layout和Paint
        3.优化动画效果
25.前端首屏优化
    CSR
        优点:
            不依赖数据FP事件
            最快 客户端用户体验好
            内存数据共享
        缺点：
            SEO不友好
            FCP FMP慢
    预渲染
        优点:
            不依赖数据FCP事件
            比CSR块 客户端用户体验好
            内存数据共享
        缺点：
            SEO不友好
            FMP慢
    SSR
        优点：
            SEO友好
            首屏性能高
            FMP比CSR和预渲染快
        缺点:
            客户端数据共享成本高
            模板维护成本高
    同构
        优点：
            SEO友好
            首屏性能高
            FMP比CSR和预渲染快
            客户端用户体验好
            内存数据共享
            客户端和服务器端代码公用
            开发效率高
        缺点：
            Node容易形成性能瓶颈
    解释:
        FP:仅有一个div根节点
        FCP：包含页面的基本框架 没有数据内容
        FMP：包含页面所有元素及数据




























