1.浏览器输入url后发生了什么
    1.缓存解析
        1.浏览器缓存：浏览器会记录DNS一段事件 因此 只是第一个地方解析DNS请求
        2.操作系统缓存： 如果在浏览器缓存中不包含这个记录 则会使系统调用操作系统 获取操作系统记录(保存最近的DNS查询缓存)
        3.路由器缓存：如果上述两个步骤均不能成功获取DNS记录 继续搜索路由器缓存
        4.ISP缓存：若上述均失败 继续向ISP搜索
    2.域名解析 解析获取相应的ip地址
    3.浏览器像服务器发出TCP连接 与浏览器建立TCP三次握手
    4.握手成功后 浏览器向服务器发送http请求 请求数据包
    5.服务器处理收到的请求 将数据返回至浏览器
    6.浏览器收到HTTP响应
    7.读取页面内容 浏览器渲染 解析html源码
    8.生成DOM树 解析CSS样式 js交互
    9.客户端和服务器交互
    10.AJAX查询
    (DNS 建立TCP连接(三次握手) 浏览器发出读取文件HTTP请求(该请求报文作为TCP三次握手的第三个报文数据发送给服务器) 服务器对浏览器做出响应 把对应的html文本发送给浏览器 释放TCP连接 )
    1.浏览器向 DNS(Domain Name System) 服务器请求解析该 URL 中的域名所对应的 IP 地址;/域名解析 获取相应的IP地址
    2.建立TCP连接（三次握手）;
    3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
    4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
    5.释放 TCP连接（四次挥手）;
    6.浏览器将该 html 文本并显示内容;
2.浏览器渲染引擎工作流程
    ((分析HTML元素)DOM树 (创建StyleRules CSS分析器 分析CSS文件)Rules树 (DOM树和Rules树)Render树 Layout(分析布局信息 计算坐标位置) Painting(绘制))
    (以上流程不一定会严格遵守先后顺序 有可能同时出现)
    1.创建DOM树 HTML分析器 分析HTML元素 构建一棵DOM树
    2.创建StyleRules CSS分析器 分析CSS文件 构建Rules树
    3.创建Render树 将DOM树和Rules树关联起来 构建一颗Render树
    4.布局Layout分析布局信息 计算坐标位置
    5.绘制Painting 开始绘制
        这几个工作流程不会严格遵循先后顺序 而是有可能出现同时进行
2.重绘(Repaint)重排(Reflow)是什么以及如何减少重绘、避免重排
    重排
        DOM中各个元素都有自己的盒子模型，需要浏览器根据样式进行计算，并根据计算结果将元素放到特定位置，这就是Reflow
    触发条件
        增、删、改、移DOM
        修改CSS样式
        Resize窗口
        页面滚动
        修改网页的默认字体
    重绘（Repaint)
        当各种盒子的位置、大小以及其他属性改变时，浏览器需要把这些元素都按照各自的特性绘制一遍，这个过程称为Repaint。table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍事件，这就是我们尽量避免使用table布局页面的原因之一
    触发Repaint的条件：
        DOM改动
        CSS改动
    回流：(重构/重排/reflow)
        当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流，每个页面至少需要回流一次，就是在页面加载的时候
    触发条件：
        任何页面布局和几何属性的改变都会触发回流
    重绘和回流：
        在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘
        即 回流一定会引发重绘 重绘不一定会引发回流
    重绘重排的代价：
        耗时 导致浏览器卡慢
    减少重绘、避免重排
        本质上，就是合并修改。具体的措施有：
            DOM层面：DocumentFragment本质上是一个占位符，真正插入页面的是它的所有子孙节点，所以，将需要变动的DOM节点先汇总到DocumentFragment，然后一次性插入，可以减少DOM操作的次数。
            CSS层面：操作多个样式时，可以先汇总到一个类中，然后一次性修改
    优化：
        1.浏览器自己的优化，浏览器会维护一个队列，把所有会引起回流，重绘的操作放入这个队列，等队列中的操作到了一i的那个数量或者一定时间间隔，浏览器就会flush队列，尽心一个批处理，这样就会让多次的回流重绘变成一次回流重绘
        2.操作时做的优化，减少对渲染树的操作，合并多次的DOM和样式修改，并减少对style样式的请求
3.window.onload的作用
window.onload是等文档和资源都加载完成后调用的事件，保证js获取元素 的时候，已经加载。
4.什么是window对象? 什么是document对象?
    window是js中最大的对象，表示窗口，包含document
    document文档对象，表示HTML
7.OOA(Object-Oriented Analysis)：面向对象的分析
  OOD(Object-Oriented Design):面向对象的设计
  OOP(Object-Oriented Programming):面向对象编程
8.浏览器内的事件队列
    JavaScript是基于单线程运行的,同时又是异步执行的，一般来说，这种既是单线程又是异步的语言都是基于事件来驱动的，恰好浏览器就给JavaScript提供了这么一个环境

    setTimeout的等待时间结束后并不是直接执行的而是先推入浏览器的一个任务队列，在同步队列结束后再一次调用任务队列中的任务

    一般来说 浏览器会有以下几个线程
    1.js引擎线程(解释执行js代码 用户输入 网络请求)
    2.GUI线程(绘制用户界面 与js主线程是互斥的)
    3.http网络请求线程(处理用户的get,post等请求，等返回结果后将回调函数推入任务队列中)
    4.定时触发器线程(setTimeout setInterval等待时间结束后把执行函数推入任务队列中)
    5.浏览器中事件处理线程(将click mouse 等交互事件发生后 将这些事件放入事件队列中)

    当我们调用一个函数，它的地址参数局部变量都会压入一个stack中

    整个js的代码macrotask先执行 同步代码执行完后有microtask执行microtask 没有microtask执行下一个macrotask 如此往复循环至结束
9.window.open方法
