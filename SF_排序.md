基础排序算法：
    1.冒泡排序 最好O(n) 最坏O(n^2) 平均(n^2)
    2.插入排序 最好O(n) 最坏O(n^2) 平均(n^2)
    3.选择排序 都是O(n^2)
进阶排序算法(分治)
    4.归并排序 O(nlog(n))
    5.快速排序 最好O(nlog(n)) 最坏O(n^2) 平均(nlog(n))
1.冒泡排序
时间复杂度
    1.最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)
    2.最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)
    3.平均时间复杂度：这个东西比较难搞，它涉及到一些概率论的知识。实际面试的时候也不会有面试官摁着你让你算这个，这里记住平均时间复杂度是 O(n^2) 即可。

基本思路分析
冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动。
每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了。

基本冒泡思路编码实现
function bubbleSort(arr) {
    // 缓存数组长度
    const len = arr.length  
    // 外层循环用于控制从头到尾的比较+交换到底有多少轮
    for(let i=0;i<len;i++) {  
        // 内层循环用于完成每一轮遍历过程中的重复比较+交换
        for(let j=0;j<len-1;j++) {
            // 若相邻元素前面的数比后面的大
            if(arr[j] > arr[j+1]) {  
                // 交换两者
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
            }
        }
    }
    // 返回数组
    return arr
}

基本冒泡思路的改进

楼上基本冒泡思路的问题在于，没有区别处理这一部分已经有序的元素，而是把它和未排序的部分做了无差别的处理，进而造成了许多不必要的比较。
为了避免这些冗余的比较动作，我们需要规避掉数组中的后 n 个元素，对应的代码可以这样写：

改进版冒泡排序的编码实现
function betterBubbleSort(arr) {
    const len = arr.length  
    for(let i=0;i<len;i++) {
        // 注意差别在这行，我们对内层循环的范围作了限制
        for(let j=0;j<len-1-i;j++) {
            if(arr[j] > arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
            }
        }
    }
    return arr
}

面向“最好情况”的进一步改进
function betterBubbleSort(arr) {
    const len = arr.length  
    
    for(let i=0;i<len;i++) {
        // 区别在这里，我们加了一个标志位
        let flag = false
        for(let j=0;j<len-1-i;j++) {
            if(arr[j] > arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
                // 只要发生了一次交换，就修改标志位
                flag = true
            }
        }
        
        // 若一次交换也没发生，则说明数组有序，直接放过
        if(flag == false)  return arr;
    }
    return arr
}
标志位可以帮助我们在第一次冒泡的时候就定位到数组是否完全有序，进而节省掉不必要的判断逻辑，将最好情况下的时间复杂度定向优化为 O(n)。

2.冒泡排序
思路分析
选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。

真实排序过程演示
下面我们尝试基于选择排序的思路，对如下数组进行排序：

[5, 3, 2, 4, 1]
首先，索引范围为 [0, n-1] 也即 [0,4] 之间的元素进行的遍历（两个箭头分别对应当前范围的起点和终点）：

[5, 3, 2, 4, 1]
 ↑           ↑
得出整个数组的最小值为 1。因此把1锁定在当前范围的头部，也就是和 5 进行交换：

[1, 3, 2, 4, 5]
交换后，数组的第一个元素值就明确了。接下来需要排序的是 [1, 4] 这个索引区间：

[1, 3, 2, 4, 5]
    ↑        ↑
遍历这个区间，找出区间内最小值为 2。因此区间头部的元素锁定为 2，也就是把 2 和 3 交换。相应地，将需要排序的区间范围的起点再次后移一位，此时区间为 [2, 4]：

[1, 2, 3, 4, 5]
       ↑     ↑
遍历 [2,4] 区间，得到最小值为 3。3 本来就在当前区间的头部，因此不需要做额外的交换。
以此类推，4会被定位为索引区间 [3,4] 上的最小值，仍然是不需要额外交换的。

基于这个思路，我们来写代码：

编码示范
function selectSort(arr)  {
  // 缓存数组长度
  const len = arr.length 
  // 定义 minIndex，缓存当前区间最小值的索引，注意是索引
  let minIndex  
  // i 是当前排序区间的起点
  for(let i = 0; i < len - 1; i++) { 
    // 初始化 minIndex 为当前区间第一个元素
    minIndex = i  
    // i、j分别定义当前区间的上下界，i是左边界，j是右边界
    for(let j = i; j < len; j++) {  
      // 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j
      if(arr[j] < arr[minIndex]) {  
        minIndex = j
      }
    }
    // 如果 minIndex 对应元素不是目前的头部元素，则交换两者
    if(minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
  }
  return arr
}
3.插入排序
思路分析
插入排序的核心思想是“找到元素在它前面那个序列中的正确位置”。
具体来说，插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。

真实排序过程演示
下面我们尝试基于插入排序的思路，对如下数组进行排序：

[5, 3, 2, 4, 1]
首先，单个数字一定有序，因此数组首位的这个 5 可以看做是一个有序序列。在这样的前提下， 我们就可以选中第二个元素 3 作为当前元素，思考它和前面那个序列 [5] 之间的关系。很明显， 3 比 5 小，注意这里按照插入排序的原则，靠前的较大数字要为靠后的较小数字腾出位置：

[暂时空出, 5, 2, 4, 1]
当前元素 3
再往前看，发现没有更小的元素可以作比较了。那么现在空出的这个位置就是当前元素 3 应该待的地方：

[3, 5, 2, 4, 1]
以上我们就完成了一轮插入。这一轮插入结束后，大家会发现，有序数组 [5] 现在变成了有序数组 [3, 5]——这正是插入排序的用意所在，通过正确地定位当前元素在有序序列里的位置、不断扩大有序数组的范围，最终达到完全排序的目的。

沿着这个思路，继续往下走，当前元素变成了紧跟[3, 5] 这个有序序列的 2。对比 2 和 5 的大小，发现 2 比 5 小。按照插入排序的原则，5要往后挪，给较小元素空出一个位置：

[3, 暂时空出, 5, 4, 1]
当前元素 2
接着继续向前对比，遇到了 3。对比 3 和 2 的大小，发现 3 比 2 大。按照插入排序的原则，3要往后挪，给较小元素空出一个位置：

[暂时空出, 3, 5, 4, 1]
当前元素 2
此时 2 前面的有序序列已经被对比完毕了。我们把 2 放到最终空出来的那个属于它的空位里去：

[2, 3, 5, 4, 1]
以上我们完成了第二轮插入。这一轮插入结束后，有序数组 [3, 5] 现在变成了有序数组 [2, 3, 5]。

继续往下走，紧跟有序数组 [2, 3, 5] 的元素是 4。仍然是从后往前，首先对比 4 和 5 的大小，发现 4 比 5 小，那么 5 就要为更小的元素空出一个位置：

[2, 3, 暂时空出, 5, 1]
当前元素 4
向前对比，遇到了 3。因为 4 比 3 大，符合从小到大的排序原则；同时已知当前这个序列是有序的，3 前面的数字一定都比 3 小，再继续向前查找就没有意义了。因此当前空出的这个坑就是 4 应该待的地方：

[2, 3, 4, 5, 1]
以此类推，最后一个元素 1 会被拱到 [2, 3, 4, 5] 这个序列的头部去，最终数组得以完全排序：

[1, 2, 3, 4, 5]
分析至此，再来帮大家复习一遍插入排序里的几个关键点：

当前元素前面的那个序列是有序的
“正确的位置”如何定义——所有在当前元素前面的数都不大于它，所有在当前元素后面的数都不小于它
在有序序列里定位元素位置的时候，是从后往前定位的。只要发现一个比当前元素大的值，就需要为当前元素腾出一个新的坑位。
基于这个思路，我们来写代码：

编码实现
function insertSort(arr) {
  // 缓存数组长度
  const len = arr.length
  // temp 用来保存当前需要插入的元素
  let temp  
  // i用于标识每次被插入的元素的索引
  for(let i = 1;i < len; i++) {
    // j用于帮助 temp 寻找自己应该有的定位
    let j = i
    temp = arr[i]  
    // 判断 j 前面一个元素是否比 temp 大
    while(j > 0 && arr[j-1] > temp) {
      // 如果是，则将 j 前面的一个元素后移一位，为 temp 让出位置
      arr[j] = arr[j-1]   
      j--
    }
    // 循环让位，最后得到的 j 就是 temp 的正确索引
    arr[j] = temp
  }
  return arr
}
认识“分治”思想
本节我们要学习的两个排序算法都是对“分治”思想的应用。
“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解。

利用分治思想解决问题，我们一般分三步走：

分解子问题
求解每个子问题
合并子问题的解，得出大问题的解
下面我们一起来看看分治思想是如何帮助我们提升排序算法效率的。
4.归并排序
思路分析
归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：

分解子问题：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
求解每个子问题：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
合并子问题的解，得出大问题的解：当数组被合并至原有的规模时，就得到了一个完全排序的数组
真实排序过程演示
下面我们基于归并排序的思路，尝试对以下数组进行排序：

[8, 7, 6, 5, 4, 3, 2, 1]
首先重复地分割数组，整个分割过程如下：
首次分割，将数组整个对半分：

[8, 7, 6, 5,| 4, 3, 2, 1]
二次分割，将分割出的左右两个子数组各自对半分：

[8, 7,| 6, 5,| 4, 3,| 2, 1]
三次分割，四个子数组各自对半分后，每个子数组内都只有一个元素了：

[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]
接下来开始尝试解决每个子问题。将规模为1的子数组两两合并为规模为2的子数组，合并时确保有序，我们会得到这样的结果：

[7, 8,| 5, 6,| 3, 4,| 1, 2]
继续将规模为2的按照有序原则合并为规模为4的子数组：

[5, 6, 7, 8,| 1, 2, 3, 4]  
最后将规模为4的子数组合并为规模为8的数组：

[1, 2, 3, 4, 5, 6, 7, 8]  
整个数组就完全有序了。

编码实现
通过上面的讲解，我们可以总结出归并排序中的两个主要动作：

分割
合并
这两个动作是紧密关联的，分割是将大数组反复分解为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。整个过程符合两个特征：

重复（令人想到递归或迭代）
有去有回（令人想到回溯，进而明确递归这条路）
因此，归并排序在实现上依托的就是递归思想。
除此之外，这里还涉及到另一个小小的知识点——两个有序数组的合并。合并有序数组是咱们在第 7 节讲过的一道真题，涉及到双指针法。此处强烈建议印象模糊的同学回头复习一下完整的解题思路。

编码实现
function mergeSort(arr) {
    const len = arr.length
    // 处理边界情况
    if(len <= 1) {
        return arr
    }   
    // 计算分割点
    const mid = Math.floor(len / 2)    
    // 递归分割左子数组，然后合并为有序数组
    const leftArr = mergeSort(arr.slice(0, mid)) 
    // 递归分割右子数组，然后合并为有序数组
    const rightArr = mergeSort(arr.slice(mid,len))  
    // 合并左右两个有序数组
    arr = mergeArr(leftArr, rightArr)  
    // 返回合并后的结果
    return arr
}
  
function mergeArr(arr1, arr2) {  
    // 初始化两个指针，分别指向 arr1 和 arr2
    let i = 0, j = 0   
    // 初始化结果数组
    const res = []    
    // 缓存arr1的长度
    const len1 = arr1.length  
    // 缓存arr2的长度
    const len2 = arr2.length  
    // 合并两个子数组
    while(i < len1 && j < len2) {
        if(arr1[i] < arr2[j]) {
            res.push(arr1[i])
            i++
        } else {
            res.push(arr2[j])
            j++
        }
    }
    // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
    if(i<len1) {
        return res.concat(arr1.slice(i))
    } else {
        return res.concat(arr2.slice(j))
    }
}




基于数学计算的分析
我们假设规模为 n 的数组对应的排序的时间复杂度是一个关于 n 的函数 F(n)。那么它和自己的两个子数组之间就有如下关系：

F(n) = F(n/2) + F(n/2) + 合并两个数组的时间
合并两个数组的过程一共要对 n 个元素进行一轮循环，因此时间复杂度可以目测出来是 O(n)，代入上面公式：

F(n) = F(n/2) + F(n/2) + O(n) = 2^1*T(n/2)+2^0*O(n)
继续细分，两个子数组被划分为四个子数组，仍然遵循上面公式所描述的关系。代入 n/4 后可以得到四个子数组和大数组之间的关系：

F(n/2) = 2*F(n/4)+O(n)   

F(n) = 2*(2*F(n/4)+O(n))+O(n) = 2^2*F(n/4)+2^1*O(n)
这样不断划分下去，直到每个序列里只有一个数位置。对于规模为 n 的数组来说，需要划分的次数为 log(n)，用 log(n) 替换掉上述公式中的2的次数，我们就可以得到归并排序的时间复杂度：

F(n) = nF(1) + O(nlog(n)) = O(nlog(n))
综上所述， 归并排序的时间复杂度是 O(nlog(n))。

基于逻辑的分析
如果上面的数学公式让你感到不友好，那么我们通过简单的逻辑估算，也可以得出归并排序的时间复杂度：
逻辑估算的核心思想是“抓主要矛盾”。我们可以回顾一下归并排序的代码：

function mergeSort(arr) {
    const len = arr.length
    // 处理边界情况
    if(len <= 1) {
        return arr
    }   
    // 计算分割点
    const mid = Math.floor(len / 2)    
    // 递归分割左子数组，然后合并为有序数组
    const leftArr = mergeSort(arr.slice(0, mid)) 
    // 递归分割右子数组，然后合并为有序数组
    const rightArr = mergeSort(arr.slice(mid,len))  
    // 合并左右两个有序数组
    arr = mergeArr(leftArr, rightArr)  
    // 返回合并后的结果
    return arr
}
  
function mergeArr(arr1, arr2) {  
    // 初始化两个指针，分别指向 arr1 和 arr2
    let i = 0, j = 0   
    // 初始化结果数组
    const res = []    
    // 缓存arr1的长度
    const len1 = arr1.length  
    // 缓存arr2的长度
    const len2 = arr2.length  
    // 合并两个子数组
    while(i < len1 && j < len2) {
        if(arr1[i] < arr2[j]) {
            res.push(arr1[i])
            i++
        } else {
            res.push(arr2[j])
            j++
        }
    }
    // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
    if(i<len1) {
        return res.concat(arr1.slice(i))
    } else {
        return res.concat(arr2.slice(j))
    }
}
我们把每一次切分+归并看做是一轮。对于规模为 n 的数组来说，需要切分 log(n) 次，因此就有 log(n) 轮。
每一轮中，切分动作都是小事情，只需要固定的几步：

 // 计算分割点
const mid = Math.floor(len / 2)    
// 递归分割左子数组，然后合并为有序数组
const leftArr = mergeSort(arr.slice(0, mid)) 
// 递归分割右子数组，然后合并为有序数组
const rightArr = mergeSort(arr.slice(mid,len))
因此单次切分对应的是常数级别的时间复杂度 O(1)。

再看合并，单次合并的时间复杂度为 O(n)。O(n) 和 O(1) 完全不在一个复杂度量级上，因此本着“抓主要矛盾”的原则，我们可以认为：决定归并排序时间复杂度的操作就是合并操作。

log(n) 轮对应 log(n) 次合并操作，因此归并排序的时间复杂度就是 O(nlog(n))。

以上两种时间复杂度的计算思路，大家理解其中一种即可，不必死磕。

5.快速排序
快速排序在基本思想上和归并排序是一致的，仍然坚持“分而治之”的原则不动摇。区别在于，快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序。

思路分析
快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。
这个描述对初学者来说可能会比较抽象，我们直接通过真实排序的过程来理解它：

真实排序过程演示
首先要做的事情就选取一个基准值。基准值的选择有很多方式，这里我们选取数组中间的值：

[5, 1, 3, 6, 2, 0, 7]
 ↑       基准      ↑
左右指针分别指向数组的两端。接下来我们要做的，就是先移动左指针，直到找到一个不小于基准值的值为止；然后再移动右指针，直到找到一个不大于基准值的值为止。
首先我们来看左指针，5比6小，故左指针右移一位：

[5, 1, 3, 6, 2, 0, 7]
    ↑    基准      ↑
继续对比，1比6小，继续右移左指针：

[5, 1, 3, 6, 2, 0, 7]
       ↑ 基准      ↑
继续对比，3比6小，继续右移左指针，左指针最终指向了基准值：

[5, 1, 3, 6, 2, 0, 7]
         基准      ↑
          ↑
此时由于 6===6，左指针停止移动。开始看右指针：
右指针指向7，7>6，故左移右指针：

[5, 1, 3, 6, 2, 0, 7]
         基准   ↑
          ↑
发现 0 比 6 小，停下来，交换 6 和 0，同时两个指针共同向中间走一步：

[5, 1, 3, 0, 2, 6, 7]
             ↑ 基准
             ↑   
此时 2 比 6 小，故右指针不动，左指针继续前进：

[5, 1, 3, 0, 2, 6, 7]
             ↑ 基准
           right↑
               left   
此时右指针所指的值不大于 6，左指针所指的值不小于 6，故两个指针都不再移动。此时我们会发现，对于左指针所指的数字来说，它左边的所有数字都比它小，右边的所有数字都比它大（这里注意也可能存在相等的情况）。由此我们就能够以左指针为轴心，划分出一左一右、一小一大两个子数组：

[5, 1, 3, 0, 2]   
[6, 7]
针对两个子数组，重复执行以上操作，直到数组完全排序为止。这就是快速排序的整个过程。

编码实现
// 快速排序入口
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 定义递归边界，若数组只有一个元素，则没有排序必要
  if(arr.length > 1) {
      // lineIndex表示下一次划分左右子数组的索引位
      const lineIndex = partition(arr, left, right)
      // 如果左边子数组的长度不小于1，则递归快排这个子数组
      if(left < lineIndex-1) {
        // 左子数组以 lineIndex-1 为右边界
        quickSort(arr, left, lineIndex-1)
      }
      // 如果右边子数组的长度不小于1，则递归快排这个子数组
      if(lineIndex<right) {
        // 右子数组以 lineIndex 为左边界
        quickSort(arr, lineIndex, right)
      }
  }
  return arr
}
// 以基准值为轴心，划分左右子数组的过程
function partition(arr, left, right) {
  // 基准值默认取中间位置的元素
  let pivotValue = arr[Math.floor(left + (right-left)/2)]
  // 初始化左右指针
  let i = left
  let j = right
  // 当左右指针不越界时，循环执行以下逻辑
  while(i<=j) {
      // 左指针所指元素若小于基准值，则右移左指针
      while(arr[i] < pivotValue) {
          i++
      }
      // 右指针所指元素大于基准值，则左移右指针
      while(arr[j] > pivotValue) {
          j--
      }

      // 若i<=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序
      if(i<=j) {
          swap(arr, i, j)
          i++
          j--
      }

  }
  // 返回左指针索引作为下一次划分左右子数组的依据
  return i
}

// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]]
}
编码复盘——快速排序的时间复杂度分析
快速排序的时间复杂度的好坏，是由基准值来决定的。

最好时间复杂度：它对应的是这种情况——我们每次选择基准值，都刚好是当前子数组的中间数。这时，可以确保每一次分割都能将数组分为两半，进而只需要递归 log(n) 次。这时，快速排序的时间复杂度分析思路和归并排序相似，最后结果也是 O(nlog(n))。
最坏时间复杂度：每次划分取到的都是当前数组中的最大值/最小值。大家可以尝试把这种情况代入快排的思路中，你会发现此时快排已经退化为了冒泡排序，对应的时间复杂度是 O(n^2)。
平均时间复杂度： O(nlog(n))















