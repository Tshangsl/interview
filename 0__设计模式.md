##### 设计模式
> 三类 23种 六大原则
5. 装饰器模式
> 允许向一个现有的对象添加新的功能 同时又不改变其结构 这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装，这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能
> 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能
6. 策略模式
> 策略模式中 一个类的行为或其算法可以在运行时更改 这种类型的设计模式属于行为型模式 策略模式中 创建各种表示策略的对象和一个行为随着策略对象改变而改变的context对象 策略对象改变context对象的执行算法
7. 模版模式
> 模版模式中 一个抽象类公开定义了执行它的方法的方式/模版 它的子类可以按需要重写方法实现 但调用将以抽象类中定义的方式进行 这种类型的设计模式属于行为型模式

0. 观察者模式和发布订阅模式
    1. 观察者模式
        - 为了实现松耦合 使用观察者模式 面向接口编程 实现松耦合
        - 观察者模式中 changed()方法所在的实例对象 就是被观察者(Subject 或者叫Observer) 它只需维护一套观察者(Observer)的集合 这些Observer实现相关的借口 subject只需知道 通知Observer时 调用哪个统一方法
    2. 发布订阅模式
        - 发布订阅模式中 发布者不会直接通知订阅者 发布者和订阅者彼此不认识
        - 交流通过第三方 消息队列中经纪人Broker
        - 发布订阅者模式中 发布者和订阅者 不是松耦合 而是完全解耦
    - 发布订阅模式(Publish-subscribe pattern) 
        - Producer Borker Consumer
        - 订阅者(Subscriber)把自己想订阅的事件注册(Subscribe)到调度中心(Topic)当发布者(Publisher)发布该事件(Publish topic)到调度中心 也就是该事件触发时 由调度中心统一调度(Fire Event) 订阅者注册到调度中心的处理代码
    - 观察者模式(Observer pattern)
        - Observer Observable
        - 观察者(Observer)直接订阅(Subscribe)主题(Subject) 当主体被激活时 会触发(Fire Event)观察者中的事件
    > 总结

    - 表面
        1. 观察者模式中 只有两个角色 观察者+被观察者
        2. 发布订阅模式中 不仅仅只有发布者和订阅者还有经纪人Brokder
    - 深层次
        1. 观察者和被观察者是松耦合的关系
        2. 发布者和订阅者 完全不存在耦合
    - 使用层面
        1. 观察者模式 多用于单个应用内部
        2. 发布定于模式 更多是一种跨应用的模式 如常用的消息中间件
### (面向对象23种软件)设计模式：(七大设计原则的具体实现)
- (目的：
    增强代码 可复用性、可维护性、可读性、稳健性、安全性
    程序低耦合，高复用，高内聚，易扩展，易维护。
)
- (1995 GoF 设计模式 Gang of Four 四人组/四人帮 
《设计模式：可复用面向对象软件的基础》)
(引入设计模式是为了使设计简单 
设计模式是针对软件设计的
软件设计是针对需求的
一定不要为了使用设计模式而使用设计模式)
- (实际应用中，通常多个设计模式混合使用)
- (七大设计原则 
    - 目的:降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。
    1. 开闭原则
        对扩展开放，对修改关闭 
        降低维护带来的新风险
    2. 里氏替换原则
        不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义
        防止继承泛滥
    3. 依赖倒置原则
        高层不应该依赖低层，要面向接口编程
        更利于代码结构的升级扩展
    4. 单一职责原则
        一个类只干一件事，实现类要单一
        便于理解，提高代码的可读性
    5. 接口隔离原则
        一个接口只干一件事，接口要精简单一
        功能解耦，高聚合、低耦合
    6. 迪米特法则
        不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度
        只和朋友交流，不和陌生人说话，减少代码臃肿
    7. 合成复用原则
        尽量使用组合或者聚合关系实现代码复用，少使用继承
        降低代码耦合
)
- (23种设计模式
    > 目的分类:
    1. 创建型模式：5种
        > 用于描述 怎样创建对象 主要特点是 将对象的创建与使用分离
        1. 单例 Singleton
            > 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
        2. 原型 Prototype
            > 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
        3. 工厂方法 Factory Method
            > 定义一个用于创建产品的接口，由子类决定生产什么产品。
        4. 抽象工厂 AbstractFactory
            > 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
        5. 建造者 Builder
            > 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
    2. 结构型模型: 7种
        > 用于描述 如何将类或对象按某种布局组成更大的结构
        1. 代理 Proxy
            > 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
        2. 适配器 Adapters
            > 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
        3. 桥接 Bridge
            > 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
        4. 装饰 Decorator
            > 动态的给对象增加一些职责，即增加其额外的功能。
        5. 外观 Facade
            > 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
        6. 享元 Flyweight
            > 运用共享技术来有效地支持大量细粒度对象的复用。
        7. 组合 Composite
            > 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
    3. 行为型模式：11种
        > 用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。
        1. 模板方法 TemplateMethod
            定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
        2. 策略 Strategy
            定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
        3. 命令 Command
            将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
        4. 职责链 Chain of Responsibility
            把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
        5. 状态 State
            允许一个对象在其内部状态发生改变时改变其行为能力。
        6. 观察者 Observer
            多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
            观察者模式属于行为型模式 行为型模式关注的是对象间的通讯 观察者模式就是观察者和被观察者之间的通讯
        7. 中介者 Mediator
            定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
        8. 迭代器 Iterator
            提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
        9. 访问者 Visitor
            在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
        10. 备忘录 Memento
            在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
        11. 解释器 Interpreter
            提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
    > 作用范围分类
    1. 类模式
        用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的 在编译时刻便确定下来了
        1. 工厂方法
        2. （类）适配器
        3. 模板方法
        4. 解释器
    2. 对象模式
        用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。
        GoF 中除了以上 4 种，其他的都是对象模式。
)
- 本质
    > 是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。
- 分类：
    > 两种分类方法
    1. 根据模式目的
        1.创建型模式
        2.结构型模式
        3.行为型模式
    2. 根据模式作用范围
        1.类模式
        2.对象模式
- 23种设计模式功能：
    1. 单例（Singleton）模式：
        >某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
    2. 原型（Prototype）模式：
        > 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
    3. 工厂方法（Factory Method）模式：
        > 定义一个用于创建产品的接口，由子类决定生产什么产品。
    4. 抽象工厂（AbstractFactory）模式：
        > 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
    5. 建造者（Builder）模式：
        > 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
    6. 代理（Proxy）模式：
        > 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
    7. 适配器（Adapter）模式：
        > 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
    8. 桥接（Bridge）模式：
        > 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
    9. 装饰（Decorator）模式：
        > 动态的给对象增加一些职责，即增加其额外的功能。
    10. 外观（Facade）模式：
        > 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
    11. 享元（Flyweight）模式：
        > 运用共享技术来有效地支持大量细粒度对象的复用。
    12. 组合（Composite）模式：
        > 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
    13. 模板方法（TemplateMethod）模式：
        > 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
    14. 策略（Strategy）模式：
        > 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
    15. 命令（Command）模式：
        > 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
    16. 职责链（Chain of Responsibility）模式：
        > 把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
    17. 状态（State）模式：
        > 允许一个对象在其内部状态发生改变时改变其行为能力。
    18. 观察者（Observer）模式：
        > 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
    19. 中介者（Mediator）模式：
        > 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
    20. 迭代器（Iterator）模式：
        > 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
    21. 访问者（Visitor）模式：
        > 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
    22. 备忘录（Memento）模式：
        > 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
    23. 解释器（Interpreter）模式：
        > 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
    >这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式


23.观察者模式和订阅-发布模式区别 各自适用的场景
    观察者模式：
        主题和观察者是互相感知的 
        一对多
    订阅-发布者模式:
        借助第三方实现调度 发布者和订阅者之间互不感知
        多对多

Vue中的设计模式
外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度
工厂模式

1.数据结构层面
数组
栈
队列
链表
树（这里我们着重讲二叉树）
2.数组
1.创建
const arr = (new Array(7)).fill(1)
如此便可以得到一个长度为7，且每个元素都初始化为1的数组：
访问遍历
for
    从性能上看，for 循环遍历起来是最快的
forEach
map
2.二维数组
矩阵<=>二维数组
初始化:
fills arr[0][0] = 1  发现一整列的元素都被设为了 1    
工作机制
当你给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。
7个数组对应了同一个引用、指向的是同一块内存空间，它们本质上是同一个数组。s
for 循环
const len = arr.length
for(let i=0;i<len;i++) {
    // 将数组的每一个坑位初始化为数组
    arr[i] = []
}
for 循环中，每一次迭代我们都通过“[]”来创建一个新的数组，这样便不会有引用指向问题带来的尴尬。
访问：
双层循环
3.栈和队列(两者的区别在于，它们各自对数组的增删操作有着不一样的限制)
在 JavaScript 中，栈和队列的实现一般都要依赖于数组，大家完全可以把栈和队列都看作是“特别的数组”。

实际上，栈和队列作为两种运算受限的线性表，用链表来实现也是没问题的。只是从前端面试做题的角度来说，基于链表来实现栈和队列约等于脱裤子放屁（链表实现起来会比数组麻烦得多，做不到开箱即用），基本没人会这么干。这里大家按照数组的思路往下走就行了

两者的区别在于，它们各自对数组的增删操作有着不一样的限制。因此，在学习栈与队列之前，我们需要先来明确一下数组中的增删操作具有什么样的特性、对应的方法有哪些：

数组中增加元素的三种方法
1.unshift 方法-添加元素到数组的头部
2.push 方法-添加元素到数组的尾部
3.splice 方法-添加元素到数组的任何位置

const arr = [1,2] 
arr.splice(1,0,3) // [1,3,2]

数组中删除元素的三种方法
1.shift 方法-删除数组头部的元素
2.pop 方法-删除数组尾部的元素
3.splice 方法-删除数组任意位置的元素

栈stack 只用 pop 和 push 完成增删的“数组”
栈是一种后进先出(LIFO，Last In First Out)的数据结构。
只允许从尾部添加元素
只允许从尾部取出元素
对应到数组的方法，刚好就是 push 和 pop。
因此，我们可以认为在 JavaScript 中，栈就是限制只能用 push 来添加元素，同时只能用 pop 来移除元素的一种特殊的数组。

队列（Queue）——只用 push 和 shift 完成增删的“数组”
队列是一种先进先出（FIFO，First In First Out）的数据结构。
只允许从尾部添加元素
只允许从头部移除元素

链表
链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。
这个“离散”是相对于数组的“连续”来说的
数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段连续的内存空间。元素与元素之间，紧紧相连（当然啦，还有二般情况，我们在下文的辨析环节会提到）。
而链表中的结点，则允许散落在内存空间的各个角落里。

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}   

数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了如下的联系：

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：
链表结点的创建
创建链表结点，咱们需要一个构造函数：
function ListNode(val) {
    this.val = val;
    this.next = null;
}
在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：
const node = new ListNode(1)  
node.next = new ListNode(2)
添加：
    直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。
插入：
    变更的是前驱结点和目标结点的 next 指针指向，
    // 如果目标结点本来不存在，那么记得手动创建
    const node3 = new ListNode(3)     
    // 把node3的 next 指针指向 node2（即 node1.next）
    node3.next = node1.next
    // 把node1的 next 指针指向 node3
    node1.next = node3
链表元素的删除(前驱节点)
    node1.next = node3.next 
    在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。比如说咱们这个题里，其实只要能拿到 node1 就行了：
    // 利用 node1 可以定位到 node3
const target = node1.next  
node1.next = target.next

链表和数组的辨析
    数组增加/删除操作对应的复杂度就是 O(n)。
    JS 中不一定是
    它是一个纯数字数组，那么对应的确实是连续内存。
    但如果我们定义了不同类型的元素：
    它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。
    JS 数组未必是真正的数组
    相对于数组来说，链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。

    高效的增删操作
    在链表中，添加和删除操作的复杂度是固定的 
    链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

    麻烦的访问操作
    当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

    // 记录目标结点的位置
    const index = 10  
    // 设一个游标指向链表第一个结点，从第一个结点开始遍历
    let node = head  
    // 反复遍历到第10个结点为止
    for(let i=0;i<index&&node;i++) {
        node = node.next
    }

    随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

    但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：

小结：
    链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。这个特性需要大家牢记，可能会作为数据结构选型的依据来单独考察。
树：
树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
“叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。
二叉树
二叉树是指满足以下要求的树：

1.它可以没有根结点，作为一棵空树存在
2.如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。如下图：
    
，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

二叉树的编码实现

在 JS 中，二叉树使用对象来定义。它的结构分为三块：
数据域
左侧子结点（左子树根结点）的引用
右侧子结点（右子树根结点）的引用
在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：
// 二叉树结点的构造函数
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}
当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：
const node  = new TreeNode(1)
如此便能得到一个值为 1 的二叉树结点，从结构上来说，它长这样：
以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：
二叉树的遍历——命题思路解读
以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：
递归遍历
    先序遍历(根左右)
        根结点 -> 左子树 -> 右子树
    中序遍历(左根右)
        左子树 -> 根结点 -> 右子树
    后序遍历(左右根)
        左子树 -> 右子树 -> 根结点
迭代遍历
    层次遍历
按照实现方式的不同，遍历方式又可以分为以下两种：
    递归遍历（先、中、后序遍历）
    迭代遍历（层次遍历）

编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。

它可以没有根结点，作为一棵空树存在
如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};


递归函数的编写要点

编写一个递归函数之前，大家首先要明确两样东西：
递归式 根结点 -> 左子树 -> 右子树 
递归边界 
在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。

先序遍历
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}

中序遍历
唯一的区别只是把遍历顺序调换了左子树 -> 根结点 -> 右子树：
递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。我们参考先序遍历的分析思路，来写中序遍历的代码：
// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}

后序遍历
先访问左子树，再访问右子树，最后访问根结点
在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}

时间复杂度 空间复杂度

在所有的 for 循环里，判断语句都会比递增语句多执行一次。在这里，判断语句执行的次数就是 n+1。
计算T(n) -> 推导O(n) 
实际操作中，O(n) 基本可以目测
常见的时间复杂度表达，除了多项式以外，还有logn

常见时间复杂度按照从小到大的顺序排列 有以下几种
常数时间：O(1)
对数时间:O(logn)
线性时间:O(n)
线性对数时间:O(blogn)
二次时间:O(n^2)
三次时间:O(n^3)
指数时间:O(2^n)

空间复杂度
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。和时间复杂度相似，它是内存增长的趋势。
常见的空间复杂度有 O(1)、O(n) 和 O(n^2)。













