afrigo非洲跨境电商平台app端开发
afrigo非洲跨境电商平台pc端后台管理系统开发
个人博客
求职帝小程序后端管理系统的开发
影音盒子开发

2021 1月份
afrigo非洲跨境电商平台app端开发(Hbuilderx dev)
    项目描述：非洲跨境电商平台app端 
    面向人群：非洲人民
    解决问题：
            可以这样说 现在的非洲 很像是十几年前的中国
            非洲在电商贸易这方面 蕴含着巨大的商机和潜力

    技术栈：
        国云电商模板 uni-app SASS i18n国际化
        
    功能：评论页面 评论接口 订单详情界面催单接口 refund接口 相应的国际化 处理
    功能：
        1.afrigo app端实现的功能不多 这个项目架构相对成熟
            因为这个是app版本的迭代升级 而不是从零开始
            而且这个项目我处理的部分是从别人手中接手的

            完善了几个接口 做了一些相关的国际化处理
            能切换英文和法文 考虑到非洲地区不同语言需求的人群 
        2.新写的就是一个评论页面 组件都是用国云电商模板里面的组件实现的 
            这是为了避免引入不必要的组件 增加负荷 非洲那边的流量是很贵的嘛    
            UI仿照的是淘宝的样式 带参进入评论页面
            上面就是左边商品图片 右边商品详情 
            点击能进入相应的商品详情页面(query传参) 下面是rating组件实现的点星星 
            表示自己对商品满意度 再下面是一个输入框 然后就是上传评论图片功能
        3.上传图片功能 实现的是单张图片上传功能 使用的是uni-app中两个API实现的
            uni.chooseImage uni.upLoadFile 按照官方文档进行相应参数的配置
        4.当时实现的想法比较简单 切图 三元表达式 如果用户没有上传图片 
            默认显示请为宝贝添加评论的图片   
        5.然后确实能传到数据库 但是实现方式过于粗糙 
            不过当时后端的接口只给了一个上传单张图片的功能
            不过应该是可以通过前端的一些方式 用单张上传图片的接口
            也能实现多张上传功能 不过后来就开学了 这个功能就没能继续再完善
        还有一些其他一些小的内容
        6.由于购物app 用户必须登录后进行操作 
            评论页面 需要从Vuex中的state中拿到userInfo用户信息 
            用mapState辅助函数 在computed里面解构出来 
            然后向后端发送请求的时候 都要带上userInfo
            这个是一个基础逻辑问题
        7.上传图片这个方面没有使用封装的请求
            所以我要自己拿token作验证 
            用uni.getStorageSync('token');从本地缓存中拿到token  
            请求头header 里面的Authorization
        8. 评论页面点击确认按钮 向服务器端发送HTTP请求
            发送请求之前 会检测用户是否进行了数据填写
            如果没有 是不能提交评论的 这个是个逻辑上的问题
        9.向服务器端提交评论页面的数据操作 
            使用async await函数做异步处理
            如果提交评论成功 
            就会延迟一秒后跳转到index主页面
            这个延迟是用定时器实现的
        
        10.跳转到评论页面要接参 在onLoad函数中 用options参数接过来的
        11.跳转到评论页面要带商品id 订单id各种信息进来 使用params传参 在onLoad中接收
    项目亮点：
        1.错误码设计
            第1位: 定义错误提示级别，1给用户的普通提示、2给前端开发人员的提示
                第2-4位: 具体错误编号
        2.iconfont 把所有图片图标 全部更换为字体图标
2020 12月份
afrigo非洲跨境电商平台pc端开发(Webstorm dev)
    项目描述：上面那个afrigo app项目的后台管理
    技术栈：vue-admin-template  ElementUI 
    功能：地址管理页面 (模糊搜索 添加数据 数据列表的树状展示)
            非洲区域(region)分四级 负责把每一级地区展示出来
                数据列表每一行有操作功能(编辑删除查看下一级)
            数据库设计：regionId pRegionId
    亮点：
        1.实现的功能大致分为三块 
            第一块模糊搜索 第二块添加地址 第三块地址区域的展示 是以table表格的形式展示出来的
            第三块是最复杂的部分 之后单独说 
        2.第一块模糊搜索 组成很简单 就是一个输入框输入要搜索的内容 一个按钮点击后下面数据列表展示你搜索的内容
            这个功能主要复杂度在后端那里 我做的就是输入框绑定v-model获取输入框内用户输入的值 当用户点击搜索按钮时
            触发我写的一个函数 把关键字作为参数发送HTTP请求 从后端拿到数据 然后在数据列表中展示出来
        3.第二块添加地址 我单独写了一个页面 不过由于这个添加地址和编辑地址实现的功能十分类似 我就写了一个单页面组件 
            分别在添加地址页面和编辑页面中调用该组件就行 
        4.添加地址功能是这样实现的 主页面上就是一个按钮 点击该按钮 页面发生跳转 跳转到添加页面 该页面字段一共有这几个
            首先是区域名称 一个输入框 填写你要添加的区域名称 
        5.然后是上级分类 这个上级分类就是 你这个地址上面几级都是什么 举个例子 如果你添加哈尔滨 上级分类就是黑龙江 如果你添加香坊区 上级分类就是黑龙江/哈尔滨 这个我是用级联选择器实现的 这个说起来有一些复杂 一会再说 先把编辑页面的字段都介绍完
        6.除了上面两个字段还有一个字段就是运费 是一个输入框 最后一个字段是备注 然后下面就是两个按钮 一个提交按钮 一个重置按钮
        7.先从第一个字段说起 按逻辑来讲 你添加一个区域 其他可能不需要写 区域名称是一定需要的 这个表单我使用的是elementui里面的组件 设置rules相关 就实现一个效果 如果你不填写的话 输入框显示红色 提示你填写 这种格式还挺长见的 第一个字段就这样处理的 不是说很复杂
        8.第二个字段是最复杂的 当初设计的时候设想的是 点击输入框那个小角 请求数据显示第一级区域 点击第一级区域 请求数据显示该区域下的二级区域 举个例子 类似点击小角显示中国省级区域 山东 河南 点击河南 显示郑州。。
        9.实现的时候遇到了困难 因为click触发不理想 。。
        10.拿到后端的树状结构嵌套的对象数组 我给绑定上 就能正常显示 bug 如果该区域下没有子区域 后端返回一个null 前端不可渲染、 但是它会 显示一个空白页 网络搜索 不是我一个人遇到这个问题
        11.封装一个函数 如果子区域length为0 设置该值为undefined解决该问题
        12.下面两个字段就是用户正常填写 我v-model绑定 获取就好了 点击提交按钮将用户填写信息作为参数提交表单发送HTTP请求 然后跳转到主页面 请求成功后跳转到主页面这时候就能显示出来新添加的数据了 发送请求前的表单验证用的是this.$refs[formName].validate方法
        13.这就是添加按钮做的事情 还有一个重置按钮 实现的用户需求就是 用户可能不想填这个地址了 不用一下下删除 点击一下重置 就清空之前填入的所有信息 使用Object.assign方法实现 
        14.说回第三块数据列表的展示 字段就是正常添加地址会显示的那些字段 id自动生成 区域名称 运费 备注 操作 三个按钮 三个功能 分别是编辑 删除 查看下一级 
        15.这里先讲删除 这个删除接口比较简单 就是带参请求 后端删除操作成功后 再一次请求获取数据接口 展示新的列表 之前又说道我写了一个单页面组件 实现添加和编辑功能 这个一会说
        16.查看下一级功能是什么意思呢 举个例子 就是地址管理页面进来的时候 这个数据列表展示页面就是 黑龙江 吉林省。。。 然后你点击黑龙江这一行的查看下一级功能 数据列表刷新 哈尔滨 齐齐哈尔 继续点击齐齐哈尔的下一级 显示克山县如此类推
        17.实现这个功能主要用到的函数是this.$router.push方法 当我点击黑龙江的时候 把它的regionId传过去 再次进入这个页面 不同的是 我的$route里有了参数 我使用的wacth侦听器侦听$route对象 如果改变 调用resetPRegionId函数 改变pRegionId 再发送请求 获取数据 进行展示
        18.最后说回编辑地址这个按钮实现的功能 之前说过这个页面实现的功能和添加地址实现的功能十分类似 字段都是那些字段 但是又不是完全相同的 因为编辑功能你点击按钮进入页面的时候是带默认值
        19.如何分辨该页面是添加还是编辑 是使用isEdit属性实现的 父组件添加页面传值false 编辑页面传值true 子组件在props中接收到父组件传过来的值 然后据此判断是哪个页面 是否要显示有默认值 展示判断逻辑的实现
        20. 然后是默认值逻辑的实现 如果是编辑页面 在push进该页面的时候用query传参 在creatd生命周期函数中接收this.$route.query里面的数据 展示出来
        21.其他默认值都相对好展示 其中最复杂的还是上级分类这块 举个例子 例如 你进入香坊区的编辑页面 那该页面的上级分类就应该显示黑龙江/哈尔滨 这个参数不好传的原因是 不确定该区域上面有几个级别的区域 还要获取上面几个级别区域的名字
        22.解决方法是 在data中定义了一个num为0 表示进入区域的深度 例如最开始省级为0 进入黑下哈尔为1 进入哈下香为2 记录进入区域深度 一个regionIdList数组 记录进入每个区域regionId 如果我在这一级想进入编辑页面 我就可以通过这些数据进行判断显示

        1.地址树状分页分级展示
        2.封装一个单文件组件 减少冗余 增强复用性
        1.级联选择器 四级数据的获取 展示(后端同学沟通解决)
        2.级联选择器 children为null时 数据列表为空白页(封装一个递归函数 children.length<1 undefined)
        3.编辑页面级联选择器的默认值 要获取该级别区域的上一级以及上上一级 不定(num regionIdList)
        4.数据列表分级展示(this.$router.push watch中监听route)
        5.表单验证
        6.通过props属性 子组件获得父组件中is-Edit的值 在单文件组件中 根据该属性值的不同 做相应差异化处理
        7.ref
        8.scope相当于一行的数据 scope.row相当于当前行的数据对象 用插槽 拿到当前行 row是个内置的属性 ，vue slot的scope传递值是父作用域中的源数据改变，值会同步改变。且{{scope.$index}}可以获取当前行的index。  slot slot-scope="scope" scope.row.regionId
        9.使用watch侦听属性 监听$route对象是否发生改变 一旦发生改变 调用this.resetPRegionId 改置pRegionId 重新请求数据 实现地址分级获取的功能
        10.在created(此时操作不了dom)生命周期钩子中调用this.resetPRegionId 因为此时页面初次渲染 此函数中会将pRegionId设为0 虽然data中初始化该值就是0 获取data
        11.使用this.$router.push方法 有历史记录
        12.此项目中前端传参 我使用 path+query方式 组件中使用this.route.query方式接收
        13.使用Object.assign({}, defaultAddressDetail) 做表单重置
        14.表单验证使用的this.$refs[formName].validate((valid)=>{

        })
        方法进行验证
        15.优化 删除区域的时候 使用方法this.$confirm 在该方法中的then中调用delete接口也调用了then 造成了回调地域的现象出现 
        改用return该方法调用完返回的response 改原来的回调地域为链式调用风格 进行了代码优化
2020 12月份
个人博客(vscode)
    项目描述：个人博客
    技术栈和：Vue Vue-Cli Node Koa框架 富文本编辑器wangEnduit 
                   Element-UI  MVC开发模式(Model View Controller) SASS
                    axios JWT
    功能：登录 注册 评论分页展示 发表评论 发表文章 删除文章 删除评论 查看评论详情
    项目逻辑：
        1.首先项目运行出来是一个主页面 有登陆注册两个功能 点击可以分别跳到登录注册页面 
        登陆页面就是输入用户名 密码 发送login请求 成功返回token把token存储在localStorage和vuex中的state中
        返回userInfo 把userInfo存储在vuex中
        2.登录之后就会进入主页面 主页面就是一些博客文章的展示 做了一个分级展示 后端sql语言做相关配合实现 
        主页面有一个按钮点击进入发表文章页面 发表文章页面就是一个富文本编辑器做文章内容区 一个输入框做文章标题
        下面一个按钮点击发表文章成功跳回主页面 主页面显示那些博客 按照发表时间进行排序 时间最近的在最上面
        3.点击每个博客 下面有评论区 有评论 评论人 评论发表时间 时间为了做正常时间格式的展示 后端封装了一个时间戳函数
        然后有一个按钮点击可以进入发表评论页面 和发表文章页面逻辑类似 有一个按钮可以实现删除文章功能 
        4.注册页面也是用户名密码 注册成功后会自动跳转到登录页面 依然是上面那些逻辑
    亮点：
        1.前端使用axios封装请求(BASE_API)响应拦截器(token验证)
        2.前端myblog-pc使用Vue-Cli框架搭建 后端myblog-rd使用MVC设计模式 Node+Koa搭建 数据使用mysql关系型数据库
        3.后端封装了一个时间戳函数(处理评论时间格式) 引入JWT生成token 封装了一个verifyToken函数
        4.Vue前端路由传参页面跳转 我使用的是params方式传参 
            params(页面刷新参数消失) name(/users/123)/query path(?q=123)
        5.发表文章评论页面的编辑器去引入了富文本编辑器wangEnduit 发表文章页面content为html标签 使用v-html指令 使其正常显示
        6.使用了ElementUI里面的一个分页组件 在getData函数中传参给后端 后端配置相关的访问数据库语言 实现分页获取数据
        7.除了login/regist页面不需要进行token验证 其他页面要进行操作 都会匹配进后端路由配置封装的verifyToken函数 
        如果验证不通过 会直接返回我设置的state 
        8.后端根据前端是提交数据还是获取数据 分get请求和post请求
        get请求 使用ctx.query(?方式传参) |ctx.params(另一种传参方式) post请求使用ctx.request.body
        9.前端使用ES6规范 后端使用CommonJS规范
        10.后端路由文件按照功能区分两个 分别是blogs.js(做博客相关操作)和users.js(专门负责用户的登录和注册)
        使用router.prefix('/user')语法设置路由前缀 作为区分 功能上整洁 合理
        11.后端路由配置使用的是koa-router 前端路由配置使用的是vue-router 
        封装的请求拦截响应器使用的是axios HTTP库中的语法
        const instance = axios.create({
            baseURL: 'http://localhost:3000',
            timeout: 60000
        });
        封装了baseURL
        请求拦截器中获取token并在请求头中进行配置 响应拦截器中判断后端是否返回401 
        如果返回401调用vuex actions中写好的函数logout清除vuex和localStorage中存储的token
        12.数据库设计了三张表
            t_blog      blog_id user_id 
            t_comment   comm_id blog_id user_id
            t_user      user_id
        13.后端使用MVC开发模式 C 处理业务逻辑的controllers中调用M(处理数据库增删改查函数时) 使用的async await语法进行处理
        14.后端在login相应逻辑业务处理中调用createToken函数(使用的是JWT json web token) 生成token 并放置在ctx.body中返还给前端
            前端接收后使用 this.$store.commit("storeLoginUser", user);(mutations中的方法 同步) 将用户信息存储在state中
            使用this.$store.dispatch("setToken", token);(actions中的方法 异步)将token存储在vuex中 
            (vuex中)使用 localStorage.setItem('mytoken', token)将token存储在localStorage中
            在前端封装的请求拦截器http.js中使用localStorage.getItem('mytoken')拿到token 并在请求头中配置
            config.headers['Authorization'] = 'Bearer ' + token;
            完成前后端登录token验证的一个逻辑
        15.后端业务处理代码C中采用以下基本步骤进行操作 
            1.接收前端传的数据 如果有的话
            2.验证 用户名是否填写 安全性考虑
            3.连接数据库
            4.根据数据库操作的结果 返回相应的信息
        16.前端发表评论/文章页面 操作之前都必须要获得vuex中存储的用户信息
        17.后端数据库CONFIG  专门封装了一个db.config.js配置文件
    遇到问题及解决:
        1.mysql数据库的安装和下载问题               
        2.富文本编辑器的选择和引入 
2020 11月份(webstorm dev)
求职帝pc端后台管理系统
    项目描述：小程序求职帝的pc端后台管理系统
    面向人群：北上广深一些中小型用人企业单位 在读相关专业大学生
    解决问题: 北上广深这样的城市 用人成本高 对于一些中小型企业来说
             可能没有那么多的资金 在用人成本上
            在校的大学生往往可以通过书籍网络获取计算机相关知识
            但是缺乏真实的项目经验 不能很好地把知识应用在实际上
            这就形成了一个商机 我们是不是可以把这两类人群的需求点结合在一起
            让企业和大学生合作 既可以降低企业用人成本 
            也可以给在校学生提供锻炼的机会和一些金钱收益
            达到一个互惠共赢的局面呢 
            求职帝小程序这个平台就是在这个背景下被设想出来的
    技术栈：Vue-Admin-Template Element-UI
    功能：简历详情页面(带参跳转)
    逻辑：
        一个很简单的页面 最上面个人信息 中间技能 经验之类的 只用把数据展示出来就好 
        没有什么复杂的逻辑实现
    亮点:
        1.swaggerui的使用和查看 
            获取token
            1.了解到可以在swaggerui中注册登录然后获取鉴权 填入Bearer +token 
            能在swaggerui上测试后端接口是否可以正常使用
            2.运行项目后 在控制台的vue-devtools工具的vuex中查看token获取鉴权
            3.了解到接口文档中formData数据格式和json数据格式
            传递数据形式上的不同 可以做一个简单的区分
        2.和后端同学沟通共同开发 
        3.figma的使用和查看
        4.蓝湖工具的使用
2020 10月份
影音盒子(vscode) 一个练习项目
    项目描述：电视剧 音乐 书籍相关的一个app
    目的：梳理学过之前学过的相关知识 
    技术栈：Vue-Cli Element-UI jsonbird axios aplayer组件
    功能：(上下导航栏) 影音 音乐 书籍 三个个页面
    逻辑：
        进入就是电视剧列表 下面导航栏 点击可以进入相应的音乐和书籍页面
    亮点：
        1.电视剧列表展示页面做了一个数据懒加载
        2.assets公共文件夹下 引入了一个reset.css文件做样式重置 
            引入一个rem.js文件做移动端适配 将这两个文件在main.js文件中做全局引入
        3.了解到项目配置文件中package.json和package.lock.json的不同
        4.封装了两个组件 上下导航栏 在App.vue中进行引入配置 其他所有书写的页面都在上下导航栏的中间(router-view)
        5.main.js中引入elementui axios aplayer插件做音乐播放器
        6.各页面切换 状态管理是通过vuex状态管理器实现的 首先在state里面存储curPage 当前页 默认是剧集页面 作为该app的首页 
        点击下面导航栏切换页面的时候 通过调用mutations里面的changePage方法对state中的curPage操作实现 s、
        7.底部的导航栏是使用v-for指令遍历出来的 跳转使用的是router-link组件 设置了一个routerList对象数组列表 数组中每一个对象
        包含path name 和bgColor 通过对router-link组件的to属性的绑定 click方式进行切换页面和导航栏背景颜色
        8.通过v-bind指令绑定内联样式style切换导航栏背景颜色
        9.影视页面就是jsonbird解决跨域问题 使用images.weserv.nl图片缓存网站获取图片
        获取数据列表 使用v-for指令加一点样式展示出来 还有一个功能 点击该影视剧
        通过this.$router.push方法 params方式传参对应的影视剧id 进入相应的影视详情页面
        10.影视详情页面依旧跨域获取数据 缓存获取图片 获取影片详情介绍 做了一个展示
        11.音乐页面引用aplayer组件 分别请求网易云歌单接口和歌曲接口 跨域问题还是使用的jsonbird方式解决的 用了一个then链式调用 先请求歌单
            然后调用请求单手歌的方法把请求回来的歌单列表的第一首歌的id传给它 获取默认歌曲展示 后面点击每个歌 传入相应的id调用该song
        12.书籍页面使用了ElementUI里面的轮播图组件 tabs标签页组件 loading组件 rating组件 整个页面由两部分组成 上面的轮播图 下面的选项卡切换
            请求的是豆瓣图书的接口 两个接口 一个是虚构类fiction图书接口 一个是非虚构类nonfiction图书接口 
            这里关于使用axios库提供的get方法获取数据 做了一个取巧的事情 因为这两个接口非常类似 只有中间一小块不同
            一个是book_fiction一个是book_nonfiction 请求数据的时候 url就用了字符串变量拼接的方法做的 
            正常使用选项卡组件 它会有一个activeName属性 会随着点击而切换 使用this.activeName 

初始化  
    开始创建 
    初始化数据 
    编译模板 
    挂载DOM-渲染 
    数据变化更新DOM-渲染
    销毁
生命周期 
    vue实例从创建到销毁的过程

    beforeCreate --vm不存在 dom未生成 el没有 data未初始化
        实例初始化之后 创建之前
        el undefined
        data undefined
        message undefined
        --el和data未初始化

    created --el没有 dom未生成(模板渲染成HTML之前) data生成
        el undefined
        data [Object Object]
        --el未初始化 data初始化 

    beforeMount--$el被挂载前调用 --el初始化 dom(相关render函数首次被调用 将模板渲染成HTML) data初始化 

        el [Object HTMLDivElement]
        data[Object Object]
        --el和data初始化->已完成模板编译->未渲染到界面

    mounted--$el被挂载后 el挂载(编译好的HTML挂载到页面) 初始化页面完成后调用nextTick方法
        el[Object HTMLDivElement]
        data[Object Object]
        --挂载渲染完成后调用->初始化页面->对DOM进行操作

    beforeUpdate
        更新渲染视图前 
        界面中数据旧 data中数据已更新
        未同步
    updated
        更新渲染视图后
        已同步
    beforeDestory 实例vm可用
        销毁前
    destoryed 实例vm不可用
        销毁后
vue获取数据-生命周期函数
    created/beforeMount/mounted
    正常获取created
    设计需页面加载完成后(DOM操作)mounted

DOM异步 NexTick
DOM异步
    Vue异步执行DOM更新
    数据变化 一个队列 缓冲同一事件循环发生所有数据改变
    避免不必要的计算和DOM操作
NexTick(DOM更新后想做点什么)
    下次DOM更新循环结束后执行延迟回调
    修改数据之后使用$nextTick 
    可在回调中获取更新后的DOM

虚拟DOM DOM-diff DOM-patch
虚拟DOM
    用JS按照DOM结构实现的树状结构对象
    节点与DOM Tree每个位置属性一一对应
    解决浏览器性能
    虚拟DOM将10次更新的diff保存到本地一个JS对象
    最终将该JS对象依次attach到DOM树上    
    优点：
        减少DOM操作
        跨平台
    具体实现步骤:
        1.JS对象模拟真实DOM树
        2.diff算法--比较两颗虚拟DOM树差异
        3.pach算法--将两虚拟DOM对象差异应用到真正的DOM树
DOM-diff
    仅在两树同级虚拟节点间做递归比较
    React框架采用方法

Object.defineProperty

双向绑定&Vue中的双向绑定
双向绑定
    1.发布订阅者模式-backbone.js
    2.脏值检查-angular.js
    3.数据劫持-vue.js
Vue中双向绑定 Vue2.x
    数据劫持Object.defineProperty+发布者-订阅者模式
    Object.defineProperty
        劫持各个属性setter getter
    发布-订阅者模式
        数据变动时发布消息给订阅者 触发响应监听回调
    1.监听器Observer
    2.解析器Compile
    3.订阅者Watcher
    4.订阅器Dep
    对象：
        1.Vue.set(object,propertyName,value)
        2.vm.$set(object,propertyName,value)
    数组：
        1.
        2.
        3.vm.items.splice(newLength)
Vue中双向绑定 Vue3.x
    Proxy
        可直接监听对象而非属性
        可直接监听数组变化
MVC(Model View Controller)
    View->Controller->Model->View 单向通信
MVP(Model View Presenter) 
    View Model不发生联系 通过Presenter传递 双向通信
    View很薄 不部署任何业务逻辑 称为被动视图
    Presenter很厚 所有业务逻辑都部署于此
MVVM(Model View ViewModel) 
    将Presenter改为ViewModel 其他基本与MVP一致
    View Model不发生联系 通过Presenter传递 双向通信
    Model数据模型 数据和业务逻辑在此应用
    View UI视图 负责数据展示
    ViewModel负责监听Model中数据的改变并且控制视图更新 处理用户交互操作


指令
1.v-html/v-text{{}}
1.v-bind:/v-on@/v-model
2.v-if(v-else/v-else-if)/v-show
3.v-for

template
    模板占位符 可包裹元素
    循环过程中 不会被渲染 天生不可见 display:none
    1.字符串模板写法
    2.template标签内
    3.script标签中 type加上x-template

slot
    1.单个插槽|默认插槽|匿名插槽--不用设置name
    2.具名插槽--父组件通过HTML模板上slot属性关联
    3.作用域插槽|带数据插槽 slot-scopes
        子组件可给父组件传参 父组件决定展示

component
    1.可复用的Vue实例且带有一个名字
    2.每个实例可维护一份被返回对象的独立拷贝
    销毁
        1.没有使用keep-alive路由切换
        2.v-if='false'
        3.执行vm.$destroy()

minxin
    1.全局混入
    2.局部混入

key 基本数据类型值
    1.v-for 特定key 虚拟DOM算法 新旧nodes做对比

模板语法
    开发者声明式将DOM绑定至底层Vue实例的数据
    Vue将模板编译成虚拟DOM渲染函数

ref
1.普通元素上 this.$ref.xxx dom元素
2.子组件    this.$ref.xxx 组件实例可以使用组件所有方法
3.v-for用于元素/组件 引用信息将是包含DOM节点/组件实例数组
                可循环拿到单个ref
ref本身作为渲染结果被创建 dom未渲染完成之前不允许访问
$ref并非响应式 不能在模板中做数据绑定

组件通信
1.props/this.$emit
2.$ref $parent $children
3.vuex

is与动态组件
    HTML元素某些元素只能出现在它某些特定的内部
    自定义组件会作为无效内容提升到外部 
    并导致最终渲染结果出错

computed method watch
计算属性computed
(计算属性是基于它们的响应式依赖进行缓存的,只在相关响应式依赖发生改变时它们才会重新求值)
事件methods
(只要发生重新渲染，method 调用总会执行该函数)
methods方法 watch属性 不能用this
this会是undefind,
因为箭头函数中的this指向的是定义时的this，而不是执行时的this，所以不会指向Vue实例的上下文。
2.
computed
(计算属性/依赖多个属性/缓存结果时每次都会重新创建变量/计算开销比较大(计算次数多或者异步处理)/通过return返回)
和watch
(侦听器/依赖一个属性/直接计算，不会创建变量保存结果/计算开销比较大(计算次数多或者异步处理)/不需要return) 
在选项参数中指定deep: true 可深度监听
在选项参数中指定immediate: true将立即以表达式的当前值触发回调。监听后立即调用

动态绑定class
1.对象语法
    <div class="test" :class="{active: actived ,'active-click': clicked && actived}">
    </div>
2.数组语法
    <div class="test" :class="[actived? activeClass : '', clicked && actived ? activeClickClass : '']">
    </div> 
3.对象和数组混合
    <div :class="[testClass , {active: actived} , {'active-click': clicked && actived}]"></div>
4.对象和计算属性


每个实例可以维护一份被返回的对象的独立的拷贝

$route 路由信息对象 路由信息参数
    path params hash query fullPath matched name
$router Vue-router实例对象 路由跳转方法 钩子函数 
    路由跳转方法 钩子函数 

query 
    path引入 this.$route.query.xxx接参
    类似get 参数显示在地址栏 
    浏览器地址 http://localhost:8036/home?userId=123 
params
    name引入 this.$route.params.xxx接参
    类似post 参数不显示在地址栏 
    浏览器地址 http://localhost:8036/home/123
    地址上做配置 path: '/home/:userId',

JSON.stringfy()将JavaScript值转换成JSON字符串
JSON.parse()将JSON字符串转换为JSON对象

Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的
Vuex中解构
getters相当于vue中的计算属性 通过getters进一步处理 得到我们想要的数值
且允许传参 第一个参数是state
1.可以通过$store来获取
2.前面的方法名和获取的属性名是一致的
    import {mapState,mapMutations} from "vuex";
    computed里面(mapState mapGetters)
    1.mapState辅助函数(state类似于vue中的data)
    computed:{
        ...mapState(['nickname','age','gender'])
    },
    2.mapGetters辅助函数(getters相当于vue中computed)
    computed:{
       ...mapGetters(['realname','money_us'])
    },
    methods里面(mapMutations mapActions)
    3.mapMutations辅助函数(mutations类似于vue中的methods)
    (mutations需要通过commit调用其里面的方法
    它也可以传入参数 第一个参数是state 第二个参数是载荷(payLoad)
    即额外的参数 该参数最好写成对象形式 可以传递更多信息)
    (mutations只能写同步方法不能写异步方法如axios setTimeout 主要作用就修改state)
    (为什么调用mutations中的方法对state中的数值进行修改 而不直接进行修改呢
    作者在mutations中做了类似埋点操作如果
    从mutations中操作的话， 能被检测到，可以更方便用调试工具调试，调试工具可以检测到实时变化，而直接改变state中的属性，则无法实时监测
    )
    (mutations中写异步，也能够调成功，但是由于是异步的，不能被调试工具追踪到，所有不推荐这样写，不利于调试,这是官方的约定。)
    methods:{
        ...mapMutations(['changePage'])
    }
    4.mapActions
    (action类似mutation
    区别：
        action可以提交mutation
        action不要直接操作state 而是去操作mutation
        action包含异步操作 类似axios请求 都可以放在action中写
        action默认就是异步 而且返回promise
    )
    methods:{
    ...mapActions(['getUserInfo'])
    }
    (this.$store.dispatch(‘getUserInfo’))




