// 原型链
// const指向对象？
/*
JS数据类型：
        1.五种基本数据类型(基本数据类型在赋值操作后，两个变量相互不影响)
                Number String Boolean Undefined Null
                        undefined：用关键字var let const
                                声明了变量，但未给变量初始化值
                                则该值就是undefined
                        null：空对象指针
                                被当作一个空对象引用
        2.两种引用数据类型
                Object 
                        JS中Object是一组属性和方法的集合
*/
/*
null与undefined
        null：一个表示无的对象 转换成数值时为o
        undefined：一个表示无的原始值 转换为数值时为NaN
        null：表示没有对象 即此处不该有值
        undefined：缺少值，此处应该有一个值，但是还没有定义
*/
/*
js中变量是松散类型的 提供一种检测当前变量的数据类型的方法
typeof关键字
        typeof(null);object
        null类型进行typeof操作符后
                结果是object 原因在于 null类型被当作一个空对象引用
        typeof([]);object
        typeof({});object
*/
/*
undefined和NULL
        1.undefined和null在if语句中 都会被自动转为false
*/
/*
        变量提升是人为实现的问题
        函数提升当初设计时有目的（解决相互递归的问题）
        但是在代码编写过程中 要遵循开发规范 先声明 后调用
*/
/*
优先权
        1.函数
        2.函数表达式
        3.变量
*/
/*
变量提升：
        通常JS引擎会在正式执行前先进行一次预编译
        这个过程中 
        首先将变量声明及函数声明提升至当前作用域的顶端
        然后进行接下来的处理

        当前作用域声明了多个同名变量
        它们的同一个标识符会被提升至作用域顶部
        其他部分按顺序执行
*/
/*
函数提升：
        1.函数声明前就可以调用
        引擎把函数声明震哥哥提升到当前作用域的顶部
        2.如果在以恶搞作用域中存在多个同名函数声明
                后面出现的会覆盖前面的函数声明
*/
/*
let 和 var 的区别：
        1、let 不允许重复声明变量，如果这么做了就会提示错误
        2、let不存在变量提升，会报错
        3、let存在一个块级作用域的概念
        4、暂时性死区：【在一个作用域内，不允许同名变量进来】
 */
/* 
var 和 const 的区别：
        1、const也不存在变量提升
        2、const 也不允许重复声明
                对象？
        3、赋值以后不允许再更改变量的值（引用数据类型不能改地址）
*/
/*
作用域：
        1、全局作用域
        2、局部作用域（函数作用域）
        3、块级作用域：es6中，一个{}就是一个块级作用域，
        let 声明的变量只能在声明他的{}中获取到
                ES6之前JS没有块级作用域
*/
/* 
闭包：
        外部函数中声明内部函数，
        在内部函数中引用了外部函数中定义的局部变量，
        此时外部函数执行完后变量会继续留在内存当中，
        不会被释放
*/
