/*
    JS中 栈和队列实现一般都要依赖于数组
    栈和队列
        特殊的数组
        两种运算受限的线性表
        两者区别在于各自对数组增删操作有不一样的限制
*/
/*
    数组添加元素三种方法：
        首unshift
        尾push
        任意splice
    数组删除元素三种方法
        首shift
        尾pop
        任意splice
*/

/*
    栈LIFO：只用pop和push完成增删的数组
*/
/*
    队列:只用push和shift完成增删的数组
*/
/*
    链表:(JS中的链表 是以嵌套的对象的形式来实现的)
        和数组相似 都是有序的列表 都是线性结构(有且仅有一个前驱/后继)
        不同：
            链表中数据单位的名称叫结点
            结点和结点的分布 在内存中可以是离散的
        数组：元素是连续的 每个元素内存地址可以根据其索引距离数组头部距离计算出来
            对数组来说 每一个元素都可以通过数组的索引下标直接定位      
        链表:每一个结点的结构都包含两部分内容
            数据域 存储当前结点所存储的数据值
            指针域 代表下一个结点(后续结点)的引用
            设定一个head指针来专门指向链表的开始位置
*/
// 链表结点的创建
function ListNode(val){
    this.val = val;
    this.next = null;
}
// 使用构造函数创建结点时
// 传入val 数据域对应的值内容
// 指定next 下一个链表结点
const node = new ListNode(1);
node.next = new ListNode(2);
// 以上创建出一个数据域值为1 next结点数据域值为2的链表节点

/*
链表的结点间关系是通过next指针来维系的
    链表元素的添加和删除操作 本质上都是在围绕next指针做文章
    任意两节点间插入一个新节点
        需要变更前驱节点和目标节点的next指向
*/

// 链表元素添加

const node1 = new ListNode(1);
const node2 = new ListNode(2);
node1.next = node2;

const node3 = new ListNode(3);
node1.next = node3;
node3.next = node2;

console.log(node1);

// 链表元素删除
// 删除操作重点不是定位目标节点 而是定位目标结点的前驱结点
// 删除 在链表的遍历过程中 无法再遍历到某个节点的存在

node1.next = node3.next;
console.log(node1);


/*
    数组增加/删除操作对应的复杂度是O(n)
    JS中不一定是(JS数组未必是真正的数组)
        只定义一种类型的元素 对应的是连续内存
        定义不同类型元素    对应的是非连续内存
            此时JS数组不再具有数组特征
            其底层使用哈希映射分配内存空间
            是由对象链表实现的
    链表添加删除元素：
        都不需要挪动多余元素
        链表中添加和删除操作复杂度固定O(n)
*/
// 访问
// 数组 O[1]
// 链表 O[n]

// 链表访问 试图读取某一个特定的链表结点时 必须遍历整个链表来查找它
const index = 10;
let node = head;
for(let i = 0 ;i<index&&node;i++){
    node = node.next;
}

/*
结论
    链表插入/删除效率较高 访问效率较低
    数组访问效率较高 插入/删除效率较低
*/






