1. 双向绑定
    1. 三种实行方法：(发布订阅者模式/脏值检查/数据劫持)
        目前几种主流的mvc(vm)框架都实现了双向数据绑定，
        而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。
        1. 发布者-订阅者模式(backbone.js)
            一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set('property', value)
        2. 脏值检查(angular.js)
            angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：
                1.DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
                2.XHR响应事件 ( $http )
                3.浏览器Location变更事件 ( $location )
                4.Timer事件( timeout ,interval )
                5.执行 digest() 或apply()
        3. 数据劫持(vue.js)
            vue.js 则是采用数据劫持(Object.defineProperty()来劫持)结合发布者-订阅者模式的方式.
            通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
2. 如何看待前端框架选型
3. Vue与React的组件化实现
    > Vue实现组件化
    - 通过.vue文件 创建对应的组件 Template 结构 script 行为 style 样式
    > React实现组件化
    - React中有组件化的概念 但没有像Vue这样的组件模板文件 React中一切都是以JS来表示的
    
    > React中组件&Props
    > (Vue中组件分为 全局组件/局部组件)
    
    > 组件分类
        函数组件(无状态组件)
        class组件(有状态组件)
    
    > 组件定义
    1. 所有的组件都应该显示在页面中
    2. 组件名必须首字母大写 否则会认为是HTML标签
    3. class组件必须继承自React.Component
    4. class组件必须有constructor做状态初始化
    5. class组件必须有render
    
    组件传参
        通过props来接受父组件通
4. Vue和jQuery区别
    1. Vue
        - (专注于数据层 通过数据双向绑定 最终表现在DOM层减少DOM操作)
        - 减少了DOM操作 Vue使用了组件化思想 使得项目子集职责清晰 提升开发效率 方便重复利用 便于协同开发
    2. jQuery(专注视图层 通过操作DOM实现页面的一些逻辑渲染)：
5. Vue与Angular区别
    1. 2.x Vue的双向绑定基于ES5中的getter/setter实现
    Angular由自己实现一套模板编译规则 需要进行所谓脏值检查
    Vue则不需要 因此Vue在性能上更高效 代价是对于IE9以下的浏览器无法支持
    2. Vue需要提供一个el对象进行实例化 后续的所有作用范围也是在el对象之下 Angular是整个HTML页面 一个页面可以有多个Vue实例 而Angular不是
6. Vue/Angular区别
    Vue/Angular
    相同点：
        1.都支持指令 内置指令和自定义指令
        2.都支持过滤器 内置过滤器和自定义过滤器
        3.都支持双向数据绑定
        4.都不支持低端浏览器
    不同点：
        1.Angular学习成本高 比如增加Dependency Injection特性 Vue.js本身实现的API都比较简单直观
        2.性能上Angular依赖对数据做脏检查 Watcher越多越慢 Vue使用基于依赖追踪的观察并使用异步队列更新 所有数据独立触发
7. 
    > MVC(Model View Controller)
    - View->Controller->Model->View 单向通信
    - 展示一个篮球的页面
    1. 设置一个篮球的模型等待使用
    2. 写一个需要展示篮球的视图
    3. 使用控制器让模型和视图交互
    
    > MVP(Model View Presenter) 
    - View Model不发生联系 通过Presenter传递 双向通信
    - View很薄 不部署任何业务逻辑 称为被动视图
    - Presenter很厚 所有业务逻辑都部署于此

    > MVVM(Model View ViewModel) 
    - vm是Vue对象 功能绑定到view上 Model中篮球更新或其他操作 通过vm通知派发至view
    - Vue和React都是借鉴MVVM思想+工程师自己的想法出现的两个框架  
    - 将Presenter改为ViewModel 其他基本与MVP一致
    - View Model不发生联系 通过Presenter传递 双向通信
    - (Model数据业务逻辑/View UI数据展示/ViewModel监听Model中数据的改变并控制视图更新处理用户交互操作)
    1. Model数据模型 数据和业务逻辑在此应用
    2. View UI视图 负责数据展示
    3. ViewModel负责监听Model中数据的改变并且控制视图更新 处理用户交互操作

    > MVC:(所有通信都是单向的)
    1. 通信方式：(单向View->Controller->Model->View)
        1. View(视图 用户页面) 传送指令到 Controller
        2. Controller(控制器 业务逻辑) 完成业务逻辑后，要求 Model 改变状态
        3. Model(模型 数据保存) 将新的数据发送到 View，用户得到反馈
    2. 互动模式：(1.View->Controller 2.Controller)
        - 接收用户指令时 MVC可以分成两种方式 
        1. 一种是通过View接受指令 传递给Controller
        2. 直接通过controller接受指令
    3. 实例Backbone
        > 实际项目往往采用更灵活的方式，以 Backbone.js 为例。
        1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。
        2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。
        3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器）

    > MVP(将controller改名为Presenter 同时改变了通信方向)：
    1. 各部分之间的通信，都是双向的。
    2. View 与 Model 不发生联系，都通过 Presenter 传递。
    3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。

    > MVVM:(MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。)
    1. Model代表数据模型 数据和业务逻辑都在Model中定义
    2. View代表UI视图 负责数据的展示
    3. ViewModel负责监听Model中数据的改变并且控制视图更新 处理用户交互操作
    - MVVM架构下 Model和View并无直接关联 通过ViewModel来进行联系
    - Model和ViewModel之间有着双向数据绑定的联系
    - 因此当Model中的数据改变时会触发View层刷新
    - View中由于用户交互操作而改变的数据也会在Model中同步
    - 这种模式实现了Model和View的数据自动同步 
    - 因此开发者只需要专注对数据的维护操作即可 而不需要自己操作DOM
    - 复杂的数据状态维护完全由 MVVM 来统一管理。
    > 唯一区别：
    它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。
    1. 各部分之间的通信，都是双向的
    2. 采用双向绑定：View 的变动，自动反映在 ViewModel，反之亦然

    > MVC(Model View Controller)
    - View->Controller->Model->View 单向通信
    > MVP(Model View Presenter) 
    - View Model不发生联系 通过Presenter传递 双向通信
    - View很薄 不部署任何业务逻辑 称为被动视图
    - Presenter很厚 所有业务逻辑都部署于此
    - 所以Backbone干脆取消了controller 留下了router
    > MVVM(Model View ViewModel) 
    - 将Presenter改为ViewModel 其他基本与MVP一致
    - View Model不发生联系 通过Presenter传递 双向通信
    - Model数据模型 数据和业务逻辑在此应用
    - View UI视图 负责数据展示
    - ViewModel负责监听Model中数据的改变并且控制视图更新 处理用户交互操作

    > MVC
    - M:Model模型
    - V:View视图
    - C:Controller控制器
    MVC:展示一个篮球的页面
    1. 设置一个篮球的模型等待使用
    2. 写一个需要展示篮球的视图
    3. 使用控制器让模型和视图交互
    
    > MVVM
    - VM:ViewModel视图模型
    - MVVM:
    - vm是vue对象,功能绑定到view上,Model中篮球更新或其他操作，通过vm通知派发至view
    - Vue和React都是借鉴mvvm思想+工程师自己的想法出现的两个框架
    - 各种MVVM框架 如Angular Regular Vue React 最大的优点是可以实现数据绑定 不需要手动进行DOM操作 它们实现的原理基本上是脏检查或数据劫持

    - 通过observer观察每个对象的属性 添加到订阅器Dep中 当数据发生变化时发出一个notice 作者使用ES6+flow写 代码在score/core/observer/index.js
    - 上面代码继承Array本身的原型方法 然后又做了劫持修改 可以发出通知
    - Vue会在observer数据阶段判断如果是数组 则修改数组原型
    - Vue还是不能检测到数据项和数组长度的变化 尽量避免这样的调用方式 作者实现了$set操作










