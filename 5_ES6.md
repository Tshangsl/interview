1.ES6有什么新特性以及对于ES6的理解,ECMAScript和JS的关系是什么
    1.新的声明函数和变量的关键字let/const
    2.解构赋值
    3.class/extend类声明与继承
    4.Set/Map:新的数据结构
    5.箭头函数
    6.promise
    7.async/await
    8，数组对象函数的扩展
    ECMAScript6是JavaScript语言的下一代标准，已经在2015年6月正式发布，它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言
    前者是后者的规格，后者是前者的一种实现
2.let const var 的区别 为什么var可以重复声明 为什么需要块级作用域
    let const var 都是声明函数和变量的关键字
    var和let/const的区别
        1.块级作用域
            ES5只有全局作用域和函数作用域，没有块级作用域。
                1.内层变量可能覆盖外层变量
                2.s用来计数的循环变量泄露为全局变量
        2.不存在变量提升
            暂时性死区和不能变量提升意义在于
                为了减少运行时错误 防止在变量声明前就是用这个变量 从而导致意料之外的行为
        3.暂时性死区
            只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的哪一行代码出现 才可获取和使用该变量
        4.不可重复声明
            let，const不允许在相同作用域内，重复声明同一个变量
        5.let const 声明的全局变量不会挂在顶层对象下
            1.浏览器环境的顶层对象是window
            2.node环境的顶层变量是global
            3.var声明的全局变量会挂在顶层对象下面 而let const不会挂在顶层对象下面
    const命令两个注意点
        1.let可以先声明再赋值，const声明后必须马上赋值，否则会报错
        2.const简单类型一旦声明就不能再更改 复杂类型(数组 对象等)指针指向的地址不能更改 内部数据可以更改     
    let，const使用场景
        1.let使用场景 变量 用以代替var
        2.const使用场景 常量 声明匿名函数 箭头函数的时候
    var可以重复声明的原理
        1.当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为a，并赋值为2，但在运行的时候编译器与引擎还会进行两项额外的操作：判断变量是否已经声明：
        2.首先编译器对代码进行分析拆解，从左至右遇见var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量a，若已经存在，则忽略var 继续向下编译，这时a = 2被编译成可执行的代码供引擎使用。
        3.引擎遇见a=2时同样会询问在当前的作用域下是否有变量a，若存在，则将a赋值为2（由于第一步编译器忽略了重复声明的var，且作用域中已经有a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量a则将其赋值2，若没有找到，则招呼作用域声明一个变量a并赋值为
3.如何理解同步和异步，async和await的用途
     同步：按照代码书写顺序一一执行处理指令的一种模式，上一段代码执行完才能执行下一段代码。
     异步：可以理解为一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务。
     JS之所以需要异步的原因在于JS是单线程运行的。
     常用的异步场景有：定时器、ajax请求、事件绑定。
     async函数是generator函数的语法糖 。
     async函数始终返回一个Promise，await可以实现一个"等待"的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行以及在发生异步的错误时提供更精准的错误信息
4.JS中的异步集合
    1、回调函数
        异步编程中最基础的方法
            1.同步回调
            2.异步回调
    2、事件监听
        JS中可以通过DOM绑定事件 实现异步事件监听
    3、发布 订阅/观察者模式
        它定义对象间的一对多依赖关系 
        当一个对象的状态发生改变时
        所有依赖于它的对象都将得到通知
    4、Promise对象/Promise A+对象
        1.Promise,就是一个对象，用来传递异步操作的消息 对象的状态不受外界影响
        2.Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。
        3.只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
        4.这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。
        Promise常用方法：
            1.Promise.all()方法 参数不一定是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise实例。 p的状态由p1、p2、p3决定，分成两种情况：
                1.只有p1、p2、p3的状态都变成Fulfilled，p的状态才会变成Fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
                2.只要p1、p2、p3中有一个被Rejected，p的状态就变成Rejected，此时第一个被Rejected的实例返回值会传递给p的回调函数。
            2.Promise.race()同样是将多个Promise实例，包装成一个新的Promise实例 只要p1、p2、p3中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值就传递给p的回调函数。
            3.Promise.resolve() 将现有对象转为promise对象 比如，bjquery的ajax返回的是deferred对象，通过promise的resolve()方法将其转换为promise对象。
            4.Promise.reject()返回一个新的promise实例，状态为reject
            5.Promise.prototype.then()方法 then方法是定义在原型对象Promise.prototype上的，作用是为Promise实例添加状态改变时的回调函数。 
            6.Promise.prototype.catch()方法 是.then(null,rejection)的别名，用于指定发生错误时的回调函数。
    5、es6中出现了Generator函数
        调用generator函数返回的是内部的指针对象，调用next方法就会移动内部指针。
        Generator函数之所以能被用来处理异步操作，因为它可以暂停执行和恢复执行、函数体内外的数据交换和错误处理机制。
        所以使用起来我们常常需要额外需要写一个自动执行generator函数的执行器函数
    6、es7中出现了async/await
        async函数基于Generator又做了几点改进：
            1、内置执行器，将Generator函数和自动执行器进一步包装。
            2、语义更清楚，async表示函数中有异步操作，await表示等待着紧跟在后边的表达式的结果。
            3、适用性更广泛，await后面可以跟promise对象和原始类型的值(Generator中不支持)
            它基于Promise使用async/await来优化then链的调用,其实也是Generator函数的语法糖。
            async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来
            await得到的就是返回值，其内部已经执行promise中resolve方法，然后将结果返回。
    5.怎么理解Promise对象，手写promise，或者问何如解决回调地域，如何拦截错误,resolve函数和reject函数作用
        1.所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
        2.从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
        3.Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。
            1.Promise可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
            2.Promise对象提供统一的接口，使得控制异步操作更加容易
        三个状态：
            等待中（pending）
            完成了（resolved）
            拒绝了（rejected）
        特点：
            1.对象的状态不受外界影响
            2.一旦状态改变就不会再变，任何时候都可以得到这个结果
        Promise缺点：
            首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。
            其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
            第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
        解决问题：
            Promise实际上解决jquery的ajax回调地域(层层嵌套)，只是异步编程的一种解决方案
            Promise 的出现解决了 之前的回调地狱问题,并且Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise ， 并且是一个全新的Promise 。
            是因为Promise 的状态不可变。如果你在then中使用了return ，那么 return 的值会被 Promise .resolve 包装。
        拦截错误：
            .catch
            1.使用catch方法捕捉错误，但是catch方法只能捕捉到同步错误，异步错误捕捉不到
            2.使用reject跑出错，错误会被不停地返回到下一个，必须在每一个then里面使用throw将错误派出去，不然不能被catch捕捉到，其实也可以不用再次throw错误，在promise正常catch就好，在异步中reject一下在最后就能catch到
            3.Promise中的错误不会影响到外层的运行，window.onerror也是无法检测道德
        resolve函数和reject函数作用：
            resolve函数将Promise对象的状态“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
            reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。    
            而一旦状态改变，就不会再变。 所以 代码中的reject('error'); 不会有作用。
            Promise 只能 resolve 一次，剩下的调用都会被忽略。 所以 第二次的 resolve('success2'); 也不会有作用。    

4.JS是如何实现异步的 EventLoop事件轮询和消息队列：(规定任务在浏览器中执行顺序)
    **JS引擎是单线程的，但又能实现异步的原因在于事件循环(EventLoop)和任务队列体系(Task Queue)。
    setTimeout 不属于 Javascript，它是由浏览器提供的 API（当然 Node.js 也有这个 API）。
    实现异步：
        1.回调函数
        2.Promise，
        3.订阅观察者模式
        4.generator
        5.Async/Await 
        6.setTimeout，setInterval
        7.事件监听
    ES6 为了引入 Promise 加入了微任务队列（Micro Task Queue），
    它的优先级高于消息队列（Message Queue），
    也就是说当调用栈清空后
    事件循环（The Event Loop）会率先将微任务队列的回调押入栈中执行，看如下代码：
    事件循环:..
    任务队列
    主线程

    3.异步的核心：
        回调函数 回调函数是所有异步编程的根基
    4.EventLoop事件轮询和消息队列：
        1.在真正的开发中，会有众多的同步任务和异步任务，那到底要按照什么顺序执行呢，这就牵扯到了事件轮询.
        2.简单的说就是一个规范，规定了任务在浏览器中的执行顺序，那这个顺序是什么，稍后再说，我们先要了解栈和队列。
    5.栈和队列:
        浏览器中会有一个调用栈(Call Stack)和消息队列(Queue)，当代码从上到下执行时，会把任务压入调用栈中执行，执行结束后会将任务弹出
    6.消息队列/回调队列
        消息队列是用来存放回调函数的容器，所以也称为回调队列，在调用栈清空时，浏览器开始轮询消息队列，按顺序执行消息队列中的任务。
    7.宏任务和微任务
        1.常见的宏任务有setTimeout，setInterval，UI交互事件等等，
        2.常见的微任务有Promise.then，Object.observe等等。这些其实只要记住就好。
            1.宏任务是由宿主发起的，比如浏览器或Node（本文不讨论Node，这里是举例）；而微任务是由JS引擎发起的
            2.宏任务会在另一个线程执行，微任务不会（你可能有疑问：JS不是单线程的吗？JS是单线程的没错，但是浏览器不是单线程的，比如setTimeout的倒计时是在浏览器的其他线程单独处理的）
            3.每次执行栈执行的代码就是一个宏任务，而微任务在当前 task 执行结束后立即执行的任务
    8.EventLoop(事件轮询/事件循环)的执行顺序
        作用：
            监听调用栈(Call Stack)和消息队列(Queue)
            一旦调用栈清空，EventLoop就会从消息队列中取出第一个回调函数 压入调用栈中执行
        EventLoop：
            1.代码从上到下执行，如果遇到微任务就放到微任务队列中，遇到宏任务就放到宏任务队列中.
            2.所有同步代码执行完成后，先去微任务队列里把所有的微任务都执行完，再去宏任务队列里按顺序执行宏任务.
            3.每执行完一个宏任务，就去微任务队列看看有没有产生新的微任务
            4.如果有就执行微任务，没有就执行下一个宏任务，直到所有任务都执行完。
7.require(CommonJS语法/后端服务器/原始导出值的复制/运行时动态加载/默认不是严格模式)
    /import(ES6语法/高版本的浏览器和Node/导出值的引用/静态编译/默认是严格模式)的区别
        1.require是CommonJS语法，import是ES6语法
        2.require只在后端服务器支持，import在高版本浏览器及Node中都可以支持
        3.require引入的是原始导出值的复制，import是导出值的引用
        4.require是运行时动态加载，import是静态编译
        5.require调用时默认不是严格模式，import则默认调用严格模式
8.Set(集合)、Map(字典)、WeakSet和WeakMap的区别
    Set和Map主要应用场景
        数组重组和数组存储
    Set：
        一种叫集合的数据结构 
        一种类数组的数据结构，成员的值都是唯一的没有重复值
        接受一个数组(或类似数组的对象)作为参数
        可以遍历，遍历顺序就是插入顺序
    Map：
        Map是一种叫字典的数据结构
        一种类似对象的数据结构，也是键值对的集合，键的范围不限于字符串，各种类型的值（包括对象）都可以当作键
        可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组
        Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键
        如果Map的键是一个简单数据类型的值(Number Boolean String)则只要两个值严格相等，Map将其视为一个键
        Map的遍历顺序就是插入顺序
    Set和数组最大区别
        1.成员无序且唯一，成员可以是任意类型
        2.Set的属性，操作方法及遍历方法与Map类似
    WeakSet和Set最大区别
        它的成员都是对象且都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用。
        如果其他对象都不在引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于WeakSet中，这个特点意味着，无法引用WeakSet的成员
        WeakSet不可以被遍历 没有size属性
    Map和Object最大区别
        1.Map能存储任意类型的key
        2.Map会保留key的类型 而Object会把key转换为string(Object的key还可以是symbol)
    Map遍历方法
        Map.prototype.keys()
        Map.prototype.values()
        Map.prototype.entries()
        Map.prototype.forEach()
    WeakMap结构和Map结构类似 区别在于
        WeakMap的键名只能是对象，且是弱引用对象。
        在没有其他引用和该键引用同一个对象，这个对象将会被回收，相应的key无效
        (垃圾回收机制不将该引用考虑在内)，所以其所对应的对象可能会被自动回收
        是没有遍历操作，即没有key()values()entries()方法 也没有size属性
        是无法清空，即不支持clear方法，这与WeakMap的键不被计入引用，被垃圾回收机制忽略有关，因此WeakMap只有四个方法可用get() set() has() delete()
        WeakMap不可以被遍历
        基本上WeakMap的专用场合就是它的键所对应的对象，可能会在将来消失，WeakMap接受有助于防止内存泄漏
9.箭头函数(没有原型=>本身没有this指针,this定义时确定,call apply bind不能改变，所以不可用做定义构造函数)和普通函数的区别
    1.箭头函数在语法上比普通函数更简洁
    2.箭头函数没有prototype(原型),所以箭头函数本身没有this
    3.箭头函数的this指向在函数定义时就继承自外层第一个普通函数的this，
        所以箭头函数的this指向在定义的时候就已经确定了，并且之后永远不会改变
    4.使用call apply bind 都不能改变箭头函数中this的指向
    5.因为箭头函数没有子集的this且不会改变，所以箭头函数不能用定义构造函数，否则使用new关键字会报错
    6.箭头函数内部没有arguments，而是rest参数(...)代替arguments对象来访问箭头函数的参数列表
    7.箭头函数不能用作Generator函数 不能使用yield关键字
    8.当要求动态上下文的时候，就不能使用箭头函数，也就是this的固化
10.模块化开发(ES6模块化 和CommonJS模块化开发标准)
    将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。 
    模块功能主要有两个命令构成 : export和 import。
    export命令用于规定模块的对外接口，
    import命令用于输入其他模块提供的功能。
    export命令：
        一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。
    import命令：
        使用 import 命令加载模块注意: import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口(如果导入的是对象,改写对象的属性是可以的,但是不建议轻易修改它的值)。
    export default命令：
        为模块指定默认输出
        export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。
        本质上，export default就是输出一个叫做default的变量或方法(指定对外接口为default)，然后系统允许你为它取任意名字。所以它后面不能跟变量声明语句。
12.ES6新增特性解构赋值
    1.左右两边解构必须一样
    2.右边必须是个合法的值
    3.声明和赋值不能分开
    数组解构 对象解构 字符串解构 函数参数解构(用数组对函数参数解构)
14.COMMONJS(运行时加载/同步)和ES6 MODULE(编译时输出/异步)的区别与共同点
    区别：
        1.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
        2.CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。
        3.CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤,即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。
        4.import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。
        5.CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
    共同点：
        CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。
        import/export 最终都是编译为 require/exports 来执行的。
15.COMMONJS/ES6模块化方案的不同
    CommonJS模块导出(require exports/module.exports)
    模块的内部 module变量代表的就是当前模块 它的exports属性就是对外的接口 加在某个模块 加载的就是module.exports属性 这个属性指向一个空的对象
    CommonJS module.exports与exports的区别
        1.exports是module.exports的引用
        2.给module.exports复制会切断与exports之间的联系
            直接添加属性 两者皆可
            复制操作时，只能用module.exports
    ES6模块化(import export 和export default)
    export和export default的区别
        1.export和export default均可用于导出常量，函数，文件，模块等。
        2.可以在其他文件或模块中通过import+(常量|函数|文件|模块)名的方式，将其导入，以便能对其进行使用
        3.在一个文件或模块中,export,import可以有多个，export defult仅有一个
        4.通过export方式导出，在导入时要加{},export default不需要
    使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名

    export语句输出的接口，与其对应的值时动态绑定关系，即通过该接口，可以取到模块内部实时的值
    CommonJS规范，CommonJS模块输出的时值的缓存，不存在动态更新
    export命令规定的时对外的接口，必须与模块内部的变量简历一一对应关系
15.什么是babel
    Babel：
        一个JavaScript编译器
        Babel是一个工具链 
        主要用于将ECMAScript 2015+版本的代码
        转换为向后兼容的JavaScript语法
        以便能够运行在当前和旧版本的浏览器或其他环境中
        通过语法转换器来支持新版本的javascript
17.ES6中对函数的扩展
    1.es6中对于函数参数默认值的扩展
    2.rest 不用写rest 写其他的也可以
    3.新增两个属性 length
    4.箭头函数
18. 普通函数的this指向问题(谁调用的这个方法 谁触发的这个事件 this指向谁)以及改变this指向的三种方法 和箭头函数的this指向
        1.事件处理函数中 this =>绑定事件的dom元素
        2.定时器中 this=>window
        3.自定义函数中 this=>window
        4.自定义对象中 this=>该对象
        5.自定义类中new一个对象 this=>new出来的实例化对象

        1.call(this,arg1,arg2,arg3)
        2.apply(this,[arg1,arg2,arg3])其他参数以数组形式传过去
        3.bind(this,arg1,arg2,arg3)需要手动调用

        1.this指向的使定义时所在的对象，而不是调用时所在对象
        2.箭头函数没有this 它的父作用域中的this是谁 箭头函数中的this就是谁
        3.如果箭头函数被非箭头函数包含 
        那它的this指向的就是它最近的内层非箭头函数中的this 否则就是window
20.有ABC三个请求 AB请求同时执行 但是不一定同时结束 要求在AB请求结束后 再执行C请求 应该怎么写
    可以使用Promise.all(A,B).then(C)把AB作为一个数组传入 
21.单页面应用优缺点
    优点：
        1.用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小
        2.前后端分离
        3.页面效果会比较炫酷（比如切换页面内容时的专场动画）
    缺点：
        1.不利于seo
        2.导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）
        3.初次加载时耗时多
        4.页面复杂度提高很多
22.promise和async await区别
    Async Await
        1.是写异步代码的新方式 以前的方法有回调函数和Promise
        2.是基于Promise实现的 它不能用于普通的回调函数
        3.与Promise一样是非阻塞的
        4.使得异步代码看起来像同步代码
    Async Await写和Promise写区别
        1.函数前面多了一个async关键字 await关键字只能用在async定义的函数内 async会隐式地返回一个Promise 该Promise的resolve值就是函数return的值
    Async Await处理异步的优点
        1.让代码简洁很多 不需要像Promise一样需要写then 不需要写匿名函数处理Promise的resolve值 也不需要定义多余的data变量，还避免了嵌套代码。
        2.错误处理
        Async/Await 让 try/catch 可以同时处理同步和异步错误。在下面的promise示例中，try/catch 不能处理 JSON.parse 的错误，因为它在Promise中。我们需要使用 .catch，这样错误处理代码非常冗余。并且，在我们的实际生产代码会更加复杂。
        使用aync/await的话，catch能处理JSON.parse错误:
        3.条件语句
        条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句
23.await后面如果接了一个promise return null 或 return false 它接下会执行什么 resolve
24.如果在promise.then中抛出一个错误应该怎么做


