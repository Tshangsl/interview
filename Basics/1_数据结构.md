1. 绪论
2. 线性表
    1. 线性表/线性结构 随机访问/链式结构 顺序访问
        顺序表
        线性链表    指针描述
        静态链表    数组描述
        循环链表
        双向链表
        双向循环链表
    线性顺序存储结构和链式存储结构区别优缺点
        顺序存储 适用于查找
            优点:存储密度大(=1) 易于查找和修改
            缺点:插入或删除元素时不方便 存储空间利用率低
                预先分配内存可能会造成存储空间的浪费
        链式存储  适用于插入/删除
            优点:插入或删除元素时很方便 使用灵活 存储空间利用率高
            缺点:存储密度小(<1)查找和修改需要遍历整个链表
3. 栈和队列
4. 串
5. 数组和广义表
6. 树和二叉树
    DFS 栈
    BFS 队列
    AVL平衡二叉树有什么特点 好处 和红黑树的区别
    AVL
        平衡二叉树又称AVL树，是一种特殊的二叉查找树
        其左右子数都是平衡二叉树且左右子树高度差的绝对值不超过1
        一句话表述为：
        以树中所有结点为根的树的左右子树高度差的绝对值不超过1.将二叉树上结点的左子树深度减去右子树深度称为平衡因子BF
        那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1.只要二叉树上有一个结点的平衡因子的绝对值大于1，该二叉树就是不平衡的。
    红黑树
        是一种二叉查找树
        但在每个结点增加一个存储位表示结点的颜色，可以是红或者黑（非黑即红）。
        通过对任何一条从根到叶子的路径上各个结点着色的方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因此红黑树是一种弱平衡二叉树
        相对于要求严格的AVL树来说，它的旋转次数少
        所以对于搜索、插入、删除操作比较多的情况下，通常使用红黑树。
        性质
            1.每个结点非红即黑
            2.根节点是黑的
            3.每个叶节点（叶节点即树尾端NULL指针或NULL结点）都是黑的
            4.如果一个结点是红色的，则它的子节点必须是黑色的
            5.对于任何结点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑结点。
    区别：
        AVL树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；
        红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。
7. 图
数据结构
1.如何判断一个环是一个闭着的
2.JS中对象的数据结构在底层是用什么实现的
3.100个数中找出最大的用什么方法

- 基础排序算法：
    1. 冒泡排序 最好O(n) 最坏O(n^2) 平均(n^2)
        冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动。
        每一轮操作都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了
    2. 插入排序 最好O(n) 最坏O(n^2) 平均(n^2)
        插入排序的核心思想是“找到元素在它前面那个序列中的正确位置”。
        具体来说，插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。
    3. 选择排序 都是O(n^2)
        选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。
- 进阶排序算法(分治)
    4. 归并排序 O(nlog(n))
        归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：
            分解子问题：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
            求解每个子问题：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
            合并子问题的解，得出大问题的解：当数组被合并至原有的规模时，就得到了一个完全排序的数组
    5. 快速排序 最好O(nlog(n)) 最坏O(n^2) 平均(nlog(n))
        快速排序在基本思想上和归并排序是一致的，仍然坚持“分而治之”的原则不动摇。区别在于，快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序。
        思路分析
            快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。
> 算法
1. 递归与分治
    > 递归 :直接或间接调用自身的算法称为递归算法 用函数自身给出定义的函数称为递归函数 每个递归函数都必须有非递归定义的初始值 否则递归函数就无法计算
    > 分治:将一个难以直接解决的大问题 分割成一些规模较小的相同问题 这些子问题互相独立且与原问题相同 递归地解这些子问题 然后将各子问题的解合并起来得到原问题的解 由分治法产生的子问题往往是原问题的较小模式 为使用递归技术提供方便
    > 二分搜索:充分利用元素间次序关系 采用分治策略 可在最坏情况下用O(logn)时间完成搜索任务
2. 动态规划
    - 适用于动态规划法求解的问题 经分解得到的子问题往往不是互相独立的
    基本思想
        可以用一个表来记录所有已解决的子问题的答案 不管盖子问题以后是否被用到 只要它被计算过就将其结果填入表中
    动态规划算法适用于解最优化问题
        1.找出最优解的性质 并刻画其结构性质
        2.递归地定义最优值
        3.以自底向上的方式计算出最优值
        4.根据计算最优值时得到的信息 构造最优解
    0-1背包问题
3. 贪心
    总是做出在当前看来最好的选择
    并不从整体最优上加以考虑 所做出的选择只是在某种意义上的局部最优解
    两个性质
        1.贪心选择性
        2.最优子结构性质
    与动态规划算法
    相同
        1.都要求最优子结构
    差别
    单源最短路径
    哈夫曼编码
    最小生成树
4. 回溯(找出解空间中满足约束条件的所有解)
    有通用的解题方法之称 用它可以系统地搜索一个问题的所有解或任一解
    回溯算法是一个既带有系统性又带有跳跃性的搜索算法
    回溯法搜索解空间树 采用两种策略避免无效搜索
        1.约束函数在扩展结点处剪去不满足约束的子树
        2.用限制函数剪去得不到最优解的子树
        这两类函数统称为剪枝函数
    0-1背包
5. 分支限界(找出满足约束条件的一个解)
    类似回溯法 也是在问题的解空间上搜索问题解的算法
    两者求解目标不同
        回溯法
            找出解空间中满足约束条件的所有解
        分支限界法
            找出满足约束条件的一个解
            或是在满足约束条件的解中找出使得木易目标函数值达到极大值或极小值的解
            即在某种意义下的最优解
    对解空间的搜索方式也不同
        回溯法
            深度优先方式搜索解空间
        分支限界法
            广度优先或最小耗费优先方式搜索解空间
6. 随机化
    一个基本特征 对所求解问题的同一实例 用同一随机化算法求解两次可能得到完全不同的效果
    大致分四类
        1.数值随机化算法
            常用于数值问题的求解 这类算法得到的往往是近似解 且近似解的精度随计算时间的增加而不断提高
        2.蒙特卡罗算法
            求问题的准确解
            能求得问题的一个解 但是这个解未必是正确的
        3.拉斯维加斯算法
            不会得到不正确的解
            一旦找到一个解 这个解就是正确的解
        4.舍伍德算法
            总能求得问题的一个解 且所求的解总是正确的
1.数据结构层面
数组
栈
队列
链表
树（这里我们着重讲二叉树）
2.数组
1.创建
const arr = (new Array(7)).fill(1)
如此便可以得到一个长度为7，且每个元素都初始化为1的数组：
访问遍历
for
    从性能上看，for 循环遍历起来是最快的
forEach
map
2.二维数组
矩阵<=>二维数组
初始化:
fills arr[0][0] = 1  发现一整列的元素都被设为了 1    
工作机制
当你给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。
7个数组对应了同一个引用、指向的是同一块内存空间，它们本质上是同一个数组。s
for 循环
const len = arr.length
for(let i=0;i<len;i++) {
    // 将数组的每一个坑位初始化为数组
    arr[i] = []
}
for 循环中，每一次迭代我们都通过“[]”来创建一个新的数组，这样便不会有引用指向问题带来的尴尬。
访问：
双层循环
3.栈和队列(两者的区别在于，它们各自对数组的增删操作有着不一样的限制)
在 JavaScript 中，栈和队列的实现一般都要依赖于数组，大家完全可以把栈和队列都看作是“特别的数组”。

实际上，栈和队列作为两种运算受限的线性表，用链表来实现也是没问题的。只是从前端面试做题的角度来说，基于链表来实现栈和队列约等于脱裤子放屁（链表实现起来会比数组麻烦得多，做不到开箱即用），基本没人会这么干。这里大家按照数组的思路往下走就行了

两者的区别在于，它们各自对数组的增删操作有着不一样的限制。因此，在学习栈与队列之前，我们需要先来明确一下数组中的增删操作具有什么样的特性、对应的方法有哪些：

数组中增加元素的三种方法
1.unshift 方法-添加元素到数组的头部
2.push 方法-添加元素到数组的尾部
3.splice 方法-添加元素到数组的任何位置

const arr = [1,2] 
arr.splice(1,0,3) // [1,3,2]

数组中删除元素的三种方法
1.shift 方法-删除数组头部的元素
2.pop 方法-删除数组尾部的元素
3.splice 方法-删除数组任意位置的元素

栈stack 只用 pop 和 push 完成增删的“数组”
栈是一种后进先出(LIFO，Last In First Out)的数据结构。
只允许从尾部添加元素
只允许从尾部取出元素
对应到数组的方法，刚好就是 push 和 pop。
因此，我们可以认为在 JavaScript 中，栈就是限制只能用 push 来添加元素，同时只能用 pop 来移除元素的一种特殊的数组。

队列（Queue）——只用 push 和 shift 完成增删的“数组”
队列是一种先进先出（FIFO，First In First Out）的数据结构。
只允许从尾部添加元素
只允许从头部移除元素

链表
链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。
这个“离散”是相对于数组的“连续”来说的
数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段连续的内存空间。元素与元素之间，紧紧相连（当然啦，还有二般情况，我们在下文的辨析环节会提到）。
而链表中的结点，则允许散落在内存空间的各个角落里。

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}   

数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了如下的联系：

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：
链表结点的创建
创建链表结点，咱们需要一个构造函数：
function ListNode(val) {
    this.val = val;
    this.next = null;
}
在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：
const node = new ListNode(1)  
node.next = new ListNode(2)
添加：
    直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。
插入：
    变更的是前驱结点和目标结点的 next 指针指向，
    // 如果目标结点本来不存在，那么记得手动创建
    const node3 = new ListNode(3)     
    // 把node3的 next 指针指向 node2（即 node1.next）
    node3.next = node1.next
    // 把node1的 next 指针指向 node3
    node1.next = node3
链表元素的删除(前驱节点)
    node1.next = node3.next 
    在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。比如说咱们这个题里，其实只要能拿到 node1 就行了：
    // 利用 node1 可以定位到 node3
const target = node1.next  
node1.next = target.next

链表和数组的辨析
    数组增加/删除操作对应的复杂度就是 O(n)。
    JS 中不一定是
    它是一个纯数字数组，那么对应的确实是连续内存。
    但如果我们定义了不同类型的元素：
    它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。
    JS 数组未必是真正的数组
    相对于数组来说，链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。

    高效的增删操作
    在链表中，添加和删除操作的复杂度是固定的 
    链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

    麻烦的访问操作
    当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

    // 记录目标结点的位置
    const index = 10  
    // 设一个游标指向链表第一个结点，从第一个结点开始遍历
    let node = head  
    // 反复遍历到第10个结点为止
    for(let i=0;i<index&&node;i++) {
        node = node.next
    }

    随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

    但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：

小结：
    链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。这个特性需要大家牢记，可能会作为数据结构选型的依据来单独考察。
树：
树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
“叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。
二叉树
二叉树是指满足以下要求的树：

1.它可以没有根结点，作为一棵空树存在
2.如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。如下图：
    
，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

二叉树的编码实现

在 JS 中，二叉树使用对象来定义。它的结构分为三块：
数据域
左侧子结点（左子树根结点）的引用
右侧子结点（右子树根结点）的引用
在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：
// 二叉树结点的构造函数
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}
当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：
const node  = new TreeNode(1)
如此便能得到一个值为 1 的二叉树结点，从结构上来说，它长这样：
以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：
二叉树的遍历——命题思路解读
以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：
递归遍历
    先序遍历(根左右)
        根结点 -> 左子树 -> 右子树
    中序遍历(左根右)
        左子树 -> 根结点 -> 右子树
    后序遍历(左右根)
        左子树 -> 右子树 -> 根结点
迭代遍历
    层次遍历
按照实现方式的不同，遍历方式又可以分为以下两种：
    递归遍历（先、中、后序遍历）
    迭代遍历（层次遍历）

编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。

它可以没有根结点，作为一棵空树存在
如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};


递归函数的编写要点

编写一个递归函数之前，大家首先要明确两样东西：
递归式 根结点 -> 左子树 -> 右子树 
递归边界 
在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。

先序遍历
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}

中序遍历
唯一的区别只是把遍历顺序调换了左子树 -> 根结点 -> 右子树：
递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。我们参考先序遍历的分析思路，来写中序遍历的代码：
// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}

后序遍历
先访问左子树，再访问右子树，最后访问根结点
在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}

时间复杂度 空间复杂度

在所有的 for 循环里，判断语句都会比递增语句多执行一次。在这里，判断语句执行的次数就是 n+1。
计算T(n) -> 推导O(n) 
实际操作中，O(n) 基本可以目测
常见的时间复杂度表达，除了多项式以外，还有logn

常见时间复杂度按照从小到大的顺序排列 有以下几种
常数时间：O(1)
对数时间:O(logn)
线性时间:O(n)
线性对数时间:O(blogn)
二次时间:O(n^2)
三次时间:O(n^3)
指数时间:O(2^n)

空间复杂度
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。和时间复杂度相似，它是内存增长的趋势。
常见的空间复杂度有 O(1)、O(n) 和 O(n^2)。