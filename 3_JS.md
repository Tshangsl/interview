1.JS有哪些数据类型，数据类型之间有哪些不同，判断数据类型的方法
    基本数据类型:String Number Boolean Undefined Null Symbol
    引用数据类型:Object(对象Object 数组Array 函数Function) 
        ES2020即ES11 又增加了新类型 BigInt
    区别：
        两者作为函数的参数进行传递时：
            基本数据类型传入的是数据的副本，原数据的更改不会影响传入后的数据。
            引用数据类型传入的是数据的引用地址，原数据的更改会影响传入后的数据。
        两者在内存中的存储位置：
            基本数据类型存储在栈中。
            引用数据类型在栈中存储了指针，该指针指向的数据实体存储在堆中。
    判断一个变量是基本数据类型还是引用数据类型方法：
        1.typeof运算符判断类型
        typeof(null) Object;
        typeof(NaN) Number
        null == undefined  返回true，因为undefined派生自null;
        null === undefined  返回false。
        2.A instanceof B(引用数据类型)可以用来判断A是否为B的实例，但它不能检测 null 和 undefined；
        3.B.constructor == A可以判断A是否为B的原型，但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。
        4.Object.prototype.toString.call() 是最准确最常用的方式。
2.浅拷贝和深拷贝都是什么含义，有什么不同，如何实现
    1.浅拷贝只复制指向某个对象的指针，而不复制对象本身。
        （1）Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝；
        （2）扩展运算符；
    2.深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。
         (1) 手写遍历递归赋值；
        （2）结合使用JSON.parse()和JSON.stringify()方法。
3.如何理解JS中的this关键字，this的指向以及如何改变this的指向
    this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象
    全局环境：this始终指向window对象
    局部环境：
            1.全局作用域下直接调用函数，this指向window
            2.对象函数调用，那个对象调用就指向那个对象
            3.使用 new 实例化对象，在构造函数中的this指向实例化对象。
            4.使用call或apply或bind改变this的指向。
    this指向的改变方法 call(参数列表) apply(参数数组) bind
    改变this指向的几种方法：
    1.使用箭头函数
    2.在函数内部使用_this = this
    3.用apply call bind 改变
    4.new一个实例化对象
    非严格模式下
        如果函数没有用作构造函数 而是仅仅作为普通函数使用的话 那么函数中的this是指向window的
    严格模式下this是一个undefined
4.call(参数列表) apply(参数数组) bind 作用
    首先要了解this的指向问题：
        （1）this的指向不是在函数定义时确定的，而是在函数调用时确定，this默认情况下指向window，严格模式下为undefined
        （2）使用new 调用构造函数时，构造函数内的this 指向新创建的对象
        （3）通过 出call/apply/bind方法显式调用函数时，函数内this 指向指定的对象（第一个参数）
        （4）通过上下文对象A调用函数时，函数内this指向对象A
         (5）箭头函数本身并不存在this，箭头函数的this的指向由它的外层作用域来决定的（指向外层作用域的this）
    call和apply、bind
        作用：在函数调用时改变函数的执行上下文也就是this的值指向
        区别：call采用不定长的参数列表，而apply使用一个参数数组。
5.什么是作用域(scope)和作用域链(scope chain)？
    作用域：
        1.作用域是可访问变量的集合
        2.在JavaScript中，对象和函数同样也是变量
        3.在JavaScript中，作用域为可访问变量，对象，函数的集合
        4.分为全局作用域和局部作用域(函数作用域块级作用域)
    全局作用域:
        贯穿整个javascript文档，在所有函数声明或者大括号之外定义的变量，都在全局作用域里，一旦声明一个全局变量，那么你可以在任何地方都使用它，包括函数内部，事实上，javascript默认拥有一个全局对象window，声明一个全局变量就是为window对象的同名属性赋值
      注：若变量在函数内部没有声明(未使用var关键字)，该变量为全局变量，全局变量在页面关闭后销毁
    局部作用域:(函数作用域和块级作用域)
        在JavaScript中，任何定义在函数体内的变量或者函数都将处在函数作用域中，这些变量也无法在函数外部使用。(闭包除外)
        1.变量在函数内声明，变量属于局部作用域
        2.局部变量：只能在函数内部访问
        3.局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量
        4.局部变量在函数开始执行时创建，函数执行后局部变量会自动销毁
      注：当函数体内局部变量和函数外局部变量重名时，函数内部优先使用自己的变量
    作用域链：
        1.遍历嵌套作用链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找，当抵达最外层全局作用域时，无论找到还是没找到，查找过程都会停止
        2.简单来说，局部作用域(如函数作用域)可以访问全局作用域中的变量和方法，而全局作用域不能访问局部作用域的变量和方法
        3.函数被调用之前作用域已经存在
        4.是js中的一种查找机制，从当前作用域查找，当前作用域没有往上一级作用域查找，一直到最外层，如果都找不到则是is not define
6.JS中实现继承的方法有哪些
    1.class+extends继承(ES6)
    2.原型链实现继承
        ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。
        基本思想：
            利用原型让一个引用类型继承另一个引用类型的属性和方法
        构造函数&原型&实例关系：
            每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。
        存在的问题：
            1.最主要的问题来自包含引用类型值的原型
            2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链
    3.借用构造函数继承
        子类型构造函数的内部调用超类型构造函数
    4.组合继承
        定义：
            1.有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式
            2.背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
            3.既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性
        组合继承：
            避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf也能够用于识别基于组合继承创建的对象。
        无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部
    5.原型式继承
    6.寄生式继承
    7.寄生组合式继承(combination inheritance)
7.什么是闭包,闭包的作用是什么
    JavaSscript中每创建一个函数 闭包也会随之产生 它是基于词法作用域书写代码自然产生的结果
    产生条件：
        当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的
    概括：
        1.闭包会在函数被创建时，自动根据器所在的词法作用域产生
        2.闭包主要是在函数不在所在的词法作用域中执行的情况下作用的
        在外部函数的内部声明内部函数，在内部函数里引用了外部函数中的局部变量，当外部函数调用完毕后，局部变量不被释放
    闭包的最大作用：延长作用域的生命周期
        如常见的防抖(debounce)函数
    闭包的副作用：内存泄漏
8.说一说JS的IIFE，为什么要使用它
    IIFE：(Immediately Invoked Function Expression),意为立即调用的函数表达式，即声明函数的同时立刻调用这个函数
    目的：
        弥补JS在scope(作用域)方面的缺陷，JS只有全局作用域(global scope)，函数作用域(function scope),从ES6开始才有块级作用域(block scope) 对比其他面向对象语言 JS在访问控制方面脆弱 为了实现作用域的隔离
    常见形式:
        ()();
        (())
    IIFE可以带多个参数
    总结：IIFE的目的是隔离作用域，防止污染全局命名空间
9.什么是原型，原型链
    原型也是一个对象 也可以用_proto_获取它的原型(原型的原型)
        person._proto === Person.prototype
    原型中的constructor属性 指向构造函数
    Person === Person.prototype.constructor;
    Object.prototype._proto_ null 即Object.prototype没有原型
    由相互关联的原型组成的链状结构就是原型链 

    1.子类的_proto_属性，表示构造函数的继承，总是指向父类
    2.子类prototype属性的_proto_属性表示方法的继承 总是指向父类的prototype属性

    理解：
        1.作为一个对象 子类的原型是父类
            C._proto_ === F
        2.作为一个构造函数 子类的原型对象是父类的原型对象的实例
            C.prototype._proto_ === F.prototype

    _proto_
    每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法
    对象_proto_属性的值就是它所对应的原型对象

    prototype
    只有函数才有prototype属性
    当你创建函数时，JS会为这个函数自动添加prototype属性，值是一个有constructor属性的对象
    而一旦你把这个函数当作构造函数(constructor)调用(即通过new关键字调用)那么JS就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法(实例通过设置自己的_proto_指向构造函数的prototype来实现这种继承)

    function a() {} //构造函数a可以通过prototype来存属性和方法
    var b = new a(); //b是实例对象
    b.__proto__ === a.prototype; //对象通过__proto__指向自己的构造函数的prototype

    JS是单继承的Object.prototype是原型链的顶端，所有对象从它继承了包括toString等等方法和属性

    一个ES5方法 可以获得对象原型
    Object.getPrototypeOf(person) === Person.prototype
    创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。
    当一个对象调用某个方法或者属性的时候，先在自身查找，如果找到就调用，如果没有就顺着__proto__到原型对象中查找，如果还没有就继续去原型的原型中查找，一直到null，这样形成一条链叫做原型链。如果还没有找到就返回undefined
10.什么是防抖(最后一次)和节流(冷却一段时间) 如何实现
    防抖和节流都是防止短时间内高频触发事件的方案。
    防抖的原理是：如果一定时间内多次执行了某事件，则只执行其中的最后一次。
    节流的原理是：要执行的事件每隔一段时间会被冷却，无法执行。
    应用场景有：搜索框实时搜索，滚动改变相关的事件。
11.什么是执行上下文和执行栈
    执行上下文：
        1.函数每调用一次，都会产生一个新的执行上下文环境
        2.因为不同的调用，可能就会有不同的参数
        3.因此执行上下文是在执行的时候定义的
    执行上下文三个：
        全局执行上下文
            全局执行上下文只有一个,在客户端一般由浏览器创建，也就是我们熟知的window对象，我们能通过this直接访问到它
            任何不在函数内部的代码都在全局上下文中，它会执行两件事。
            1.创建一个全局Window对象(浏览器的情况下)。
            2.并设置this的值等于这个全局对象，一个程序中只能有一个全局执行上下文
        函数执行上下文
            每当一个函数被调用时，都会为该函数创建一个新的上下文。
            1.每个函数都有它自己的执行上下文。
            2.是在函数被调用时创建的。
            3.函数执行上下文可以有多个
        Eval函数执行上下文(没有过多了解)
            执行在eval函数内部的代码也会有它属于自己的执行上下文
    特点：
        1.单线程，在主线程上运行
        2.同步执行，从上往下按顺序执行
        3.全局上下文只有一个，在关闭浏览器时会被弹出栈
        4.函数执行上下文没有数目限制
        5.函数没被调用一次，都会产生一个新的执行上下文环境
    执行栈：
        也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
        1.当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。
        2.每当引擎遇到一个函数被调用，它会该函数创建一个新的执行上下文并压入栈的顶部。
        2.引擎会执行那些执行上下文位于栈顶的函数，当函数执行结束时，执行上下文会栈中弹出，控制流程到达当前栈中的下一个上下文。
    执行上下文和执行栈存在的意义：
        1.变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。
        2.每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。
        3.每个函数调用都有自己的上下文。
        4.当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文。
        5.在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 
        6.JS的执行流就是通过这个执行栈进行控制的。
    PS：this只是执行上下文的一部分
12.作用域和执行上下文的区别是什么？
    1.作用域是和每次函数调用时变量的访问有关，并且每次调用都是独立的
    2.作用域是在函数定义时就已经确定了，不是在函数调用时确定
    3.此处区别于执行上下文(this也是上下文环境里的成分)
    4.作用域只是一个地盘，其中没有变量，变量是通过作用域对应的执行上下文环境中的变量对象来实现的
    5.作用域是静态观念的 执行上下文环境是动态上的 两者并不一样
    6.有闭包存在时，一个作用域存在两个上下文环境也是有的
    7.作用域只是用于划分你在这个作用域里面定义的变量的有效范围，出了这个作用域就无效
    8.同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值
    9.作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。
    10.如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。
        1.执行上下文总是关键字this的值 是调用当前可执行代码的对象的引用
        2.作用域是函数定义的时候就确定好的 函数当中的变量适合函数所处的作用域有关，函数运行的作用域也是与该函数定义时的作用域有关
        3.上下文，主要是关键字this的值，这个是由函数运行时决定的，简单来说就是谁调用此函数，this就指向谁。
13.BFC(块级格式化上下文规则)和IFC BFC是什么 有哪几种实现方式 分别适用于哪些场景
    BFC:
        BFC(Block formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，只有Block-level box参与 它规定了内部的Block-level Box如何布局 并且和这个区域外部毫不相干
    Box：css布局基本单位
        Box是CSS布局的对象和基本单位 直观点来说 一个页面是由很多个 Box 组成的。
        元素的类型和 display 属性，决定了这个 Box 的类型。
        不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器）
        因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：
            1.block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；
            2.inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；
            3.run-in box: css3 中才有
    Formatting Context：
        是W3C CSS2.1规范中的一个概念 它是页面中的一块渲染区域 并且有一套渲染规则 它决定了其子元素将如何定位 以及和其他元素的关系和相互作用
        最常见的Formatting Context有
            1.Block Fromatting Context BFC
                BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
            2.Inline Formatting Context IFC
    BFC布局规则：
        1.内部的Box会在垂直方向 一个接一个地放置
        2.Box垂直方向的距离由margin决定 属于同一个BFC的两个相邻Box的margin会发生重叠
        3.每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
        4.BFC的区域不会与float box重叠。
        5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
        6.计算BFC的高度时，浮动元素也参与计算。
    如何创建BFC：
        1.float的值不是none。
        2.position的值不是static或者relative。
        3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex
        4.overflow的值不是visible
    BFC作用：
        1.利用BFC避免margin重叠。
            根据：属于同一个BFC的两个相邻的Box会发生margin重叠
        2.自适应两栏布局
            根据：
                1.每个盒子的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
                2.BFC的区域不会与float box重叠。
                3.清除浮动……
    总结：
        BFC就是页面上的一个隔离的独立容器 容器里面的子元素不会影响到外面的元素 反之也是如此

        因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。

            当一个元素具备了触发新块格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则此时这个元素会收缩到适当大小 不仅行盒子如此 所有盒子都如此
15.事件冒泡和捕获
    事件冒泡:(从里向外)
        事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。简而言之，就是由里向外进行冒泡。
    事件捕获:(从外向里)
        是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于事件到达预定目标之前捕获它。
17.数组去重
    1.indexOf()
        1.新建一个空数组
        2.遍历原数组
        3.用indexOf()判断循环出来的元素下标是否和元素在数组中的索引是否相等
        4.如果相等则说明这是一个不重复的元素，则把数据推送至新数组中
    2.indexOf()/splice()
        1.遍历数组
        2.用indexOf()判断循环出来元素下标是否和元素在数组中的索引是否不相等
        3.如果不相等（则说明这是一个 的元素），则把该元素从数组中删除
        4.删除后数组长度变短，所以索引也要减一
    3.splice()
        1.循环两次数组
        2.判断每次循环的值是否一样并且下标不一样，找到后截去第二重数组所对应的下标位置的这个元素
        3.原数组则会变成去重后的新数组
    4.ES6写法
        1.new Set() Set结构不会添加重复的值
        2.扩展运算符...转成数组
    5.ES6写法
        1.new Set() Set结构不会添加重复的值
        2.Array.from()转成数组
    6.reduce方法
        .....
18.数组遍历方法和操作
    1.keys
    2.values
    3.entries
    4.forEach 遍历数组中的每一个元素，默认没有返回值 forEach方法不改变原数组
    5.filter 
        对数组元素进行条件筛选 返回一个数组 将原数组符合条件的元素放入数组中 
        filter方法不改变原数组
    6.reduce 
        reduce(callback(total,item,index,arr),initial)方法有两个参数 
        1.第一个参数是一个回调函数必须 
        2.第二个参数是初始值可选 
        数组将上一次的返回值作为下一次循环的初始值 最后将这个结果返回 
        如果没有初始值 则reduce会将数组的第一个元素作为循环开始的初始值
        常用于数组元素的累加累乘 
        reduce方法不改变原数组
    7.map 返回一个数组 这个新数组的每一个元素都是原数组元素执行了回调函数之后的返回值 
        map方法不改变原数组
    8.for of 具有interator(迭代器)接口的数据都可以使用for of 进行遍历
                常见的有数组 类数组 Set Map等 不包含对象
                如果想用for of的方法遍历数组并使用索引index 
                可以用for of遍历arr.entries()方法
    9.some every方法(返回布尔值)：some和every的用法类似 数组的每一个元素都会执行回调函数 
        当返回值全为true时 every方法返回true 否则返回false 
        当返回值全为false时 some方法返回false 否则返回true
        some every 方法不改变原数组
19.对象遍历方法
    1.for in 
        循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)
    2.Object.keys(obj):
        返回一个数组 包含对象自身的所有可枚举属性(不含继承和Symbol属性)
    3.Object.getOwnPropertyNames(obj):返回一个数组 包含对象自身的所有属性(不含Symbol属性 包含不可枚举属性)
    4.Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性。
    5.Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性（不含继承的）。
20.JS哪些操作会造成内存泄露,以及避免内存泄漏
    内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。 
    GC(Garbage Collection System)垃圾回收系统
        标记清楚(较常用)
        引用计数
        1.意外的全局变量
        2.闭包(存在堆内存中)
        3.没有清理的DOM元素引用
        4.被遗忘的定时器或回调
        5.子元素存在引起的内存泄漏
        6.IE7/8引用计数使用循环引用产生的问题
    避免内存泄漏
        1.减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；
        2.注意程序逻辑，避免“死循环”之类的 ；
        3.避免创建过多的对象  原则：不用了的东西要及时归还。
21.说几条写JavaScript的规范
    1、不要在同一行声明多个变量
    2、使用===或!==来比较
    3、使用字面量的方式来创建对象、数组，替代new Array这种形式
    4、不要使用全局函数
    5、switch语句必须要带default分支
    6、函数不应该有的时候有return，有的时候没有return
    7、fon-in循环中的变量，用var关键字说明作用域，防止变量污染8、变量的声明遵循驼峰命名法，用let替代val，声明构造函数时首字母大写，定义常量的时候尽量用大写字母，用_分割
    9、三元表达式可以替代if语句
    10、&&和||是可以短路的，使用&&时如果前面一个值是错的，那么后面的值不用判断，使用||时，如果前面一个值是对的，那么后面的值不用判断
    11、比较数据类型以下6中情况是false，其他都是true------false、""、0、null、undefined、NaN
    12、数据类型检测用typeof，对象类型检测用instanceof
    13、异步加载第三方的内容
    14、单行注释//，多行注释/**/
    15、使用命名空间解决变量名冲突
    16、多人协作开发，新建一个js文件，const声明常量，在js文件中引用，用常量名替代方法名，这样做可以防止命名冲突
22.JS有哪些作用域
    全局作用域 window
    局部作用域
        函数作用域 function
        块级作用域 {} ES6新增
            使用let ,const 定义的变量或常量。会形成块级作用域。
23.词法作用域
    指函数在定义(或声明)他们的作用域中运行
    而不是在执行(或调用)他们的作用域里运行
24.==与===的区别
    1.== 相等 值相等
    2.=== 恒相等 类型和值都相等
    3.js在比较时 
        ==会先做类型转换 再判断值的大小
        === 类型和值都必须相等
25.use strict 严格模式 其与普通模式的区别
    严格模式用于标准化正常的JavaScript语义。
    严格模式可以嵌入到非严格模式中，关键字 ‘use strict’。
    使用严格模式后的代码应遵循JS严格的语法规则。例如，分号在每个语句声明之后使用。
    非严格模式下 一般this指向window 严格模式下this 是undefined
26.创建对象有哪几种方法
    1.new Object()
    2.{}对象直接量
    3.Object.create()
    4.new Constructor()
    工厂模式？
27.null undefined
    已经声明但是尚未初始化：undefined；
    空对象的引用：null。
28.事件冒泡 阻止方式
    事件冒泡是指嵌套最深的元素触发一个事件，然后这个事件顺着嵌套顺序在父元素上触发。
    防止事件冒泡的一种方法是使用 event.stopPropagation()或 event.cancelBubble （低于 IE 9）。
30.定时器的分类，区别及作用
    Js中有两种定时器：
        setInterval：间歇执行，
        setTimeout：延迟执行  
31.offsetWidth、clientWidth、scrollTop的区别
    offsetWidth：占位宽，包含 内容宽+左右padding+左右border
    clientWidth：可视宽，包含 内容宽+左右padding
    scrollTop：页面被卷去的高
32.事件、IE与火狐的事件机制有什么区别？
    IE的事件流是冒泡流，而火狐同时支持冒泡流和捕获流。
33.事件绑定和普通事件有什么区别。
    标签.事件：如果给同一个元素添加同一个事件，后面的会覆盖前面
    事件绑定：可以给同一个元素添加同一个事件，不会被覆盖
34.解释一下事件流？
    事件捕获阶段：当事件发生的时候，将事件从window依次往子元素传递
    确定目标阶段：确定事件目标
    事件冒泡阶段：事件目标开始处理事件，处理完以后会将事件依次传递给父元素，一直到window
    事件都是在事件冒泡处理,ie只有冒泡
35.拖拽效果中有几种事件？
    按下onmousedown，拖拽onmousemove，弹起onmouseup
36.js哪些操作会造成内存泄露？
    1）意外的全局变量引起的内存泄露
    function leak(){ leak=“xxx”;//leak成为一个全局变量，不会被回收 }
    2）被遗忘的定时器或者回调
    3）闭包引起的内存泄漏
37.JSON方法实现拷贝有什么问题
    JS中的变量在内存中存储分为值类型和引用类型
    值类型：
        1.占用空间固定，保存在栈(stack)中
        2.保存和复制的是值本身
        3.基本类型数据是值类型(String Number Boolean Undefined Null)
    引用类型：
        1.占用空间不固定，保存在堆(heap)中
        2.保存和复制的是指向对象的一个指针
        3.使用new()方法构造出来的对象是引用型
    最简单的深拷贝方式:
        使用JSON.stringify()
        var obj1=JSON.parse(JSON.stringify(obj));
    问题：
        1.undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略
        2.Date 日期调用了 toJSON() 将其转换为了 string 字符串（Date.toISOString()），因此会被当做字符串处理。
        3.NaN 和 Infinity 格式的数值及 null 都会被当做 null。
        4.其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
        5.对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
    当我们克隆的对象中还有引用类型时，我们只能采用递归的方法进行遍历
38.js为什么需要放在body末尾
    浏览器的渲染引擎和js解析引擎的冲突
39.JS new对象过程|new一个实例对象会发生什么
    新建一个对象，可以访问构造器中的指向this属性，还可以访问原型的属性
    JS调用new的过程分四部分
    1.新生成一个空对象
    2.将空对象链接到原型中
    3.绑定this
    4.返回新对象
40.使用typeof(bar) === object风险
41.NaN Number
42.什么是回调函数
    1.在js里函数都是对象，这表示它们可以作为参数传递给其他的函数。
        举例：当函数b()作为参数传递给函数a()，那么在某一时刻函数a()可能会执行或者调用函数b()。这种情况下，函数b()就被称为回调函数，也可以简称叫做回调(下面是栗子)。
43.怎么拿到缓存区代码
44.用class创建对象和用function构建函数对象有什么不同
45.axios的底层用了什么
46.新的fetch请求时怎么实行的
47.宏任务微任务与EventLoop
    1.在当前的微任务没有执行完成时，是不会执行下一个宏任务的。
    2.setTimeout就是作为宏任务来存在的，而Promise.then则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。
    3.所有会进入的异步都是指的事件回调中的那部分代码
        new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。
    4.在Promise/A+的规范中，Promise的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少Chrome是这么做的)，Promise应该是属于微任务阵营的
    宏任务：
        I/O setTimeout setInterval 浏览器和Node中都是宏任务
        setImmediate 浏览器中不是宏任务 Node中是
        requestAnimationFrame浏览器中是宏任务 Node中不是
    微任务：
        process.nextTick
        MutationObserver	
        Promise.then catch finally
    Event-Loop
        JavaScript是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。
        1.检查还有没有微任务需要处理）
        2.结束本次宏任务、检查还有没有宏任务需要处理
        每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。
        Event Loop只是负责告诉你该执行那些任务，或者说哪些回调被触发了，真正的逻辑还是在进程中执行的。
        宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）
48.js中将多个对象合并成一个对象
    1.利用assign(浅拷贝)合并多个对象，第一个参数为目标对象，后面可以有多个源对象。
    2.需要注意的是利用扩展运算符...合并对象 同样是进行浅拷贝
    3.手写函数（浅拷贝实现）
    4.手写函数（实现深拷贝）
    5.最后介绍最后一种办法Lodash's中的merge( )方法。Lodash's是node中的库。它也是一种深拷贝的办法。
49.可枚举属性 不可枚举属性
    可枚举属性
        1.是指那些内部 “可枚举” 标志设置为 true 的属性。对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true。但是对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。
        2.其中js中基本包装类型的原型属性是不可枚举的，如Object, Array, Number等。
        3.可枚举的属性可以通过for...in循环进行遍历（除非该属性名是一个Symbol），或者通过Object.keys()方法返回一个可枚举属性的数组。
50.JS基本包装类
    在基本数据类型中有3个特殊的存在：
        String Number Boolean
        这三个基本类型都有自己对应的包装对象。
        包装对象，其实就是对象，有相应的属性和方法。
        调用方法的过程，是在后台偷偷发生的，所以我们称作为基本包装类型。
        引用类型和基本包装对象区别：
            生存期
        引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了一瞬间。
        我们无法直接给基本类型添加方法：
        给基本类型添加方法或者属性:
            在基本包装对象的原型下面添加，每个对象都有原型。
51. concurrency并发
    non-blocking 非阻塞
    event-loop
    callback 回调函数
    asynchronous 异步的
    single-threaded 单线程
    FPS(frames-per-second)
    JS有
        call stack
        event loop
        callback quene
        API
    V8有
        heap
        callstack(调用栈)
    web API
        DOM
        AJAX
        timeout(setTimeout setInterval)
    single threaded === single call stack === do one thing at a time

