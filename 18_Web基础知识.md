1. shim()
    - 一个小型库，可透明地截取API，更改传递的参数，处理操作本身，或将操作重定向到别处。
    - 垫片通常在API的行为发生变化时出现，从而导致仍依赖旧功能的旧应用程序出现兼容性问题。在这些情况下，较新的代码之上的较薄的兼容层仍然可以支持较旧的API。垫片也可以用于在不同的软件平台上运行程序，而不是开发它们。
2. 什么是回调函数 什么是回调地域
    > 回调函数
    - 编程分为两类：
    1. 系统编程，简单来说，就是编写库；
        - 系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。
        - 所以在抽象层的图示里，库位于应用的底下。
    2. 应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。
        - 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。
        - 但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。
    - 回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。
    而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。
    （我认为）这应该是回调最早的应用之处，也是其得名如此的原因。
    > 回调函数的第1个参数是什么?
    - 通常是错误对象。如果这个参数为空，表示没有错误。
    
    > 错误优先的回调函数
    - 错误有限的回调函数用于传递错误和数据
    - 第一个参数始终应该是一个错误对象 用于检查程序是否发生了 错误 其余参数用于传递数据

    > 如何避免回调地狱
    1. 模块化 将回调函数分割为独立的函数
    2. 使用Promises
    3. 使用yield
    4. 计算生成器或Promise
3. 前端构建工具
    1. 任务管理工具(task runner)
        - 通过声明组合构建任务进行整个网站的构建,有自己的一套任务声明语法和任务实现接口,如Grunt和Gulp,
        - 这两个都是插件式的架构,有大量的插件可用,缺点在于做什么都只能用插件
    2. 打包工具(package tool)
        - 通过为每一类文件配置需要的处理方式,实现整个站点的构建,如Webpack和FIS,这两个都是整个站点的整体构建解决方案
    3. 构建工具(build tool)
4. MVV和MVVM
    M:Model模型
    V:View视图
    C:Controller控制器
    VM:ViewModel视图模型
    MVC:展示一个篮球的页面
    1.设置一个篮球的模型等待使用
    2.写一个需要展示篮球的视图
    3.使用控制器让模型和视图交互
    MVVM:
    vm是vue对象,功能绑定到view上,Model中篮球更新或其他操作，通过vm通知派发至view
    Vue和React都是借鉴mvvm思想+工程师自己的想法出现的两个框架
5. 声明式编程 命令式编程 函数式编程 面向切面编程 响应式编程
    - 两种编程方式 声明式编程/命令式编程
    1. 命令式
        - 命令机器如何做事情 不管你想要什么 它都会按照你的命令实现
    2. 声明式
        - 告诉机器你想要什么 让机器想出如何去做
    > 让一个数组中的数字翻倍
    - 命令式 for循环/声明式 map函数
    - map函数所做的事情是将直接便利整个数组的过程归纳抽离出来 专注于描述我们想要的是什么 传入map的是一个纯函数 它不具有任何副作用(不会改变外部状态)
    - 一些具有函数式编程特征的语言中 对list数据类型的操作 命令式编程for循环 声明式编程 reduce函数 每一次调用 第一个参数都是这个函数处理前一个值时返回的结果 第二个参数就是当前元素
    - reduce函数归纳抽离如何遍历数组和状态管理部分的实现 提供一个通用的方式把list合并成一个值
    ```
    var numbers = [1,2,3,4,5];
    var total = numbers.reduce(function(sum,n){
        return sum+n
    })
    ```
    3. 面向对象编程属于命令编程和声明式的结合
    - 面向对象编程和函数式编程
    1. 面向对象编程 
        - 是命令式编程的一种抽象 抽象包括两方面 数据抽象和过程抽象 
        - 在JS中 面向对象编程(也就是基于对象 因为JS并不是面向对象的语言) 把逻辑和数据封装到函数与原型中 通过函数的原型链拷贝实现继承 代码的运行逻辑与数据依然封装在函数内 但是做了属性和方法的区分
        - 优秀的面向对象编程可以做到声明式编程 也就是根据声明配置生成结果
        - 但是绝大多数的面向对象编程 不会根据声明配置去生成逻辑
    2. 函数式编程
        - 把逻辑完全视为函数的计算 把数据和逻辑封装到函数中 通过对函数的计算 加工 处理 生成新的函数 最后拼装成一个个功能独立的函数 
    
    > 函数式编程思维
    
    > 面向对象编程OOP通过封装变化使代码更易理解 函数式编程通过最小变化使得代码更易理解
    - js是一种拥有很多共享状态的动态语言 代码会随时间变得复杂笨拙难以维护 面向对象设计可在一定程度上解决这个问题 但是还不够
    - 由于有很多状态 所以处理数据流和变化的传递尤为重要 响应式编程有助于处理js异步或事件响应 在设计应用程序时 应考虑是否遵循了以下的设计原则
        - 可扩展性
        - 易模块化
        - 可重用性
        - 可测性
        - 易推理性
    - 函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作 从而在系统中消除副作用并减少对状态的改变

    > 声明式编程
    - 函数式编程属于声明式编程范式：这种范式会描述一系列的操作 但并不会暴露它们是如何实现或数据流如何传入它们
    - SQL就是一种很典型的声明式范式 它由一个个描述查询结果应该是什么样的断言组成 对数据检索的内部机制进行了抽象
    > 命令式 很具体地告诉计算机如何执行某个任务
    > 声明式 将程序的描述和求职分离开 关注如何用各种表达式描述程序逻辑 而不一定指明其控制流或状态关系的变化
    - 去掉代码循环 循环是一种重要的命令控制结构 但很难重用且很呐插入其他操作中 函数式编程旨在金肯呢个提高代码的无状态性和不变性 无副作用的函数 纯函数
    
    > 纯函数
    -  没有副作用的函数 相同的输入有相同的输出
        > 产生副作用的情况
        1. 改变一个全局的变量 属性或数据结构
        2. 改变一个函数参数的原始值
        3. 处理用户输入
        4. 抛出一个异常
        5. 屏幕打印或记录日志
        6. 查询HTML文档 浏览器的cookie或访问数据库
    - 纯函数性质
        1. 仅取决于提供的输入 而不依赖任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态
        2. 不会造成超出作用域的变化 例如修改全局变量或引用传递的参数

    > 引用透明
    - 引用透明是定义一个纯函数较为正确的方法 纯度咋子这个意义上表示一个函数的参数和返回值之间映射的纯的关系 如果一个函数对于相同的输入始终产生相同的结果 引用透明
        > 箭头函数在函数式编程里有一个高大上的名字 叫lambda表达式 对于这种匿名函数在学术上就是叫lambda表达式 JAVA中同样支持

    > 不可变数据
    - 不可变数据是指那些创建后不能更改的数据 与许多其他语言一样 js中有一些基本类型(String Number)从本质上是不可变的 对象可以在任意地方改变

    > 小结
    1. 使用纯函数的代码绝不会更改或破坏全局状态 有助于提高代码的可测试性和可维护性
    2. 函数式编程采用声明式的风格 易于推理 提高代码的可读性
    3. 函数式编程将函数视为积木 通过一等高阶函数来提高代码的模块化和可重用性
    4. 可以利用响应式编程结合各个函数降低事件驱动程序的复杂性    
    > 面向切面编程思维
    - 运行时 动态地将代码切入到类的指定方法 指定位置上的编程思想就是面向切面的编程
    - 一般而言 管切入到指定类指定方法的代码片段称为切面 而切入到哪些类 那些方法 为切入点
    - 有AOP 可以把几个类共用的代码抽取到一个切片中 等到需要时再切入到对象中 从而改变其原有的腥味
    - 这样看AOP只是OOP的补充 OOP从横面上区分出一个个的类 AOP 从纵面上向对象中加入特定的代码 
    - 有了AOP OOP立体 加上时间维度 AOP使OOP由原来的二维变成三维 由平面变立体 技术上说 AOP是通过代理机制实现的
6. 前端工程化
    > 前端工程化可以分为四个方面来说 分别为
    1. 模块化 
        - 将一个文件拆分成多个相互依赖的文件 最后进行统一的打包和加载 这样能很好的保证高效的多人协作 其中包含
        1. JS模块化 CommonJS AMD CMD ES6 Module
        2. CSS模块化 Sass Less
        3. 资源模块化  
    2. 组件化 
        - 不同于模块化 模块化是对文件 对代码和资源拆分 组件化是对UI层面的拆分
        - 考虑细粒度和通用性
    3. 规范化 
        - 工程开发初期以及开发期间指定的系列规范 
        1. 项目目录结构
        2. 编码规范:
        3. 联调规范
        4. 文件命名规范
        5. 样式管理规范
        6. git flow工作流:其中包含分支命名规范 代码合并规范等
        7. 定期code review
    4. 自动化
        - 从最早先的grunt gulp等 
        - 再到目前的webpack parcel
        - 这些自动化工具在自动化合并 构建 打包都能为我们节省很多工作
        - 而这些只是前段自动化其中的一部分 前端自动化还包含持续集成 自动化测试德国方方面面
    - 价值
    1. 为简化用户使用提供技术支持(交互部分)
    2. 为多个浏览器兼容性提供支持
    3. 为提高用户浏览速度(浏览器性能)提供支持
    4. 为跨平台或其他基于webkit或其他渲染引擎的应用提供支持
    5. 为展示数据提供支持(数据接口)
7. 静态类型和动态类型
    > 编程语言按类型检查可分为两大类 
    - 静态类型  Java C/C++ Golang
    - 动态类型  Python Ruby
    > 静态类型和动态类型的区别在于什么时候报类型的错误 
    > 如3/a 静态类型多是在编译时 动态类型多是在程序运行时
    > 编程语言设计时 考虑
    1. 什么程序要类型检查
    2. 怎么执行类型检查
    > 区别
    1. 方便性 Convenience
    动态类型比较方便 因为一个函数可以根据需要返回不同的类型 静态类型需要去构造一个新的数据类型实现
    2. 更早发现错误 Catching bugs earlier
    静态类型在编译时能发现类型上的错误 不用写tests 可以比动态类型更早找到bug 
    3. 性能 Performance
    静态类型程序运行时更快 因为在编译时已进行了检测 不需要存储和检测类型 可以节省程序运行的时间和空间
    4. 代码重用 Code Reuse
    动态类型更好 动态类型代码重用率更高 因为没有严格的类型系统 代码可以被不同类型的数据重用 静态类型有代码重用的很多方法 比如泛型 子类型等 一个list只有一中类型的数据 可以避免一些难找的bug 也可以避免因为类型自由而滥用一些库
    5. 原型开发 Prototyping
    6. 再开发和再维护 Evolution Maintaince
    > 动态语言更合适较小的程序 如Python Ruby 作为脚本语言 简单快速写完对文件的处理  静态语言Java C++ 支持大型的软件工程项目
8. UML（Unified Modeling Language，统一建模语言）:
    > 用来设计软件蓝图的可视化建模语言，一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。
    > 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。
    >基本构件:
        > UML建模核心是模型 模型是现实的简化真实系统的抽象 UML提供了系统的设计蓝图 当给软件系统建模时 需要采用通用的符号语言 这种描述模型所使用的语言被称为建模语言 在UML中 所有的描述由事物 关系 和图这些构建组成
9. 概念
  - OOA(Object-Oriented Analysis)：面向对象的分析
  - OOD(Object-Oriented Design):面向对象的设计

  - POP(Procedure-Oriented Programming):面向过程编程
  - OOP(Object-Oriented Programming):面向对象编程
  - FP(Functional programming):面向函数编程
  - AOP(Aspect Oriented Program):面向切面编程

  - 响应式编程：与异步数据流交互的编程范式
  - 命令式编程
  - 声明式编程
10. API函数的类型有哪些
    1. 一种是阻滞型函数。阻滞型函数会等待操作完成以后再进行下一步。
    2. 另外一种是非阻滞型函数。这种函数使用回调函数来处理当前函数获取的结果。
    > repl
    - Read evaluate print loop， 用于测试，调试和实验用。
    > 测试金字塔
    - 编写测试用例时 底层的单元测试应该远比上层的端到端测试要多
    - 谈到Http API时 可能会涉及到
    1. 有很多针对模型的底层单元测试
    2. 需要测试模型
    > C++和JS交互
    - 如何通过V8实现JS调用C++ 
    - JS调用C++ 分为
    1. JS调用C++函数(全局)
    2. 调用C++类
11. 如何让异步代码同步化
    1. promise
    ```
    const {promisify} = require('util');
    const readFile = promisify(fs.readFile);
    readFile('./01-runnode.js').then(data=>console.log(data))
    ```
    2. Promise API(node的版本在10.0以上)
    ```
    const {promises} = require('fs');
    promises.readFile('./1.js').thenm(data=>{console.log(data)})
    ```
    3. genenrator
    4. aysnc
12. 循环引用/依赖
    - a文件require了b文件 b文件require了a文件
    - 循环引用不会报错 导致的结果是require的结果是空对象{} 原因是b require 了a a又去require了b 此时b还没有初始化好 所以只能拿到初始值{}
    > 两种方法解决循环引用
    1. 通过分离公用的代码到另一个文件解决
    2. 不在最外层require 在用到的地方require 通常在函数内部