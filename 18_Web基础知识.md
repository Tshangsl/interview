1. shim()
    - 一个小型库，可透明地截取API，更改传递的参数，处理操作本身，或将操作重定向到别处。
    - 垫片通常在API的行为发生变化时出现，从而导致仍依赖旧功能的旧应用程序出现兼容性问题。在这些情况下，较新的代码之上的较薄的兼容层仍然可以支持较旧的API。垫片也可以用于在不同的软件平台上运行程序，而不是开发它们。
2. 什么是回调函数 什么是回调地域
    > 回调函数
    - 编程分为两类：
    1. 系统编程，简单来说，就是编写库；
        - 系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。
        - 所以在抽象层的图示里，库位于应用的底下。
    2. 应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。
        - 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。
        - 但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。
    - 回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。
    而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。
    （我认为）这应该是回调最早的应用之处，也是其得名如此的原因。
    > 回调函数的第1个参数是什么?
    - 通常是错误对象。如果这个参数为空，表示没有错误。
    
    > 错误优先的回调函数
    - 错误有限的回调函数用于传递错误和数据
    - 第一个参数始终应该是一个错误对象 用于检查程序是否发生了 错误 其余参数用于传递数据

    > 如何避免回调地狱
    1. 模块化 将回调函数分割为独立的函数
    2. 使用Promises
    3. 使用yield
    4. 计算生成器或Promise
3. 前端构建工具
    1. 任务管理工具(task runner)
        - 通过声明组合构建任务进行整个网站的构建,有自己的一套任务声明语法和任务实现接口,如Grunt和Gulp,
        - 这两个都是插件式的架构,有大量的插件可用,缺点在于做什么都只能用插件
    2. 打包工具(package tool)
        - 通过为每一类文件配置需要的处理方式,实现整个站点的构建,如Webpack和FIS,这两个都是整个站点的整体构建解决方案
    3. 构建工具(build tool)
5. 声明式编程 命令式编程 函数式编程 面向切面编程 响应式编程
    - 两种编程方式 声明式编程/命令式编程
    1. 命令式
        - 命令机器如何做事情 不管你想要什么 它都会按照你的命令实现
    2. 声明式
        - 告诉机器你想要什么 让机器想出如何去做
    > 让一个数组中的数字翻倍
    - 命令式 for循环/声明式 map函数
    - map函数所做的事情是将直接便利整个数组的过程归纳抽离出来 专注于描述我们想要的是什么 传入map的是一个纯函数 它不具有任何副作用(不会改变外部状态)
    - 一些具有函数式编程特征的语言中 对list数据类型的操作 命令式编程for循环 声明式编程 reduce函数 每一次调用 第一个参数都是这个函数处理前一个值时返回的结果 第二个参数就是当前元素
    - reduce函数归纳抽离如何遍历数组和状态管理部分的实现 提供一个通用的方式把list合并成一个值
    ```
    var numbers = [1,2,3,4,5];
    var total = numbers.reduce(function(sum,n){
        return sum+n
    })
    ```
    3. 面向对象编程属于命令编程和声明式的结合
    - 面向对象编程和函数式编程
    1. 面向对象编程 
        - 是命令式编程的一种抽象 抽象包括两方面 数据抽象和过程抽象 
        - 在JS中 面向对象编程(也就是基于对象 因为JS并不是面向对象的语言) 把逻辑和数据封装到函数与原型中 通过函数的原型链拷贝实现继承 代码的运行逻辑与数据依然封装在函数内 但是做了属性和方法的区分
        - 优秀的面向对象编程可以做到声明式编程 也就是根据声明配置生成结果
        - 但是绝大多数的面向对象编程 不会根据声明配置去生成逻辑
    2. 函数式编程
        - 把逻辑完全视为函数的计算 把数据和逻辑封装到函数中 通过对函数的计算 加工 处理 生成新的函数 最后拼装成一个个功能独立的函数 
    
    > 函数式编程思维
    
    > 面向对象编程OOP通过封装变化使代码更易理解 函数式编程通过最小变化使得代码更易理解
    - js是一种拥有很多共享状态的动态语言 代码会随时间变得复杂笨拙难以维护 面向对象设计可在一定程度上解决这个问题 但是还不够
    - 由于有很多状态 所以处理数据流和变化的传递尤为重要 响应式编程有助于处理js异步或事件响应 在设计应用程序时 应考虑是否遵循了以下的设计原则
        - 可扩展性
        - 易模块化
        - 可重用性
        - 可测性
        - 易推理性
    - 函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作 从而在系统中消除副作用并减少对状态的改变

    > 声明式编程
    - 函数式编程属于声明式编程范式：这种范式会描述一系列的操作 但并不会暴露它们是如何实现或数据流如何传入它们
    - SQL就是一种很典型的声明式范式 它由一个个描述查询结果应该是什么样的断言组成 对数据检索的内部机制进行了抽象
    > 命令式 很具体地告诉计算机如何执行某个任务
    > 声明式 将程序的描述和求职分离开 关注如何用各种表达式描述程序逻辑 而不一定指明其控制流或状态关系的变化
    - 去掉代码循环 循环是一种重要的命令控制结构 但很难重用且很呐插入其他操作中 函数式编程旨在金肯呢个提高代码的无状态性和不变性 无副作用的函数 纯函数
    
    > 纯函数
    -  没有副作用的函数 相同的输入有相同的输出
        > 产生副作用的情况
        1. 改变一个全局的变量 属性或数据结构
        2. 改变一个函数参数的原始值
        3. 处理用户输入
        4. 抛出一个异常
        5. 屏幕打印或记录日志
        6. 查询HTML文档 浏览器的cookie或访问数据库
    - 纯函数性质
        1. 仅取决于提供的输入 而不依赖任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态
        2. 不会造成超出作用域的变化 例如修改全局变量或引用传递的参数

    > 引用透明
    - 引用透明是定义一个纯函数较为正确的方法 纯度咋子这个意义上表示一个函数的参数和返回值之间映射的纯的关系 如果一个函数对于相同的输入始终产生相同的结果 引用透明
        > 箭头函数在函数式编程里有一个高大上的名字 叫lambda表达式 对于这种匿名函数在学术上就是叫lambda表达式 JAVA中同样支持

    > 不可变数据
    - 不可变数据是指那些创建后不能更改的数据 与许多其他语言一样 js中有一些基本类型(String Number)从本质上是不可变的 对象可以在任意地方改变

    > 小结
    1. 使用纯函数的代码绝不会更改或破坏全局状态 有助于提高代码的可测试性和可维护性
    2. 函数式编程采用声明式的风格 易于推理 提高代码的可读性
    3. 函数式编程将函数视为积木 通过一等高阶函数来提高代码的模块化和可重用性
    4. 可以利用响应式编程结合各个函数降低事件驱动程序的复杂性    
    > 面向切面编程思维
    - 运行时 动态地将代码切入到类的指定方法 指定位置上的编程思想就是面向切面的编程
    - 一般而言 管切入到指定类指定方法的代码片段称为切面 而切入到哪些类 那些方法 为切入点
    - 有AOP 可以把几个类共用的代码抽取到一个切片中 等到需要时再切入到对象中 从而改变其原有的腥味
    - 这样看AOP只是OOP的补充 OOP从横面上区分出一个个的类 AOP 从纵面上向对象中加入特定的代码 
    - 有了AOP OOP立体 加上时间维度 AOP使OOP由原来的二维变成三维 由平面变立体 技术上说 AOP是通过代理机制实现的
6. 前端工程化
    > 前端工程化可以分为四个方面来说 分别为
    1. 模块化 
        - 将一个文件拆分成多个相互依赖的文件 最后进行统一的打包和加载 这样能很好的保证高效的多人协作 其中包含
        1. JS模块化 CommonJS AMD CMD ES6 Module
        2. CSS模块化 Sass Less
        3. 资源模块化  
    2. 组件化 
        - 不同于模块化 模块化是对文件 对代码和资源拆分 组件化是对UI层面的拆分
        - 考虑细粒度和通用性
    3. 规范化 
        - 工程开发初期以及开发期间指定的系列规范 
        1. 项目目录结构
        2. 编码规范:
        3. 联调规范
        4. 文件命名规范
        5. 样式管理规范
        6. git flow工作流:其中包含分支命名规范 代码合并规范等
        7. 定期code review
    4. 自动化
        - 从最早先的grunt gulp等 
        - 再到目前的webpack parcel
        - 这些自动化工具在自动化合并 构建 打包都能为我们节省很多工作
        - 而这些只是前段自动化其中的一部分 前端自动化还包含持续集成 自动化测试德国方方面面
    - 价值
    1. 为简化用户使用提供技术支持(交互部分)
    2. 为多个浏览器兼容性提供支持
    3. 为提高用户浏览速度(浏览器性能)提供支持
    4. 为跨平台或其他基于webkit或其他渲染引擎的应用提供支持
    5. 为展示数据提供支持(数据接口)
7. 静态类型和动态类型
    > 编程语言按类型检查可分为两大类 
    - 静态类型  Java C/C++ Golang
    - 动态类型  Python Ruby
    > 静态类型和动态类型的区别在于什么时候报类型的错误 
    > 如3/a 静态类型多是在编译时 动态类型多是在程序运行时
    > 编程语言设计时 考虑
    1. 什么程序要类型检查
    2. 怎么执行类型检查
    > 区别
    1. 方便性 Convenience
    动态类型比较方便 因为一个函数可以根据需要返回不同的类型 静态类型需要去构造一个新的数据类型实现
    2. 更早发现错误 Catching bugs earlier
    静态类型在编译时能发现类型上的错误 不用写tests 可以比动态类型更早找到bug 
    3. 性能 Performance
    静态类型程序运行时更快 因为在编译时已进行了检测 不需要存储和检测类型 可以节省程序运行的时间和空间
    4. 代码重用 Code Reuse
    动态类型更好 动态类型代码重用率更高 因为没有严格的类型系统 代码可以被不同类型的数据重用 静态类型有代码重用的很多方法 比如泛型 子类型等 一个list只有一中类型的数据 可以避免一些难找的bug 也可以避免因为类型自由而滥用一些库
    5. 原型开发 Prototyping
    6. 再开发和再维护 Evolution Maintaince
    > 动态语言更合适较小的程序 如Python Ruby 作为脚本语言 简单快速写完对文件的处理  静态语言Java C++ 支持大型的软件工程项目
8. UML（Unified Modeling Language，统一建模语言）:
    > 用来设计软件蓝图的可视化建模语言，一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。
    > 1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。
    >基本构件:
        > UML建模核心是模型 模型是现实的简化真实系统的抽象 UML提供了系统的设计蓝图 当给软件系统建模时 需要采用通用的符号语言 这种描述模型所使用的语言被称为建模语言 在UML中 所有的描述由事物 关系 和图这些构建组成
9. 概念
  - OOA(Object-Oriented Analysis)：面向对象的分析
  - OOD(Object-Oriented Design):面向对象的设计

  - POP(Procedure-Oriented Programming):面向过程编程
  - OOP(Object-Oriented Programming):面向对象编程
  - FP(Functional programming):面向函数编程
  - AOP(Aspect Oriented Program):面向切面编程

  - 响应式编程：与异步数据流交互的编程范式
  - 命令式编程
  - 声明式编程
10. API函数的类型有哪些
    1. 一种是阻滞型函数。阻滞型函数会等待操作完成以后再进行下一步。
    2. 另外一种是非阻滞型函数。这种函数使用回调函数来处理当前函数获取的结果。
    > repl
    - Read evaluate print loop， 用于测试，调试和实验用。
    > 测试金字塔
    - 编写测试用例时 底层的单元测试应该远比上层的端到端测试要多
    - 谈到Http API时 可能会涉及到
    1. 有很多针对模型的底层单元测试
    2. 需要测试模型
    > C++和JS交互
    - 如何通过V8实现JS调用C++ 
    - JS调用C++ 分为
    1. JS调用C++函数(全局)
    2. 调用C++类
11. 如何让异步代码同步化
    1. promise
    ```
    const {promisify} = require('util');
    const readFile = promisify(fs.readFile);
    readFile('./01-runnode.js').then(data=>console.log(data))
    ```
    2. Promise API(node的版本在10.0以上)
    ```
    const {promises} = require('fs');
    promises.readFile('./1.js').thenm(data=>{console.log(data)})
    ```
    3. genenrator
    4. aysnc
12. 循环引用/依赖
    - a文件require了b文件 b文件require了a文件
    - 循环引用不会报错 导致的结果是require的结果是空对象{} 原因是b require 了a a又去require了b 此时b还没有初始化好 所以只能拿到初始值{}
    > 两种方法解决循环引用
    1. 通过分离公用的代码到另一个文件解决
    2. 不在最外层require 在用到的地方require 通常在函数内部
13. 同步异步和阻塞非阻塞
    - 同步异步取决于被调用者 阻塞非阻塞取决于调用者
        - 阻塞调用是指调用结果返回之前 当前线程会被挂起 调用线程只有得到结果之后才会返回
        - 非阻塞调用是指在不能立刻得到结果之前 该调用不会阻塞当前线程
14. 前端鉴权方案
    > 常见的前端解决方案
    1. HTTP Basic Authentication
        概念：
            HTTP Basic Authentication授权方式是浏览器遵守http协议实现的基本授权方式，HTTP协议进行通信的过程中，HTTP协议定义了允许HTTP服务器对客户端进行用户身份验证的方法。
        认证过程
            第一步：客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证；
              第二步：服务器向客户端发送验证请求代码401，然后弹出用户登录界面；
              第三步：用户输入用户信息和密码，浏览器会自动以base64形式进行加密；
              第四步：服务器收到请求之后，将信息解密，将其与数据库中的用户信息进行对比，一直的话返回用户需要的请求内容。
              登录失效的方案：在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的Authentication信息为注销用户名密码的时候便注销成功了，而客户端在注销操作的时候，手动的去修改请求头的Authentication，将它设置为服务器默认的注销账号和密码。
    2. session-cookie
        概念：
            利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，由于http请求时是无状态的，需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建seesion，如果有则已经认证成功了，否则就没有认证。
        认证过程：
            1.服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion到内存当中，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。
             2.浏览器中收到请求响应的时候会解析响应头，然后将session_id保存在本地cookie中，浏览器在下次http请求时请求头中会带上该域名下的cookie信息
             3.服务器在接受客户端请求时会去解析请求头cookie中的session_id，然后根据这个session_id去找服务器端保存的该客户端的session，然后判断该请求是否合法.
    3. Token 验证
        认证过程：
            1.客户端使用用户名跟密码请求登录；
            2.服务端收到请求，去验证用户名与密码；
            3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
            4.客户端收到Token以后可以把它存储起来，比如放在Cookie 里或者Local Storage里；
            5.客户端每次向服务端请求资源的时候需要带着服务端签发的Token；
            6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据。
        token验证方案JWT：
            一、JWT概念
                  JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成json对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。
                二、JWT组成
                 Headers： 包括类别（typ）、加密算法（alg）；
                 Claims ：包括需要传递的用户信息；
                 Signature： 根据alg算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密；
    4. OAuth(开放授权)
        概念：
            OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有支付宝，QQ,微信。
        OAuth认证过程
            第一步：向用户请求授权，而当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面；
              第二步：当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址redirect_uri的后面；
              第三步：用户再去请求时携带用户凭证（code），验证服务器返回一个访问令牌（Access Token）；
              第四步：再去拿着令牌请求资源时，就会得到受保护的资源信息。
15. 即时通讯的实现
    - 短轮询/长轮询/SSE(基于HTTP协议) WebSocket(基于TCP协议 典型的应用层协议)
    区别
    (目的都是实现客户端/服务器端一个即时通讯)
    1. 短轮询的基本思路(基于HTTP协议)
    实现原理：
        浏览器每隔一段时间向浏览器发送 HTTP 请求，
        服务器端在收到请求后，不论是否有数据更新，都直接进行响应。
        这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，
        通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
    优点：
        比较简单，易于理解。
    缺点：
        该方式由于需要不断的建立 HTTP 连接
        严重浪费了服务器端和客户端的资源。
        当用户增加时，服务器端的压力就会变大，这是很不合理的。
    2. 长轮询的基本思路(基于HTTP协议)
    - 实现原理:
        (服务器不会直接进行响应而是先将这个请求挂起 判断服务器端数据是否有更新)
        首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起 判断服务器端数据是否有更新。
        如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。
        客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。
    长轮询和短轮询相比
    - 优点：
        明显减少了很多不必要的 HTTP 请求次数，相比之下节约了资源。
    - 缺点：
        连接挂起也会导致资源的浪费。
    3. SSE- Server-sent Events (基于HTTP协议 单向 数据流如视频播放 服务端=>客户端)
    (服务端向客户端声明接下来要发送的是流信息 发送的不是一次性的数据包 而是一个数据流 如视频播放)
    - 实现原理:
        服务器使用流信息向服务器推送信息。严格地说，HTTP1.x 协议无法做到服务器主动推送信息。
        有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。
        也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。
        这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。
        SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于HTTP协议目前除了 IE/Edge，其他浏览器都支持。
    优点:   
        它相对于前面两种方式来说，不 需要建立过多的 http 请求，相比之下节约了资源。
    4. WebSocket
    (H5新定义的一个协议 基于TCP协议 全双工 双向 该协议允许服务器主动向客户端推送信息)
    上面三种方式本质上都是基于HTTP协议的.我们还可以使用 WebSocket 协议来实现。
    WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。
    缺点：
        服务器端的配置比较复杂。
    WebSocket与SSE区别：    
    WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息
    而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个HTTP请求了。
    4. WebSocket和SSE
        (WebSocket一个全双工协议 通信双方平等 可以互发消息)
        (SSE服务器端向浏览器端单向通信 如用户需要发送信息 属于下一个HTTP请求)
    5. WebSocket和HTTP
        (相同 一样基于TCP都是可靠性传输协议/应用层协议)
        (不同 WebSocket双向通信协议 模拟Socket协议 可双向发送或接收请求 HTTP单向/WebSocket需握手进行建立连接)
        (联系 WebSocket协议建立握手时 数据通过HTTP传输 建立后真正传输不需要HTTP协议)
        相同点：
        1. 都是一样基于TCP都是可靠性传输协议
        2. 都是应用层协议
        不同点:
        1. Websocket是双向通信协议 模拟Socket协议 可以双向发送或接受请求 HTTP是单向的
        2. WebSocket需要握手进行建立连接
        联系:
        1. WebSocket协议在建立握手时 数据是通过HTTP传输的
        但是建立后真正传输时不需要HTTP协议
    6. WebSocket和Socket关系
        (WebSocket(典型的应用层协议)
        Socket:
            (不是一个协议 是为了方便使用TCB/UDP抽象出来的一层)
            (不是一个协议 是为方便使用TCP/UDP抽象出来位于应用层和传输控制层间的一组接口))
            是位于应用层和传输控制层之间的一组接口
            Sockets是应用层和TCP/IP协议族通信的中间软件抽象层 它是一组接口 
            在设计模式中Socket其实就是一个门面模式 它把复杂的TCP/IP协议族隐藏在Socket接口后面
            对用户来说 一组简单的接口就是全部 让Socket去组织数据以符合指定的标准
            当两台主机通信时 必须通过Socket连接
            Socket则利用TCP/IP协议建立TCP连接 
            TCP连接更依赖于底层的IP协议 
            IP协议的连接则依赖于链路层等更低层次
        WebSocket协议:
            WebSocket是一个典型的应用层协议
        总结：
            Socket是传输控制层协议
            WebSocket是引用层协议
    7. WebSocket和HTML5的关系
        (WebSocket API是H5标准一部分 WebSocket不必一定要用在HTML/基于浏览器应用程序中)
        (许多语言/框架 服务器都提供WebSocket支持)
        WebSocket API是HTML5标准的一部分 
        但这不代表WebSocket一定要用在HTML中
        或者只能在基于浏览器中的应用程序中使用
        实际上许多语言 框架 服务器都提供了WebSocket支持
16. XML与JSON
    XML定义
        扩展标记语言 EXtensible Markup Language XML
        用于标记电子文件使其具有结构性的标记语言 
        可以用来标记数据 定义数据类型 是一种允许用户对自己的标记语言进行定义的源语言
        XML使用DTD文档类型定义来组织数据 格式统一 跨平台和语言 称为业界公认的标准
        XML是标准通用标记语言SGML的子集 非常适合Web传输 
        XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据
    JSON JavaSript Object Notation
        一种轻量级数据交换格式
        具有良好的可读和便于快速编写的特性
        可在不同平台之间进行数据交换
    - XML优点:
        1. 格式统一 符合标准
        2. 容易与其他系统进行远程交互 数据共享比较简单
    - XML缺点:(庞大 解析费时 )
        1. XML文件庞大 文件格式复杂 传输占带宽
        2. 服务端和客户端都需要花费大量代码解析XML 导致服务器端和客户端代码变得异常复杂且不易维护
        3. 客户端不同 浏览器之间解析XML方式不同 需要重复编写很多代码
    - JSON优点(数据格式简单/易于解析/支持多种语言/同时被服务器端代码使用)
        1. 数据格式比较简单 易于读写 格式都是压缩的 占用带宽小
        2. 易于解析 客户端JS可简单通过eval()进行JSON数据读取
        3. 支持多种语言 包括ActionScript C Java JavaScript Perl PHP Python Ruby等服务器端语言 便于服务器端解析
        4. JSON格式能直接为服务器端代码使用 大大简化了服务器端和客户端的代码开发量 且完成任务不变 易于维护
    - JSON缺点(没有XML那么通用)
        1. 没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性
        2. JSON格式目前在Web Service中推广还属于初级阶段
    XML与JSON优缺点对比
    (可读性/可扩展性/解析手段)
    (JSON编码难度较低/JSON解析难度基本为0/JSON数据体积更小/数据交互更方便/传输速度较快)
    (XML流行度较高/数据描述较好)
        1.可读性方面
            JSON和XML的数据可读性基本相同
            XML可读性较好些
        2.可扩展性方面
            XML天生有很好的扩展性
            JSON也是 
            没有什么是XML能扩展
            JSON不能的
        3.编码难度方面
            XML有丰富的编码工具
            JSON也有json.org提供的工具
            JSON的编码明显比XML容易许多
        4.解码难度方面
            XML解析考虑子节点 父节点
            JSON解析难度几乎为0
        5.流行度方面
            XML已经被业界广泛的使用 而JSON才刚刚开始
            但是在Ajax这个特定的领域 
            未来的发展一定是XML让位于JSON
            到时Ajax应该变成Ajaj
            (Asynchronous Javascript and JSON)
        6.解析手段方面
            JSON和XML同样拥有丰富的解析手段
        7.数据体积方面
            JSON相对于XML 数据体积更小 传递速度更快
        8.数据交换方面
            JSON和JS的交互更加方便 
            更容易解析处理 更好的数据交互
        9.数据描述方面
            JSON对数据的描述性比XML较差
        10.传输速度方面
            JSON的速度远远比XML快
    XML与JSON数据格式比较
    (XML 两种解析方式 DOM&SAX 适合于对大量数据的处理)
    (JSON 只提供整体解析方案 解析较少数据时起到良好作用)
        1.关于轻量级/重量级
            轻量级和重量级是相对而言的
            XML相对于JSON的重量级体现在
            解析上
            XML目前设计了两种解析方式
            DOM&SAX
            JSON只提供整体解析方案
                这种方法只在解析较少的数据时才能起到良好效果
            XML提供对大规模数据的逐步解析方案
                这种方案很适合于对大量数据的处理
    引申XPath(用于在XML文档中通过属性和元素进行导航)
        一门在XML文档中查找信息的语言
        XPath用于在XML文档中通过属性和元素进行导航
    XPath
        1.XPath使用路径表达式在XML文档中进行导航
        2.XPath包含一个标准数据库
        3.XPath是XSLT中的主要元素
        4.XPath是一个W3C标准
17. JSON和JSONP
    - JSON(JavaScript Object Notation)
        一种轻量级的数据交换格式
    - JSONP(JavaScript With Padding) 被包裹的JSON
        一个非官方的协议 它允许在服务器端集成Scripttags返回至客户端 通过JavaScript callback形式实现跨域访问
18. 计算机网络体系结构
    OSI(Open System Interconnection 开放式系统互连)七层协议
        应用层：允许访问OSI环境的手段
    　　表示层：对数据进行翻译、加密和压缩
    　　会话层：建立、管理和终止会话
    　　传输层：提供端到端的可靠报文传递和错误恢复
    　　网络层：负责数据包从源到宿的传递和网际互连
        数据链路层
    　　物理层：通过媒介传输比特,确定机械及电气规范
    TCP/IP四层协议(现在广泛使用的)
        应用层(HTTP HTTPS各种应用层协议和TELNET FTP SMTP)
        运输层(TCP/UDP)
        网际层(IP)
        网络接口层
    五层协议(并不存在 讲课用)
        应用层
        传输层
        网络层
        数据链路层
        物理层
19. 后端接口设计
    一个后端接口大致分为四个部分
        接口地址 URL
        接口请求方式 get/post
        请求数据 request
        响应数据 response
    参数校验
        一个接口一般对参数(请求数据)都会进行安全校验
        1.业务层校验
            1.接收数据
            2.参数验证
            3.连接数据库
            4.根据数据库操作结果返回相应的信息
    错误码设计
        ctx.body={
            state:'success'/'fail'
        }
1. Nodejs解决跨域问题9种方案
    > 什么是跨域
    - 一个域下的文档或脚本尝试去请求另一个域下的资源 这里跨域是广义的
    > 广义的跨域
    1. 资源跳转: A链接 重定向 表单提交
    2. 资源嵌入: <link><script><img><frame>等dom标签 还有央视中background:url(),@font-face()等文件外链
    3. 脚本请求: JS发起的AJAX请求 dom和js对象的跨域操作
    > 狭义
    - 通常所说的跨域是狭义的 是由浏览器同源策略限制的一类请求场景
    > 同源策略/SOP(Same origin policy)是一种约定 由NetScape公司1995年引入浏览器 它是浏览器最核心也最基本的安全功能 如果缺少了同源策略 浏览器很容易瘦到XSS CSRF攻击 
    - 同源是指协议+域名+端口 
    > 同源策略限制行为
    1. Cookie LocalStorage 和IndexDB无法读取
    2. DOM和JS对象无法获得
    3. AJAX请求不能发送
    > axios发起请求
    ```
    axios.get('http://127.0.0.1:3000/user').then(res=>{
        console.log(res.sata)
    }).catch(err=>{
        console.log(err);
    })
    ```
    > 跨域常用解决方案
    1. 通过JSONP跨域
        - 通常为了减轻web服务器负载 把js css html等静态资源分离到另一台独立域名的服务器上 在html页面中再通过相应的标签从不同的域名下加载静态资源 二倍浏览器允许
        - 基于此 可以通过动态创建script 再请求一个带参数网址实现跨域通信
        - axois最新版本已经不支持jsonp了
    2. 跨域资源共享(CORS最常用)
    3. nginx代理跨域
        - 实现原理类似node中间件代理 需要搭建一个中转nginx服务器 用于转发请求
        - 使用nginx反向代理实现跨域是最简单的跨域方式 只要修改nginx的配置即可解决跨域问题 支持所有浏览器 支持session 不需要修改任何代码 并且不会影响服务器性能
        - 实现思路：通过nginx配置一个代理服务器(域名与domain1相同 端口不同)做跳板机 反向代理访问domain2接口 并且可以顺便修改cookie中domain信息 方便当前域cookie写入 实现跨域登录
    4. node中间件代理跨域
        - 实现原理
        - 同源策略是浏览器要遵循的标准 如果是服务器向服务器请求就无需遵循同源策略 代理服务器 需要做以下几个步骤
        1. 接受客户端请求
        2. 将请求转发给服务器
        3. 拿到服务器响应数据
        4. 将响应转发给客户端

    1. document.domain+iframe(只有在主域相同的时候才能使用该方法)
    2. 动态创建script标签(script标签不受同源策略限制)
    3. location.hash+iframe(利用location.hash来进行传值)
    4. window.name+iframe(name值在不同的页面加载后依旧存在 并且可以支持非常长的name值(2MB))
    5. postMessage(HTML5中的XMLHttpRequest Level2中的API)
    6. Web Socket(WebSocket是一种浏览器的API 它的目标是在一个单独的持久连接上提供全双工 双向通信(同源策略对web sockets不适用))
24. 单点登录 多点登录
    - 单点登录SSO
        一个多系统共存的环境下
        用户的一次登录能得到其他所有系统的信任
    - 多点登录
        以微信为例
            可以PC端 phone端同时登陆/收发消息
            但是一个端只能登录一个实例 
            pc1登录 pc2登录 后者会把前者踢出 
        同一个账号可以在不同终端同时登录 同时收发信息
        禁止用户多点在线
        一个端同一个账号只能登录一个实例  