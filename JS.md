1.JS有哪些数据类型，数据类型之间有哪些不同，判断数据类型的方法
    基本数据类型:String Number Boolean Undefined Null Symbol
    引用数据类型:Object(对象 数组 函数) 
    ES2020即ES11 又增加了新类型 BigInt
    区别：
        两者作为函数的参数进行传递时：
            基本数据类型传入的是数据的副本，原数据的更改不会影响传入后的数据。
            引用数据类型传入的是数据的引用地址，原数据的更改会影响传入后的数据。
        两者在内存中的存储位置：
            基本数据类型存储在栈中。
            引用数据类型在栈中存储了指针，该指针指向的数据实体存储在堆中。
    判断方法：
        1.typeof运算符判断类型
        typeof(null) //返回 object;
        null == undefined //返回true，因为undefined派生自null;
        null === undefined //返回false。
        2.A instanceof B可以用来判断A是否为B的实例，但它不能检测 null 和 undefined；
        3.B.constructor == A可以判断A是否为B的原型，但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。
        4.Object.prototype.toString.call() 是最准确最常用的方式。
2.浅拷贝和深拷贝都是什么含义，有什么不同，如何实现
    1.浅拷贝只复制指向某个对象的指针，而不复制对象本身。
        （1）Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝；
        （2）扩展运算符；
    2.深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。
         (1) 手写遍历递归赋值；
        （2）结合使用JSON.parse()和JSON.stringify()方法。
3.this的指向以及如何改变this的指向
4.call apply bind
首先要了解this的指向问题：
（1）this的指向不是在函数定义时确定的，而是在函数调用时确定，this默认情况下指向window，严格模式下为undefined
（2）使用new 调用构造函数时，构造函数内的this 指向新创建的对象
（3）通过 出call/apply/bind方法显式调用函数时，函数内this 指向指定的对象（第一个参数）
（4）通过上下文对象A调用函数时，函数内this指向对象A
5）箭头函数本身并不存在this，箭头函数的this的指向由它的外层作用域来决定的（指向外层作用域的this）
再来看call和apply、bind
作用：在函数调用时改变函数的执行上下文也就是this的值指向
区别：call采用不定长的参数列表，而apply使用一个参数数组。

5.实现继承的方法有哪些
    1.class+extends继承(ES6)
    2.原型继承
    3.借用构造函数继承
    4.寄生组合式继承
6.什么是闭包,闭包的作用是什么
7.什么是原型，原型链
    创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。
    当一个对象调用某个方法或者属性的时候，先在自身查找，如果找到就调用，如果没有就顺着__proto__到原型对象中查找，如果还没有就继续去原型的原型中查找，一直到null，这样形成一条链叫做原型链。如果还没有找到就返回undefined
8.什么是防抖和节流 如何实现
    防抖和节流都是防止短时间内高频触发事件的方案。
    防抖的原理是：如果一定时间内多次执行了某事件，则只执行其中的最后一次。
    节流的原理是：要执行的事件每隔一段时间会被冷却，无法执行。
    应用场景有：搜索框实时搜索，滚动改变相关的事件。
4.什么是执行上下文和执行栈
    变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。
    每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。
5.什么是作用域和作用域链？
6.作用域和执行上下文的区别是什么？

2.给DOM元素绑定事件有哪几种方法
    1.普通方式
        元素标签内直接写事件+相应事件触发后的方法调用 这里的事件前面需要加上“on”。
    2.动态绑定方式
        动态事件绑定，需要先获取dom元素再绑定事件，获取dom元素可以参看原生js获取dom对象
        动态事件绑定存在内存泄露，所以务必要注意回收。
    3.监听方式
        使用addEventListener方法，该方法有三个参数：事件的类型、监听的函数、事件的冒泡和捕获控制（true/false）
        注：addEventListener方法的第三个参数默认值为false。
3.事件冒泡和捕获
    事件冒泡:(从里向外)
        事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。简而言之，就是由里向外进行冒泡。
    事件捕获:(从外向里)
        是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于事件到达预定目标之前捕获它。
10.为什么JavaScript是单线程
JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。
JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
11.数组去重
12.数组操作
13.JS哪些操作会造成内存泄露
内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。 

意外的全局变量 
闭包 
没有清理的dom元素 dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中 
被遗忘的定时器或者回调
14.说几条写JavaScript的规范