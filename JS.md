1.JS有哪些数据类型，数据类型之间有哪些不同，判断数据类型的方法
    基本数据类型:String Number Boolean Undefined Null Symbol
    引用数据类型:Object(对象 数组 函数) 
    ES2020即ES11 又增加了新类型 BigInt
    区别：
        两者作为函数的参数进行传递时：
            基本数据类型传入的是数据的副本，原数据的更改不会影响传入后的数据。
            引用数据类型传入的是数据的引用地址，原数据的更改会影响传入后的数据。
        两者在内存中的存储位置：
            基本数据类型存储在栈中。
            引用数据类型在栈中存储了指针，该指针指向的数据实体存储在堆中。
    判断方法：
        1.typeof运算符判断类型
        typeof(null) //返回 object;
        null == undefined //返回true，因为undefined派生自null;
        null === undefined //返回false。
        2.A instanceof B可以用来判断A是否为B的实例，但它不能检测 null 和 undefined；
        3.B.constructor == A可以判断A是否为B的原型，但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。
        4.Object.prototype.toString.call() 是最准确最常用的方式。
2.浅拷贝和深拷贝都是什么含义，有什么不同，如何实现
    1.浅拷贝只复制指向某个对象的指针，而不复制对象本身。
        （1）Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝；
        （2）扩展运算符；
    2.深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。
         (1) 手写遍历递归赋值；
        （2）结合使用JSON.parse()和JSON.stringify()方法。
3.如何理解JS中的this关键字，this的指向以及如何改变this的指向
    this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象
    全局环境：this始终指向window对象
    局部环境：
            1.全局作用域下直接调用函数，this指向window
            2.对象函数调用，那个对象调用就指向那个对象
            3.使用 new 实例化对象，在构造函数中的this指向实例化对象。
            4.使用call或apply改变this的指向。
4.call apply bind
    首先要了解this的指向问题：
        （1）this的指向不是在函数定义时确定的，而是在函数调用时确定，this默认情况下指向window，严格模式下为undefined
        （2）使用new 调用构造函数时，构造函数内的this 指向新创建的对象
        （3）通过 出call/apply/bind方法显式调用函数时，函数内this 指向指定的对象（第一个参数）
        （4）通过上下文对象A调用函数时，函数内this指向对象A
        5）箭头函数本身并不存在this，箭头函数的this的指向由它的外层作用域来决定的（指向外层作用域的this）
        再来看call和apply、bind
        作用：在函数调用时改变函数的执行上下文也就是this的值指向
        区别：call采用不定长的参数列表，而apply使用一个参数数组。
5.JavaScript中的作用域(scope)是什么
    在 JavaScript 中，每个函数都有自己的作用域。作用域基本上是变量以及如何通过名称访问这些变量的规则的集合。只有函数中的代码才能访问函数作用域内的变量。
    同一个作用域中的变量名必须是唯一的。一个作用域可以嵌套在另一个作用域内。如果一个作用域嵌套在另一个作用域内，最内部作用域内的代码可以访问另一个作用域的变量。

5.实现继承的方法有哪些
    1.class+extends继承(ES6)
    2.原型继承
    3.借用构造函数继承
    4.寄生组合式继承
6.什么是闭包,闭包的作用是什么
在外部函数的内部声明内部函数，在内部函数里引用了外部函数中的局部变量，当外部函数调用完毕后，局部变量不被释放
7.什么是原型，原型链
    创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。
    当一个对象调用某个方法或者属性的时候，先在自身查找，如果找到就调用，如果没有就顺着__proto__到原型对象中查找，如果还没有就继续去原型的原型中查找，一直到null，这样形成一条链叫做原型链。如果还没有找到就返回undefined
8.什么是防抖和节流 如何实现
    防抖和节流都是防止短时间内高频触发事件的方案。
    防抖的原理是：如果一定时间内多次执行了某事件，则只执行其中的最后一次。
    节流的原理是：要执行的事件每隔一段时间会被冷却，无法执行。
    应用场景有：搜索框实时搜索，滚动改变相关的事件。
4.什么是执行上下文和执行栈
    变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。
    每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。
5.什么是作用域和作用域链？
6.作用域和执行上下文的区别是什么？

2.给DOM元素绑定事件有哪几种方法
    1.普通方式
        元素标签内直接写事件+相应事件触发后的方法调用 这里的事件前面需要加上“on”。
    2.动态绑定方式
        动态事件绑定，需要先获取dom元素再绑定事件，获取dom元素可以参看原生js获取dom对象
        动态事件绑定存在内存泄露，所以务必要注意回收。
    3.监听方式
        使用addEventListener方法，该方法有三个参数：事件的类型、监听的函数、事件的冒泡和捕获控制（true/false）
        注：addEventListener方法的第三个参数默认值为false。
3.事件冒泡和捕获
    事件冒泡:(从里向外)
        事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。简而言之，就是由里向外进行冒泡。
    事件捕获:(从外向里)
        是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于事件到达预定目标之前捕获它。
10.为什么JavaScript是单线程
JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。
JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
11.数组去重
12.数组操作
13.JS哪些操作会造成内存泄露
内存泄漏是指一块被分配的内存既不能使用，也不能回收，直到浏览器进程结束。 

意外的全局变量 
闭包 
没有清理的dom元素 dom元素赋值给变量，又通过removeChild移除dom元素。但是dom元素的引用还在内存中 
被遗忘的定时器或者回调
14.说几条写JavaScript的规范
15.JS有哪些作用域
    全局作用域 window
    函数作用域 function
    块级作用域 {} ES6新增
        使用let ,const 定义的变量或常量。会形成块级作用域。
16.词法作用域
    指函数在定义(或声明)他们的作用域中运行
    而不是在执行(或调用)他们的作用域里运行
17.==与===的区别
    1.== 相等 值相等
    2.=== 恒相等 类型和值都相等
    3.js在比较时 
        ==会先做类型转换 再判断值的大小
        === 类型和值都必须相等
18.严格模式
    严格模式用于标准化正常的JavaScript语义。严格模式可以嵌入到非严格模式中，关键字 ‘use strict’。使用严格模式后的代码应遵循JS严格的语法规则。例如，分号在每个语句声明之后使用。
19.null undefined
    已经声明但是尚未初始化：undefined；
    空对象的引用：null。
20.事件冒泡 阻止方式
    事件冒泡是指嵌套最深的元素触发一个事件，然后这个事件顺着嵌套顺序在父元素上触发。
    防止事件冒泡的一种方法是使用 event.stopPropagation()或 event.cancelBubble （低于 IE 9）。
21.作用域链的理解
    作用域链是js中的一种查找机制，从当前作用域查找，当前作用域没有往上一级作用域查找，一直到最外层，如果都找不到则是is not define
22.定时器的分类，区别及作用
    Js中有两种定时器：setInterval：间歇执行，setTimeout：延迟执行  
23.offsetWidth、clientWidth、scrollTop的区别
    offsetWidth：占位宽，包含 内容宽+左右padding+左右border
    clientWidth：可视宽，包含 内容宽+左右padding
    scrollTop：页面被卷去的高
24.事件、IE与火狐的事件机制有什么区别？
    IE的事件流是冒泡流，而火狐同时支持冒泡流和捕获流。
25.事件绑定和普通事件有什么区别。
    标签.事件：如果给同一个元素添加同一个事件，后面的会覆盖前面
    事件绑定：可以给同一个元素添加同一个事件，不会被覆盖
26.解释一下事件流？
    事件捕获阶段：当事件发生的时候，将事件从window依次往子元素传递
    确定目标阶段：确定事件目标
    事件冒泡阶段：事件目标开始处理事件，处理完以后会将事件依次传递给父元素，一直到window
    事件都是在事件冒泡处理,ie只有冒泡
27.拖拽效果中有几种事件？
    按下onmousedown，拖拽onmousemove，弹起onmouseup
28.js哪些操作会造成内存泄露？
    1）意外的全局变量引起的内存泄露
    function leak(){ leak=“xxx”;//leak成为一个全局变量，不会被回收 }
    2）被遗忘的定时器或者回调
    3）闭包引起的内存泄漏


